Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON programT
Rule 2     programT -> class programT
Rule 3     programT -> vars programF
Rule 4     programT -> programF
Rule 5     programF -> func programF
Rule 6     programF -> main empty
Rule 7     class -> CLASS ID classT
Rule 8     classT -> LESS INHERIT ID GREATER classF
Rule 9     classT -> classF
Rule 10    classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty
Rule 11    vars -> VARS dec empty
Rule 12    dec -> VAR arr decF
Rule 13    dec -> VAR decF
Rule 14    decF -> COMMA dec
Rule 15    decF -> COLON type SEMICOLON dec
Rule 16    decF -> COLON type SEMICOLON empty
Rule 17    type -> INT empty
Rule 18    type -> FLOAT empty
Rule 19    type -> CHAR empty
Rule 20    type -> STRING empty
Rule 21    type -> ID empty
Rule 22    arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
Rule 23    arr -> L_BREAK CTE_INT R_BREAK empty
Rule 24    func -> typeFunc FUNCTION ID L_PAR funcF
Rule 25    funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 26    funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 27    typeFunc -> INT empty
Rule 28    typeFunc -> FLOAT empty
Rule 29    typeFunc -> CHAR empty
Rule 30    typeFunc -> STRING empty
Rule 31    typeFunc -> ID empty
Rule 32    typeFunc -> VOID empty
Rule 33    parameter -> VAR COLON typepar SEMICOLON parameterF
Rule 34    parameterF -> parameter
Rule 35    parameterF -> empty
Rule 36    typepar -> INT empty
Rule 37    typepar -> FLOAT empty
Rule 38    typepar -> CHAR empty
Rule 39    typepar -> STRING empty
Rule 40    typepar -> ID empty
Rule 41    main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
Rule 42    statement -> assigment statementF
Rule 43    statement -> void statementF
Rule 44    statement -> return statementF
Rule 45    statement -> read statementF
Rule 46    statement -> write statementF
Rule 47    statement -> if statementF
Rule 48    statement -> repeat statementF
Rule 49    statementF -> statement
Rule 50    statementF -> empty
Rule 51    void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty
Rule 52    void -> ID L_PAR param R_PAR SEMICOLON empty
Rule 53    arrfunc -> L_BREAK exp COMMA exp R_BREAK empty
Rule 54    arrfunc -> L_BREAK exp R_BREAK empty
Rule 55    param -> var paramF
Rule 56    paramF -> COMMA param
Rule 57    paramF -> empty
Rule 58    return -> RETURN L_PAR exp R_PAR SEMICOLON empty
Rule 59    var -> VAR varF
Rule 60    var -> ID DOT VAR varF
Rule 61    varF -> arrfunc empty
Rule 62    varF -> empty
Rule 63    read -> READ L_PAR readF
Rule 64    readF -> var COMMA readF
Rule 65    readF -> var R_PAR SEMICOLON empty
Rule 66    write -> WRITE L_PAR writeT
Rule 67    writeT -> CTE_STRING writeF
Rule 68    writeT -> exp writeF
Rule 69    writeF -> COMMA writeT
Rule 70    writeF -> R_PAR SEMICOLON empty
Rule 71    repeat -> conditional empty
Rule 72    repeat -> nonconditional empty
Rule 73    if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
Rule 74    ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 75    ifF -> empty
Rule 76    assigment -> var assigmentF
Rule 77    assigmentF -> EQUAL exp empty
Rule 78    assigmentF -> ope exp empty
Rule 79    ope -> PLUS_EQ empty
Rule 80    ope -> MIN_EQ empty
Rule 81    ope -> MULT_EQ empty
Rule 82    ope -> DIV_EQ empty
Rule 83    conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 84    nonconditional -> FROM VAR arrfunc nonconditionalF
Rule 85    nonconditional -> FROM VAR nonconditionalF
Rule 86    nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 87    bool -> OR exp empty
Rule 88    bool -> AND exp empty
Rule 89    exp -> ex expT
Rule 90    expT -> LESS expf
Rule 91    expT -> GREATER expf
Rule 92    expT -> LESS_TH expf
Rule 93    expT -> GREAT_TH expf
Rule 94    expT -> SAME expf
Rule 95    expT -> DIF expf
Rule 96    expT -> empty
Rule 97    expf -> ex empty
Rule 98    expf -> ex bool empty
Rule 99    ex -> term exF
Rule 100   exF -> PLUS ex
Rule 101   exF -> MINUS ex
Rule 102   exF -> empty
Rule 103   term -> factor termF
Rule 104   termF -> MULT term
Rule 105   termF -> DIV term
Rule 106   termF -> empty
Rule 107   factor -> L_PAR exp R_PAR empty
Rule 108   factor -> factorT
Rule 109   factorT -> PLUS factorF
Rule 110   factorT -> MINUS factorF
Rule 111   factorT -> factorF
Rule 112   factorF -> varcte empty
Rule 113   varcte -> var empty
Rule 114   varcte -> CTE_INT empty
Rule 115   varcte -> CTE_FLOAT empty
Rule 116   varcte -> CTE_STRING empty
Rule 117   empty -> <empty>

Terminals, with rules where they appear

AND                  : 88
ATTRIBUTES           : 10
CHAR                 : 19 29 38
CLASS                : 7
COLON                : 15 16 33
COMMA                : 14 22 53 56 64 69
CTE_FLOAT            : 115
CTE_INT              : 22 22 23 114
CTE_STRING           : 67 116
DIF                  : 95
DIV                  : 105
DIV_EQ               : 82
DO                   : 83 86
DOT                  : 51 60
ELSE                 : 74
EQUAL                : 77
FLOAT                : 18 28 37
FROM                 : 84 85
FUNCTION             : 24
GREATER              : 8 91
GREAT_TH             : 93
ID                   : 1 7 8 21 24 31 40 51 51 52 60
IF                   : 73
INHERIT              : 8
INT                  : 17 27 36
LESS                 : 8 90
LESS_TH              : 92
L_BREAK              : 22 23 53 54
L_CURPAR             : 10 25 26 41 73 74 83 86
L_PAR                : 24 41 51 52 58 63 66 73 83 107
MAIN                 : 41
METHODS              : 10
MINUS                : 101 110
MIN_EQ               : 80
MULT                 : 104
MULT_EQ              : 81
OR                   : 87
PLUS                 : 100 109
PLUS_EQ              : 79
PROGRAM              : 1
READ                 : 63
RETURN               : 58
R_BREAK              : 22 23 53 54
R_CURPAR             : 10 25 26 41 73 74 83 86
R_PAR                : 25 26 41 51 52 58 65 70 73 83 107
SAME                 : 94
SEMICOLON            : 1 10 10 15 16 25 26 33 51 52 58 65 70 73 74 83 86
STRING               : 20 30 39
THEN                 : 73
TO                   : 86
VAR                  : 12 13 33 59 60 84 85
VARS                 : 11
VOID                 : 32
WHILE                : 83
WRITE                : 66
error                : 

Nonterminals, with rules where they appear

arr                  : 12
arrfunc              : 61 84
assigment            : 42
assigmentF           : 76
bool                 : 98
class                : 2
classF               : 8 9
classT               : 7
conditional          : 71
dec                  : 10 11 14 15 25 26
decF                 : 12 13
empty                : 6 10 11 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 35 36 37 38 39 40 41 50 51 52 53 54 57 58 61 62 65 70 71 72 74 75 77 78 79 80 81 82 83 86 87 88 96 97 98 102 106 107 112 113 114 115 116
ex                   : 89 97 98 100 101
exF                  : 99
exp                  : 53 53 54 58 68 73 77 78 83 86 86 87 88 107
expT                 : 89
expf                 : 90 91 92 93 94 95
factor               : 103
factorF              : 109 110 111
factorT              : 108
func                 : 5 10
funcF                : 24
if                   : 47
ifF                  : 73
main                 : 6
nonconditional       : 72
nonconditionalF      : 84 85
ope                  : 78
param                : 51 52 56
paramF               : 55
parameter            : 25 34
parameterF           : 33
program              : 0
programF             : 3 4 5
programT             : 1 2
read                 : 45
readF                : 63 64
repeat               : 48
return               : 44
statement            : 25 26 41 49 73 74 83 86
statementF           : 42 43 44 45 46 47 48
term                 : 99 104 105
termF                : 103
type                 : 15 16
typeFunc             : 24
typepar              : 33
var                  : 55 64 65 76 113
varF                 : 59 60
varcte               : 112
vars                 : 3
void                 : 43
write                : 46
writeF               : 67 68
writeT               : 66 69

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON programT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON programT

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID L_PAR funcF
    (41) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . STRING empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 10
    VARS            shift and go to state 11
    MAIN            shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    STRING          shift and go to state 19
    ID              shift and go to state 5
    VOID            shift and go to state 20

    programT                       shift and go to state 6
    class                          shift and go to state 7
    vars                           shift and go to state 8
    programF                       shift and go to state 9
    func                           shift and go to state 12
    main                           shift and go to state 13
    typeFunc                       shift and go to state 14

state 5

    (31) typeFunc -> ID . empty
    (117) empty -> .

    FUNCTION        reduce using rule 117 (empty -> .)

    empty                          shift and go to state 21

state 6

    (1) program -> PROGRAM ID SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON programT .)


state 7

    (2) programT -> class . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID L_PAR funcF
    (41) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . STRING empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 10
    VARS            shift and go to state 11
    MAIN            shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    STRING          shift and go to state 19
    ID              shift and go to state 5
    VOID            shift and go to state 20

    class                          shift and go to state 7
    programT                       shift and go to state 22
    vars                           shift and go to state 8
    programF                       shift and go to state 9
    func                           shift and go to state 12
    main                           shift and go to state 13
    typeFunc                       shift and go to state 14

state 8

    (3) programT -> vars . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID L_PAR funcF
    (41) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . STRING empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    STRING          shift and go to state 19
    ID              shift and go to state 5
    VOID            shift and go to state 20

    programF                       shift and go to state 23
    func                           shift and go to state 12
    main                           shift and go to state 13
    typeFunc                       shift and go to state 14

state 9

    (4) programT -> programF .

    $end            reduce using rule 4 (programT -> programF .)


state 10

    (7) class -> CLASS . ID classT

    ID              shift and go to state 24


state 11

    (11) vars -> VARS . dec empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 26

    dec                            shift and go to state 25

state 12

    (5) programF -> func . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID L_PAR funcF
    (41) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . STRING empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    STRING          shift and go to state 19
    ID              shift and go to state 5
    VOID            shift and go to state 20

    func                           shift and go to state 12
    programF                       shift and go to state 27
    main                           shift and go to state 13
    typeFunc                       shift and go to state 14

state 13

    (6) programF -> main . empty
    (117) empty -> .

    $end            reduce using rule 117 (empty -> .)

    empty                          shift and go to state 28

state 14

    (24) func -> typeFunc . FUNCTION ID L_PAR funcF

    FUNCTION        shift and go to state 29


state 15

    (41) main -> MAIN . L_PAR R_PAR L_CURPAR statement R_CURPAR empty

    L_PAR           shift and go to state 30


state 16

    (27) typeFunc -> INT . empty
    (117) empty -> .

    FUNCTION        reduce using rule 117 (empty -> .)

    empty                          shift and go to state 31

state 17

    (28) typeFunc -> FLOAT . empty
    (117) empty -> .

    FUNCTION        reduce using rule 117 (empty -> .)

    empty                          shift and go to state 32

state 18

    (29) typeFunc -> CHAR . empty
    (117) empty -> .

    FUNCTION        reduce using rule 117 (empty -> .)

    empty                          shift and go to state 33

state 19

    (30) typeFunc -> STRING . empty
    (117) empty -> .

    FUNCTION        reduce using rule 117 (empty -> .)

    empty                          shift and go to state 34

state 20

    (32) typeFunc -> VOID . empty
    (117) empty -> .

    FUNCTION        reduce using rule 117 (empty -> .)

    empty                          shift and go to state 35

state 21

    (31) typeFunc -> ID empty .

    FUNCTION        reduce using rule 31 (typeFunc -> ID empty .)


state 22

    (2) programT -> class programT .

    $end            reduce using rule 2 (programT -> class programT .)


state 23

    (3) programT -> vars programF .

    $end            reduce using rule 3 (programT -> vars programF .)


state 24

    (7) class -> CLASS ID . classT
    (8) classT -> . LESS INHERIT ID GREATER classF
    (9) classT -> . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    LESS            shift and go to state 37
    SEMICOLON       shift and go to state 39

    classT                         shift and go to state 36
    classF                         shift and go to state 38

state 25

    (11) vars -> VARS dec . empty
    (117) empty -> .

    MAIN            reduce using rule 117 (empty -> .)
    INT             reduce using rule 117 (empty -> .)
    FLOAT           reduce using rule 117 (empty -> .)
    CHAR            reduce using rule 117 (empty -> .)
    STRING          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    VOID            reduce using rule 117 (empty -> .)

    empty                          shift and go to state 40

state 26

    (12) dec -> VAR . arr decF
    (13) dec -> VAR . decF
    (22) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> . L_BREAK CTE_INT R_BREAK empty
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type SEMICOLON dec
    (16) decF -> . COLON type SEMICOLON empty

    L_BREAK         shift and go to state 43
    COMMA           shift and go to state 44
    COLON           shift and go to state 45

    arr                            shift and go to state 41
    decF                           shift and go to state 42

state 27

    (5) programF -> func programF .

    $end            reduce using rule 5 (programF -> func programF .)


state 28

    (6) programF -> main empty .

    $end            reduce using rule 6 (programF -> main empty .)


state 29

    (24) func -> typeFunc FUNCTION . ID L_PAR funcF

    ID              shift and go to state 46


state 30

    (41) main -> MAIN L_PAR . R_PAR L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 47


state 31

    (27) typeFunc -> INT empty .

    FUNCTION        reduce using rule 27 (typeFunc -> INT empty .)


state 32

    (28) typeFunc -> FLOAT empty .

    FUNCTION        reduce using rule 28 (typeFunc -> FLOAT empty .)


state 33

    (29) typeFunc -> CHAR empty .

    FUNCTION        reduce using rule 29 (typeFunc -> CHAR empty .)


state 34

    (30) typeFunc -> STRING empty .

    FUNCTION        reduce using rule 30 (typeFunc -> STRING empty .)


state 35

    (32) typeFunc -> VOID empty .

    FUNCTION        reduce using rule 32 (typeFunc -> VOID empty .)


state 36

    (7) class -> CLASS ID classT .

    CLASS           reduce using rule 7 (class -> CLASS ID classT .)
    VARS            reduce using rule 7 (class -> CLASS ID classT .)
    MAIN            reduce using rule 7 (class -> CLASS ID classT .)
    INT             reduce using rule 7 (class -> CLASS ID classT .)
    FLOAT           reduce using rule 7 (class -> CLASS ID classT .)
    CHAR            reduce using rule 7 (class -> CLASS ID classT .)
    STRING          reduce using rule 7 (class -> CLASS ID classT .)
    ID              reduce using rule 7 (class -> CLASS ID classT .)
    VOID            reduce using rule 7 (class -> CLASS ID classT .)


state 37

    (8) classT -> LESS . INHERIT ID GREATER classF

    INHERIT         shift and go to state 48


state 38

    (9) classT -> classF .

    CLASS           reduce using rule 9 (classT -> classF .)
    VARS            reduce using rule 9 (classT -> classF .)
    MAIN            reduce using rule 9 (classT -> classF .)
    INT             reduce using rule 9 (classT -> classF .)
    FLOAT           reduce using rule 9 (classT -> classF .)
    CHAR            reduce using rule 9 (classT -> classF .)
    STRING          reduce using rule 9 (classT -> classF .)
    ID              reduce using rule 9 (classT -> classF .)
    VOID            reduce using rule 9 (classT -> classF .)


state 39

    (10) classF -> SEMICOLON . L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    L_CURPAR        shift and go to state 49


state 40

    (11) vars -> VARS dec empty .

    MAIN            reduce using rule 11 (vars -> VARS dec empty .)
    INT             reduce using rule 11 (vars -> VARS dec empty .)
    FLOAT           reduce using rule 11 (vars -> VARS dec empty .)
    CHAR            reduce using rule 11 (vars -> VARS dec empty .)
    STRING          reduce using rule 11 (vars -> VARS dec empty .)
    ID              reduce using rule 11 (vars -> VARS dec empty .)
    VOID            reduce using rule 11 (vars -> VARS dec empty .)


state 41

    (12) dec -> VAR arr . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type SEMICOLON dec
    (16) decF -> . COLON type SEMICOLON empty

    COMMA           shift and go to state 44
    COLON           shift and go to state 45

    decF                           shift and go to state 50

state 42

    (13) dec -> VAR decF .

    MAIN            reduce using rule 13 (dec -> VAR decF .)
    INT             reduce using rule 13 (dec -> VAR decF .)
    FLOAT           reduce using rule 13 (dec -> VAR decF .)
    CHAR            reduce using rule 13 (dec -> VAR decF .)
    STRING          reduce using rule 13 (dec -> VAR decF .)
    ID              reduce using rule 13 (dec -> VAR decF .)
    VOID            reduce using rule 13 (dec -> VAR decF .)
    METHODS         reduce using rule 13 (dec -> VAR decF .)
    L_CURPAR        reduce using rule 13 (dec -> VAR decF .)


state 43

    (22) arr -> L_BREAK . CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 51


state 44

    (14) decF -> COMMA . dec
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 26

    dec                            shift and go to state 52

state 45

    (15) decF -> COLON . type SEMICOLON dec
    (16) decF -> COLON . type SEMICOLON empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . STRING empty
    (21) type -> . ID empty

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    CHAR            shift and go to state 56
    STRING          shift and go to state 57
    ID              shift and go to state 58

    type                           shift and go to state 53

state 46

    (24) func -> typeFunc FUNCTION ID . L_PAR funcF

    L_PAR           shift and go to state 59


state 47

    (41) main -> MAIN L_PAR R_PAR . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 60


state 48

    (8) classT -> LESS INHERIT . ID GREATER classF

    ID              shift and go to state 61


state 49

    (10) classF -> SEMICOLON L_CURPAR . ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    ATTRIBUTES      shift and go to state 62


state 50

    (12) dec -> VAR arr decF .

    MAIN            reduce using rule 12 (dec -> VAR arr decF .)
    INT             reduce using rule 12 (dec -> VAR arr decF .)
    FLOAT           reduce using rule 12 (dec -> VAR arr decF .)
    CHAR            reduce using rule 12 (dec -> VAR arr decF .)
    STRING          reduce using rule 12 (dec -> VAR arr decF .)
    ID              reduce using rule 12 (dec -> VAR arr decF .)
    VOID            reduce using rule 12 (dec -> VAR arr decF .)
    METHODS         reduce using rule 12 (dec -> VAR arr decF .)
    L_CURPAR        reduce using rule 12 (dec -> VAR arr decF .)


state 51

    (22) arr -> L_BREAK CTE_INT . COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK CTE_INT . R_BREAK empty

    COMMA           shift and go to state 63
    R_BREAK         shift and go to state 64


state 52

    (14) decF -> COMMA dec .

    MAIN            reduce using rule 14 (decF -> COMMA dec .)
    INT             reduce using rule 14 (decF -> COMMA dec .)
    FLOAT           reduce using rule 14 (decF -> COMMA dec .)
    CHAR            reduce using rule 14 (decF -> COMMA dec .)
    STRING          reduce using rule 14 (decF -> COMMA dec .)
    ID              reduce using rule 14 (decF -> COMMA dec .)
    VOID            reduce using rule 14 (decF -> COMMA dec .)
    METHODS         reduce using rule 14 (decF -> COMMA dec .)
    L_CURPAR        reduce using rule 14 (decF -> COMMA dec .)


state 53

    (15) decF -> COLON type . SEMICOLON dec
    (16) decF -> COLON type . SEMICOLON empty

    SEMICOLON       shift and go to state 65


state 54

    (17) type -> INT . empty
    (117) empty -> .

    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 66

state 55

    (18) type -> FLOAT . empty
    (117) empty -> .

    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 67

state 56

    (19) type -> CHAR . empty
    (117) empty -> .

    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 68

state 57

    (20) type -> STRING . empty
    (117) empty -> .

    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 69

state 58

    (21) type -> ID . empty
    (117) empty -> .

    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 70

state 59

    (24) func -> typeFunc FUNCTION ID L_PAR . funcF
    (25) funcF -> . parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (26) funcF -> . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (33) parameter -> . VAR COLON typepar SEMICOLON parameterF

    R_PAR           shift and go to state 73
    VAR             shift and go to state 74

    funcF                          shift and go to state 71
    parameter                      shift and go to state 72

state 60

    (41) main -> MAIN L_PAR R_PAR L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    statement                      shift and go to state 75
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 61

    (8) classT -> LESS INHERIT ID . GREATER classF

    GREATER         shift and go to state 94


state 62

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES . dec METHODS func R_CURPAR SEMICOLON empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 26

    dec                            shift and go to state 95

state 63

    (22) arr -> L_BREAK CTE_INT COMMA . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 96


state 64

    (23) arr -> L_BREAK CTE_INT R_BREAK . empty
    (117) empty -> .

    COMMA           reduce using rule 117 (empty -> .)
    COLON           reduce using rule 117 (empty -> .)

    empty                          shift and go to state 97

state 65

    (15) decF -> COLON type SEMICOLON . dec
    (16) decF -> COLON type SEMICOLON . empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF
    (117) empty -> .

    VAR             shift and go to state 26
    MAIN            reduce using rule 117 (empty -> .)
    INT             reduce using rule 117 (empty -> .)
    FLOAT           reduce using rule 117 (empty -> .)
    CHAR            reduce using rule 117 (empty -> .)
    STRING          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    VOID            reduce using rule 117 (empty -> .)
    METHODS         reduce using rule 117 (empty -> .)
    L_CURPAR        reduce using rule 117 (empty -> .)

    dec                            shift and go to state 98
    empty                          shift and go to state 99

state 66

    (17) type -> INT empty .

    SEMICOLON       reduce using rule 17 (type -> INT empty .)


state 67

    (18) type -> FLOAT empty .

    SEMICOLON       reduce using rule 18 (type -> FLOAT empty .)


state 68

    (19) type -> CHAR empty .

    SEMICOLON       reduce using rule 19 (type -> CHAR empty .)


state 69

    (20) type -> STRING empty .

    SEMICOLON       reduce using rule 20 (type -> STRING empty .)


state 70

    (21) type -> ID empty .

    SEMICOLON       reduce using rule 21 (type -> ID empty .)


state 71

    (24) func -> typeFunc FUNCTION ID L_PAR funcF .

    MAIN            reduce using rule 24 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    INT             reduce using rule 24 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    FLOAT           reduce using rule 24 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    CHAR            reduce using rule 24 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    STRING          reduce using rule 24 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    ID              reduce using rule 24 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    VOID            reduce using rule 24 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    R_CURPAR        reduce using rule 24 (func -> typeFunc FUNCTION ID L_PAR funcF .)


state 72

    (25) funcF -> parameter . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 100


state 73

    (26) funcF -> R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 101


state 74

    (33) parameter -> VAR . COLON typepar SEMICOLON parameterF

    COLON           shift and go to state 102


state 75

    (41) main -> MAIN L_PAR R_PAR L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 103


state 76

    (42) statement -> assigment . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (117) empty -> .
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    assigment                      shift and go to state 76
    statementF                     shift and go to state 104
    statement                      shift and go to state 105
    empty                          shift and go to state 106
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 77

    (43) statement -> void . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (117) empty -> .
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    void                           shift and go to state 77
    statementF                     shift and go to state 107
    statement                      shift and go to state 105
    empty                          shift and go to state 106
    assigment                      shift and go to state 76
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 78

    (44) statement -> return . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (117) empty -> .
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    return                         shift and go to state 78
    statementF                     shift and go to state 108
    statement                      shift and go to state 105
    empty                          shift and go to state 106
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 79

    (45) statement -> read . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (117) empty -> .
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    read                           shift and go to state 79
    statementF                     shift and go to state 109
    statement                      shift and go to state 105
    empty                          shift and go to state 106
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 80

    (46) statement -> write . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (117) empty -> .
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    write                          shift and go to state 80
    statementF                     shift and go to state 110
    statement                      shift and go to state 105
    empty                          shift and go to state 106
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 81

    (47) statement -> if . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (117) empty -> .
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    if                             shift and go to state 81
    statementF                     shift and go to state 111
    statement                      shift and go to state 105
    empty                          shift and go to state 106
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 82

    (48) statement -> repeat . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (117) empty -> .
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    repeat                         shift and go to state 82
    statementF                     shift and go to state 112
    statement                      shift and go to state 105
    empty                          shift and go to state 106
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 83

    (76) assigment -> var . assigmentF
    (77) assigmentF -> . EQUAL exp empty
    (78) assigmentF -> . ope exp empty
    (79) ope -> . PLUS_EQ empty
    (80) ope -> . MIN_EQ empty
    (81) ope -> . MULT_EQ empty
    (82) ope -> . DIV_EQ empty

    EQUAL           shift and go to state 114
    PLUS_EQ         shift and go to state 116
    MIN_EQ          shift and go to state 117
    MULT_EQ         shift and go to state 118
    DIV_EQ          shift and go to state 119

    assigmentF                     shift and go to state 113
    ope                            shift and go to state 115

state 84

    (51) void -> ID . DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> ID . L_PAR param R_PAR SEMICOLON empty
    (60) var -> ID . DOT VAR varF

    DOT             shift and go to state 120
    L_PAR           shift and go to state 121


state 85

    (58) return -> RETURN . L_PAR exp R_PAR SEMICOLON empty

    L_PAR           shift and go to state 122


state 86

    (63) read -> READ . L_PAR readF

    L_PAR           shift and go to state 123


state 87

    (66) write -> WRITE . L_PAR writeT

    L_PAR           shift and go to state 124


state 88

    (73) if -> IF . L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_PAR           shift and go to state 125


state 89

    (71) repeat -> conditional . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 126

state 90

    (72) repeat -> nonconditional . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 127

state 91

    (59) var -> VAR . varF
    (61) varF -> . arrfunc empty
    (62) varF -> . empty
    (53) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (54) arrfunc -> . L_BREAK exp R_BREAK empty
    (117) empty -> .

    L_BREAK         shift and go to state 131
    EQUAL           reduce using rule 117 (empty -> .)
    PLUS_EQ         reduce using rule 117 (empty -> .)
    MIN_EQ          reduce using rule 117 (empty -> .)
    MULT_EQ         reduce using rule 117 (empty -> .)
    DIV_EQ          reduce using rule 117 (empty -> .)
    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    varF                           shift and go to state 128
    arrfunc                        shift and go to state 129
    empty                          shift and go to state 130

state 92

    (83) conditional -> WHILE . L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    L_PAR           shift and go to state 132


state 93

    (84) nonconditional -> FROM . VAR arrfunc nonconditionalF
    (85) nonconditional -> FROM . VAR nonconditionalF

    VAR             shift and go to state 133


state 94

    (8) classT -> LESS INHERIT ID GREATER . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    SEMICOLON       shift and go to state 39

    classF                         shift and go to state 134

state 95

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec . METHODS func R_CURPAR SEMICOLON empty

    METHODS         shift and go to state 135


state 96

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT . R_BREAK empty

    R_BREAK         shift and go to state 136


state 97

    (23) arr -> L_BREAK CTE_INT R_BREAK empty .

    COMMA           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    COLON           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)


state 98

    (15) decF -> COLON type SEMICOLON dec .

    MAIN            reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    INT             reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    FLOAT           reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    CHAR            reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    STRING          reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    ID              reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    VOID            reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    METHODS         reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    L_CURPAR        reduce using rule 15 (decF -> COLON type SEMICOLON dec .)


state 99

    (16) decF -> COLON type SEMICOLON empty .

    MAIN            reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    INT             reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    FLOAT           reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    CHAR            reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    STRING          reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    ID              reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    VOID            reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    METHODS         reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    L_CURPAR        reduce using rule 16 (decF -> COLON type SEMICOLON empty .)


state 100

    (25) funcF -> parameter R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 137


state 101

    (26) funcF -> R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 26

    dec                            shift and go to state 138

state 102

    (33) parameter -> VAR COLON . typepar SEMICOLON parameterF
    (36) typepar -> . INT empty
    (37) typepar -> . FLOAT empty
    (38) typepar -> . CHAR empty
    (39) typepar -> . STRING empty
    (40) typepar -> . ID empty

    INT             shift and go to state 140
    FLOAT           shift and go to state 141
    CHAR            shift and go to state 142
    STRING          shift and go to state 143
    ID              shift and go to state 144

    typepar                        shift and go to state 139

state 103

    (41) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR . empty
    (117) empty -> .

    $end            reduce using rule 117 (empty -> .)

    empty                          shift and go to state 145

state 104

    (42) statement -> assigment statementF .

    R_CURPAR        reduce using rule 42 (statement -> assigment statementF .)
    SEMICOLON       reduce using rule 42 (statement -> assigment statementF .)


state 105

    (49) statementF -> statement .

    R_CURPAR        reduce using rule 49 (statementF -> statement .)
    SEMICOLON       reduce using rule 49 (statementF -> statement .)


state 106

    (50) statementF -> empty .

    R_CURPAR        reduce using rule 50 (statementF -> empty .)
    SEMICOLON       reduce using rule 50 (statementF -> empty .)


state 107

    (43) statement -> void statementF .

    R_CURPAR        reduce using rule 43 (statement -> void statementF .)
    SEMICOLON       reduce using rule 43 (statement -> void statementF .)


state 108

    (44) statement -> return statementF .

    R_CURPAR        reduce using rule 44 (statement -> return statementF .)
    SEMICOLON       reduce using rule 44 (statement -> return statementF .)


state 109

    (45) statement -> read statementF .

    R_CURPAR        reduce using rule 45 (statement -> read statementF .)
    SEMICOLON       reduce using rule 45 (statement -> read statementF .)


state 110

    (46) statement -> write statementF .

    R_CURPAR        reduce using rule 46 (statement -> write statementF .)
    SEMICOLON       reduce using rule 46 (statement -> write statementF .)


state 111

    (47) statement -> if statementF .

    R_CURPAR        reduce using rule 47 (statement -> if statementF .)
    SEMICOLON       reduce using rule 47 (statement -> if statementF .)


state 112

    (48) statement -> repeat statementF .

    R_CURPAR        reduce using rule 48 (statement -> repeat statementF .)
    SEMICOLON       reduce using rule 48 (statement -> repeat statementF .)


state 113

    (76) assigment -> var assigmentF .

    ID              reduce using rule 76 (assigment -> var assigmentF .)
    RETURN          reduce using rule 76 (assigment -> var assigmentF .)
    READ            reduce using rule 76 (assigment -> var assigmentF .)
    WRITE           reduce using rule 76 (assigment -> var assigmentF .)
    IF              reduce using rule 76 (assigment -> var assigmentF .)
    VAR             reduce using rule 76 (assigment -> var assigmentF .)
    WHILE           reduce using rule 76 (assigment -> var assigmentF .)
    FROM            reduce using rule 76 (assigment -> var assigmentF .)
    R_CURPAR        reduce using rule 76 (assigment -> var assigmentF .)
    SEMICOLON       reduce using rule 76 (assigment -> var assigmentF .)


state 114

    (77) assigmentF -> EQUAL . exp empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 146
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 115

    (78) assigmentF -> ope . exp empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 161
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 116

    (79) ope -> PLUS_EQ . empty
    (117) empty -> .

    L_PAR           reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    CTE_INT         reduce using rule 117 (empty -> .)
    CTE_FLOAT       reduce using rule 117 (empty -> .)
    CTE_STRING      reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 162

state 117

    (80) ope -> MIN_EQ . empty
    (117) empty -> .

    L_PAR           reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    CTE_INT         reduce using rule 117 (empty -> .)
    CTE_FLOAT       reduce using rule 117 (empty -> .)
    CTE_STRING      reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 163

state 118

    (81) ope -> MULT_EQ . empty
    (117) empty -> .

    L_PAR           reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    CTE_INT         reduce using rule 117 (empty -> .)
    CTE_FLOAT       reduce using rule 117 (empty -> .)
    CTE_STRING      reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 164

state 119

    (82) ope -> DIV_EQ . empty
    (117) empty -> .

    L_PAR           reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    CTE_INT         reduce using rule 117 (empty -> .)
    CTE_FLOAT       reduce using rule 117 (empty -> .)
    CTE_STRING      reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 165

state 120

    (51) void -> ID DOT . ID L_PAR param R_PAR SEMICOLON empty
    (60) var -> ID DOT . VAR varF

    ID              shift and go to state 166
    VAR             shift and go to state 167


state 121

    (52) void -> ID L_PAR . param R_PAR SEMICOLON empty
    (55) param -> . var paramF
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    VAR             shift and go to state 91
    ID              shift and go to state 160

    param                          shift and go to state 168
    var                            shift and go to state 169

state 122

    (58) return -> RETURN L_PAR . exp R_PAR SEMICOLON empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 170
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 123

    (63) read -> READ L_PAR . readF
    (64) readF -> . var COMMA readF
    (65) readF -> . var R_PAR SEMICOLON empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    VAR             shift and go to state 91
    ID              shift and go to state 160

    readF                          shift and go to state 171
    var                            shift and go to state 172

state 124

    (66) write -> WRITE L_PAR . writeT
    (67) writeT -> . CTE_STRING writeF
    (68) writeT -> . exp writeF
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 174
    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    VAR             shift and go to state 91
    ID              shift and go to state 160

    writeT                         shift and go to state 173
    exp                            shift and go to state 175
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 125

    (73) if -> IF L_PAR . exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 176
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 126

    (71) repeat -> conditional empty .

    ID              reduce using rule 71 (repeat -> conditional empty .)
    RETURN          reduce using rule 71 (repeat -> conditional empty .)
    READ            reduce using rule 71 (repeat -> conditional empty .)
    WRITE           reduce using rule 71 (repeat -> conditional empty .)
    IF              reduce using rule 71 (repeat -> conditional empty .)
    VAR             reduce using rule 71 (repeat -> conditional empty .)
    WHILE           reduce using rule 71 (repeat -> conditional empty .)
    FROM            reduce using rule 71 (repeat -> conditional empty .)
    R_CURPAR        reduce using rule 71 (repeat -> conditional empty .)
    SEMICOLON       reduce using rule 71 (repeat -> conditional empty .)


state 127

    (72) repeat -> nonconditional empty .

    ID              reduce using rule 72 (repeat -> nonconditional empty .)
    RETURN          reduce using rule 72 (repeat -> nonconditional empty .)
    READ            reduce using rule 72 (repeat -> nonconditional empty .)
    WRITE           reduce using rule 72 (repeat -> nonconditional empty .)
    IF              reduce using rule 72 (repeat -> nonconditional empty .)
    VAR             reduce using rule 72 (repeat -> nonconditional empty .)
    WHILE           reduce using rule 72 (repeat -> nonconditional empty .)
    FROM            reduce using rule 72 (repeat -> nonconditional empty .)
    R_CURPAR        reduce using rule 72 (repeat -> nonconditional empty .)
    SEMICOLON       reduce using rule 72 (repeat -> nonconditional empty .)


state 128

    (59) var -> VAR varF .

    EQUAL           reduce using rule 59 (var -> VAR varF .)
    PLUS_EQ         reduce using rule 59 (var -> VAR varF .)
    MIN_EQ          reduce using rule 59 (var -> VAR varF .)
    MULT_EQ         reduce using rule 59 (var -> VAR varF .)
    DIV_EQ          reduce using rule 59 (var -> VAR varF .)
    MULT            reduce using rule 59 (var -> VAR varF .)
    DIV             reduce using rule 59 (var -> VAR varF .)
    PLUS            reduce using rule 59 (var -> VAR varF .)
    MINUS           reduce using rule 59 (var -> VAR varF .)
    LESS            reduce using rule 59 (var -> VAR varF .)
    GREATER         reduce using rule 59 (var -> VAR varF .)
    LESS_TH         reduce using rule 59 (var -> VAR varF .)
    GREAT_TH        reduce using rule 59 (var -> VAR varF .)
    SAME            reduce using rule 59 (var -> VAR varF .)
    DIF             reduce using rule 59 (var -> VAR varF .)
    ID              reduce using rule 59 (var -> VAR varF .)
    RETURN          reduce using rule 59 (var -> VAR varF .)
    READ            reduce using rule 59 (var -> VAR varF .)
    WRITE           reduce using rule 59 (var -> VAR varF .)
    IF              reduce using rule 59 (var -> VAR varF .)
    VAR             reduce using rule 59 (var -> VAR varF .)
    WHILE           reduce using rule 59 (var -> VAR varF .)
    FROM            reduce using rule 59 (var -> VAR varF .)
    R_CURPAR        reduce using rule 59 (var -> VAR varF .)
    SEMICOLON       reduce using rule 59 (var -> VAR varF .)
    COMMA           reduce using rule 59 (var -> VAR varF .)
    R_PAR           reduce using rule 59 (var -> VAR varF .)
    R_BREAK         reduce using rule 59 (var -> VAR varF .)
    TO              reduce using rule 59 (var -> VAR varF .)
    OR              reduce using rule 59 (var -> VAR varF .)
    AND             reduce using rule 59 (var -> VAR varF .)
    DO              reduce using rule 59 (var -> VAR varF .)


state 129

    (61) varF -> arrfunc . empty
    (117) empty -> .

    EQUAL           reduce using rule 117 (empty -> .)
    PLUS_EQ         reduce using rule 117 (empty -> .)
    MIN_EQ          reduce using rule 117 (empty -> .)
    MULT_EQ         reduce using rule 117 (empty -> .)
    DIV_EQ          reduce using rule 117 (empty -> .)
    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 177

state 130

    (62) varF -> empty .

    EQUAL           reduce using rule 62 (varF -> empty .)
    PLUS_EQ         reduce using rule 62 (varF -> empty .)
    MIN_EQ          reduce using rule 62 (varF -> empty .)
    MULT_EQ         reduce using rule 62 (varF -> empty .)
    DIV_EQ          reduce using rule 62 (varF -> empty .)
    MULT            reduce using rule 62 (varF -> empty .)
    DIV             reduce using rule 62 (varF -> empty .)
    PLUS            reduce using rule 62 (varF -> empty .)
    MINUS           reduce using rule 62 (varF -> empty .)
    LESS            reduce using rule 62 (varF -> empty .)
    GREATER         reduce using rule 62 (varF -> empty .)
    LESS_TH         reduce using rule 62 (varF -> empty .)
    GREAT_TH        reduce using rule 62 (varF -> empty .)
    SAME            reduce using rule 62 (varF -> empty .)
    DIF             reduce using rule 62 (varF -> empty .)
    ID              reduce using rule 62 (varF -> empty .)
    RETURN          reduce using rule 62 (varF -> empty .)
    READ            reduce using rule 62 (varF -> empty .)
    WRITE           reduce using rule 62 (varF -> empty .)
    IF              reduce using rule 62 (varF -> empty .)
    VAR             reduce using rule 62 (varF -> empty .)
    WHILE           reduce using rule 62 (varF -> empty .)
    FROM            reduce using rule 62 (varF -> empty .)
    R_CURPAR        reduce using rule 62 (varF -> empty .)
    SEMICOLON       reduce using rule 62 (varF -> empty .)
    COMMA           reduce using rule 62 (varF -> empty .)
    R_PAR           reduce using rule 62 (varF -> empty .)
    R_BREAK         reduce using rule 62 (varF -> empty .)
    TO              reduce using rule 62 (varF -> empty .)
    OR              reduce using rule 62 (varF -> empty .)
    AND             reduce using rule 62 (varF -> empty .)
    DO              reduce using rule 62 (varF -> empty .)


state 131

    (53) arrfunc -> L_BREAK . exp COMMA exp R_BREAK empty
    (54) arrfunc -> L_BREAK . exp R_BREAK empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 178
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 132

    (83) conditional -> WHILE L_PAR . exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 179
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 133

    (84) nonconditional -> FROM VAR . arrfunc nonconditionalF
    (85) nonconditional -> FROM VAR . nonconditionalF
    (53) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (54) arrfunc -> . L_BREAK exp R_BREAK empty
    (86) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_BREAK         shift and go to state 131
    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    arrfunc                        shift and go to state 180
    nonconditionalF                shift and go to state 181
    exp                            shift and go to state 182
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 134

    (8) classT -> LESS INHERIT ID GREATER classF .

    CLASS           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VARS            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    MAIN            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    INT             reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    FLOAT           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    CHAR            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    STRING          reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    ID              reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VOID            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)


state 135

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS . func R_CURPAR SEMICOLON empty
    (24) func -> . typeFunc FUNCTION ID L_PAR funcF
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . STRING empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    STRING          shift and go to state 19
    ID              shift and go to state 5
    VOID            shift and go to state 20

    func                           shift and go to state 183
    typeFunc                       shift and go to state 14

state 136

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK . empty
    (117) empty -> .

    COMMA           reduce using rule 117 (empty -> .)
    COLON           reduce using rule 117 (empty -> .)

    empty                          shift and go to state 184

state 137

    (25) funcF -> parameter R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 26

    dec                            shift and go to state 185

state 138

    (26) funcF -> R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 186


state 139

    (33) parameter -> VAR COLON typepar . SEMICOLON parameterF

    SEMICOLON       shift and go to state 187


state 140

    (36) typepar -> INT . empty
    (117) empty -> .

    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 188

state 141

    (37) typepar -> FLOAT . empty
    (117) empty -> .

    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 189

state 142

    (38) typepar -> CHAR . empty
    (117) empty -> .

    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 190

state 143

    (39) typepar -> STRING . empty
    (117) empty -> .

    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 191

state 144

    (40) typepar -> ID . empty
    (117) empty -> .

    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 192

state 145

    (41) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .

    $end            reduce using rule 41 (main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .)


state 146

    (77) assigmentF -> EQUAL exp . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 193

state 147

    (89) exp -> ex . expT
    (90) expT -> . LESS expf
    (91) expT -> . GREATER expf
    (92) expT -> . LESS_TH expf
    (93) expT -> . GREAT_TH expf
    (94) expT -> . SAME expf
    (95) expT -> . DIF expf
    (96) expT -> . empty
    (117) empty -> .

    LESS            shift and go to state 195
    GREATER         shift and go to state 196
    LESS_TH         shift and go to state 197
    GREAT_TH        shift and go to state 198
    SAME            shift and go to state 199
    DIF             shift and go to state 200
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    expT                           shift and go to state 194
    empty                          shift and go to state 201

state 148

    (99) ex -> term . exF
    (100) exF -> . PLUS ex
    (101) exF -> . MINUS ex
    (102) exF -> . empty
    (117) empty -> .

    PLUS            shift and go to state 203
    MINUS           shift and go to state 204
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    exF                            shift and go to state 202
    empty                          shift and go to state 205

state 149

    (103) term -> factor . termF
    (104) termF -> . MULT term
    (105) termF -> . DIV term
    (106) termF -> . empty
    (117) empty -> .

    MULT            shift and go to state 207
    DIV             shift and go to state 208
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    termF                          shift and go to state 206
    empty                          shift and go to state 209

state 150

    (107) factor -> L_PAR . exp R_PAR empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 210
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 151

    (108) factor -> factorT .

    MULT            reduce using rule 108 (factor -> factorT .)
    DIV             reduce using rule 108 (factor -> factorT .)
    PLUS            reduce using rule 108 (factor -> factorT .)
    MINUS           reduce using rule 108 (factor -> factorT .)
    LESS            reduce using rule 108 (factor -> factorT .)
    GREATER         reduce using rule 108 (factor -> factorT .)
    LESS_TH         reduce using rule 108 (factor -> factorT .)
    GREAT_TH        reduce using rule 108 (factor -> factorT .)
    SAME            reduce using rule 108 (factor -> factorT .)
    DIF             reduce using rule 108 (factor -> factorT .)
    ID              reduce using rule 108 (factor -> factorT .)
    RETURN          reduce using rule 108 (factor -> factorT .)
    READ            reduce using rule 108 (factor -> factorT .)
    WRITE           reduce using rule 108 (factor -> factorT .)
    IF              reduce using rule 108 (factor -> factorT .)
    VAR             reduce using rule 108 (factor -> factorT .)
    WHILE           reduce using rule 108 (factor -> factorT .)
    FROM            reduce using rule 108 (factor -> factorT .)
    R_CURPAR        reduce using rule 108 (factor -> factorT .)
    SEMICOLON       reduce using rule 108 (factor -> factorT .)
    R_PAR           reduce using rule 108 (factor -> factorT .)
    COMMA           reduce using rule 108 (factor -> factorT .)
    R_BREAK         reduce using rule 108 (factor -> factorT .)
    TO              reduce using rule 108 (factor -> factorT .)
    OR              reduce using rule 108 (factor -> factorT .)
    AND             reduce using rule 108 (factor -> factorT .)
    DO              reduce using rule 108 (factor -> factorT .)


state 152

    (109) factorT -> PLUS . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    factorF                        shift and go to state 211
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 153

    (111) factorT -> factorF .

    MULT            reduce using rule 111 (factorT -> factorF .)
    DIV             reduce using rule 111 (factorT -> factorF .)
    PLUS            reduce using rule 111 (factorT -> factorF .)
    MINUS           reduce using rule 111 (factorT -> factorF .)
    LESS            reduce using rule 111 (factorT -> factorF .)
    GREATER         reduce using rule 111 (factorT -> factorF .)
    LESS_TH         reduce using rule 111 (factorT -> factorF .)
    GREAT_TH        reduce using rule 111 (factorT -> factorF .)
    SAME            reduce using rule 111 (factorT -> factorF .)
    DIF             reduce using rule 111 (factorT -> factorF .)
    ID              reduce using rule 111 (factorT -> factorF .)
    RETURN          reduce using rule 111 (factorT -> factorF .)
    READ            reduce using rule 111 (factorT -> factorF .)
    WRITE           reduce using rule 111 (factorT -> factorF .)
    IF              reduce using rule 111 (factorT -> factorF .)
    VAR             reduce using rule 111 (factorT -> factorF .)
    WHILE           reduce using rule 111 (factorT -> factorF .)
    FROM            reduce using rule 111 (factorT -> factorF .)
    R_CURPAR        reduce using rule 111 (factorT -> factorF .)
    SEMICOLON       reduce using rule 111 (factorT -> factorF .)
    R_PAR           reduce using rule 111 (factorT -> factorF .)
    COMMA           reduce using rule 111 (factorT -> factorF .)
    R_BREAK         reduce using rule 111 (factorT -> factorF .)
    TO              reduce using rule 111 (factorT -> factorF .)
    OR              reduce using rule 111 (factorT -> factorF .)
    AND             reduce using rule 111 (factorT -> factorF .)
    DO              reduce using rule 111 (factorT -> factorF .)


state 154

    (110) factorT -> MINUS . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    factorF                        shift and go to state 212
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 155

    (112) factorF -> varcte . empty
    (117) empty -> .

    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 213

state 156

    (113) varcte -> var . empty
    (117) empty -> .

    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 214

state 157

    (114) varcte -> CTE_INT . empty
    (117) empty -> .

    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 215

state 158

    (115) varcte -> CTE_FLOAT . empty
    (117) empty -> .

    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 216

state 159

    (116) varcte -> CTE_STRING . empty
    (117) empty -> .

    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 217

state 160

    (60) var -> ID . DOT VAR varF

    DOT             shift and go to state 218


state 161

    (78) assigmentF -> ope exp . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 219

state 162

    (79) ope -> PLUS_EQ empty .

    L_PAR           reduce using rule 79 (ope -> PLUS_EQ empty .)
    PLUS            reduce using rule 79 (ope -> PLUS_EQ empty .)
    MINUS           reduce using rule 79 (ope -> PLUS_EQ empty .)
    CTE_INT         reduce using rule 79 (ope -> PLUS_EQ empty .)
    CTE_FLOAT       reduce using rule 79 (ope -> PLUS_EQ empty .)
    CTE_STRING      reduce using rule 79 (ope -> PLUS_EQ empty .)
    VAR             reduce using rule 79 (ope -> PLUS_EQ empty .)
    ID              reduce using rule 79 (ope -> PLUS_EQ empty .)


state 163

    (80) ope -> MIN_EQ empty .

    L_PAR           reduce using rule 80 (ope -> MIN_EQ empty .)
    PLUS            reduce using rule 80 (ope -> MIN_EQ empty .)
    MINUS           reduce using rule 80 (ope -> MIN_EQ empty .)
    CTE_INT         reduce using rule 80 (ope -> MIN_EQ empty .)
    CTE_FLOAT       reduce using rule 80 (ope -> MIN_EQ empty .)
    CTE_STRING      reduce using rule 80 (ope -> MIN_EQ empty .)
    VAR             reduce using rule 80 (ope -> MIN_EQ empty .)
    ID              reduce using rule 80 (ope -> MIN_EQ empty .)


state 164

    (81) ope -> MULT_EQ empty .

    L_PAR           reduce using rule 81 (ope -> MULT_EQ empty .)
    PLUS            reduce using rule 81 (ope -> MULT_EQ empty .)
    MINUS           reduce using rule 81 (ope -> MULT_EQ empty .)
    CTE_INT         reduce using rule 81 (ope -> MULT_EQ empty .)
    CTE_FLOAT       reduce using rule 81 (ope -> MULT_EQ empty .)
    CTE_STRING      reduce using rule 81 (ope -> MULT_EQ empty .)
    VAR             reduce using rule 81 (ope -> MULT_EQ empty .)
    ID              reduce using rule 81 (ope -> MULT_EQ empty .)


state 165

    (82) ope -> DIV_EQ empty .

    L_PAR           reduce using rule 82 (ope -> DIV_EQ empty .)
    PLUS            reduce using rule 82 (ope -> DIV_EQ empty .)
    MINUS           reduce using rule 82 (ope -> DIV_EQ empty .)
    CTE_INT         reduce using rule 82 (ope -> DIV_EQ empty .)
    CTE_FLOAT       reduce using rule 82 (ope -> DIV_EQ empty .)
    CTE_STRING      reduce using rule 82 (ope -> DIV_EQ empty .)
    VAR             reduce using rule 82 (ope -> DIV_EQ empty .)
    ID              reduce using rule 82 (ope -> DIV_EQ empty .)


state 166

    (51) void -> ID DOT ID . L_PAR param R_PAR SEMICOLON empty

    L_PAR           shift and go to state 220


state 167

    (60) var -> ID DOT VAR . varF
    (61) varF -> . arrfunc empty
    (62) varF -> . empty
    (53) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (54) arrfunc -> . L_BREAK exp R_BREAK empty
    (117) empty -> .

    L_BREAK         shift and go to state 131
    EQUAL           reduce using rule 117 (empty -> .)
    PLUS_EQ         reduce using rule 117 (empty -> .)
    MIN_EQ          reduce using rule 117 (empty -> .)
    MULT_EQ         reduce using rule 117 (empty -> .)
    DIV_EQ          reduce using rule 117 (empty -> .)
    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    varF                           shift and go to state 221
    arrfunc                        shift and go to state 129
    empty                          shift and go to state 130

state 168

    (52) void -> ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 222


state 169

    (55) param -> var . paramF
    (56) paramF -> . COMMA param
    (57) paramF -> . empty
    (117) empty -> .

    COMMA           shift and go to state 224
    R_PAR           reduce using rule 117 (empty -> .)

    paramF                         shift and go to state 223
    empty                          shift and go to state 225

state 170

    (58) return -> RETURN L_PAR exp . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 226


state 171

    (63) read -> READ L_PAR readF .

    ID              reduce using rule 63 (read -> READ L_PAR readF .)
    RETURN          reduce using rule 63 (read -> READ L_PAR readF .)
    READ            reduce using rule 63 (read -> READ L_PAR readF .)
    WRITE           reduce using rule 63 (read -> READ L_PAR readF .)
    IF              reduce using rule 63 (read -> READ L_PAR readF .)
    VAR             reduce using rule 63 (read -> READ L_PAR readF .)
    WHILE           reduce using rule 63 (read -> READ L_PAR readF .)
    FROM            reduce using rule 63 (read -> READ L_PAR readF .)
    R_CURPAR        reduce using rule 63 (read -> READ L_PAR readF .)
    SEMICOLON       reduce using rule 63 (read -> READ L_PAR readF .)


state 172

    (64) readF -> var . COMMA readF
    (65) readF -> var . R_PAR SEMICOLON empty

    COMMA           shift and go to state 227
    R_PAR           shift and go to state 228


state 173

    (66) write -> WRITE L_PAR writeT .

    ID              reduce using rule 66 (write -> WRITE L_PAR writeT .)
    RETURN          reduce using rule 66 (write -> WRITE L_PAR writeT .)
    READ            reduce using rule 66 (write -> WRITE L_PAR writeT .)
    WRITE           reduce using rule 66 (write -> WRITE L_PAR writeT .)
    IF              reduce using rule 66 (write -> WRITE L_PAR writeT .)
    VAR             reduce using rule 66 (write -> WRITE L_PAR writeT .)
    WHILE           reduce using rule 66 (write -> WRITE L_PAR writeT .)
    FROM            reduce using rule 66 (write -> WRITE L_PAR writeT .)
    R_CURPAR        reduce using rule 66 (write -> WRITE L_PAR writeT .)
    SEMICOLON       reduce using rule 66 (write -> WRITE L_PAR writeT .)


state 174

    (67) writeT -> CTE_STRING . writeF
    (116) varcte -> CTE_STRING . empty
    (69) writeF -> . COMMA writeT
    (70) writeF -> . R_PAR SEMICOLON empty
    (117) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for R_PAR resolved as shift
    COMMA           shift and go to state 230
    R_PAR           shift and go to state 231
    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)

  ! COMMA           [ reduce using rule 117 (empty -> .) ]
  ! R_PAR           [ reduce using rule 117 (empty -> .) ]

    writeF                         shift and go to state 229
    empty                          shift and go to state 217

state 175

    (68) writeT -> exp . writeF
    (69) writeF -> . COMMA writeT
    (70) writeF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 230
    R_PAR           shift and go to state 231

    writeF                         shift and go to state 232

state 176

    (73) if -> IF L_PAR exp . R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    R_PAR           shift and go to state 233


state 177

    (61) varF -> arrfunc empty .

    EQUAL           reduce using rule 61 (varF -> arrfunc empty .)
    PLUS_EQ         reduce using rule 61 (varF -> arrfunc empty .)
    MIN_EQ          reduce using rule 61 (varF -> arrfunc empty .)
    MULT_EQ         reduce using rule 61 (varF -> arrfunc empty .)
    DIV_EQ          reduce using rule 61 (varF -> arrfunc empty .)
    MULT            reduce using rule 61 (varF -> arrfunc empty .)
    DIV             reduce using rule 61 (varF -> arrfunc empty .)
    PLUS            reduce using rule 61 (varF -> arrfunc empty .)
    MINUS           reduce using rule 61 (varF -> arrfunc empty .)
    LESS            reduce using rule 61 (varF -> arrfunc empty .)
    GREATER         reduce using rule 61 (varF -> arrfunc empty .)
    LESS_TH         reduce using rule 61 (varF -> arrfunc empty .)
    GREAT_TH        reduce using rule 61 (varF -> arrfunc empty .)
    SAME            reduce using rule 61 (varF -> arrfunc empty .)
    DIF             reduce using rule 61 (varF -> arrfunc empty .)
    ID              reduce using rule 61 (varF -> arrfunc empty .)
    RETURN          reduce using rule 61 (varF -> arrfunc empty .)
    READ            reduce using rule 61 (varF -> arrfunc empty .)
    WRITE           reduce using rule 61 (varF -> arrfunc empty .)
    IF              reduce using rule 61 (varF -> arrfunc empty .)
    VAR             reduce using rule 61 (varF -> arrfunc empty .)
    WHILE           reduce using rule 61 (varF -> arrfunc empty .)
    FROM            reduce using rule 61 (varF -> arrfunc empty .)
    R_CURPAR        reduce using rule 61 (varF -> arrfunc empty .)
    SEMICOLON       reduce using rule 61 (varF -> arrfunc empty .)
    COMMA           reduce using rule 61 (varF -> arrfunc empty .)
    R_PAR           reduce using rule 61 (varF -> arrfunc empty .)
    R_BREAK         reduce using rule 61 (varF -> arrfunc empty .)
    TO              reduce using rule 61 (varF -> arrfunc empty .)
    OR              reduce using rule 61 (varF -> arrfunc empty .)
    AND             reduce using rule 61 (varF -> arrfunc empty .)
    DO              reduce using rule 61 (varF -> arrfunc empty .)


state 178

    (53) arrfunc -> L_BREAK exp . COMMA exp R_BREAK empty
    (54) arrfunc -> L_BREAK exp . R_BREAK empty

    COMMA           shift and go to state 234
    R_BREAK         shift and go to state 235


state 179

    (83) conditional -> WHILE L_PAR exp . R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    R_PAR           shift and go to state 236


state 180

    (84) nonconditional -> FROM VAR arrfunc . nonconditionalF
    (86) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    nonconditionalF                shift and go to state 237
    exp                            shift and go to state 182
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 181

    (85) nonconditional -> FROM VAR nonconditionalF .

    ID              reduce using rule 85 (nonconditional -> FROM VAR nonconditionalF .)
    RETURN          reduce using rule 85 (nonconditional -> FROM VAR nonconditionalF .)
    READ            reduce using rule 85 (nonconditional -> FROM VAR nonconditionalF .)
    WRITE           reduce using rule 85 (nonconditional -> FROM VAR nonconditionalF .)
    IF              reduce using rule 85 (nonconditional -> FROM VAR nonconditionalF .)
    VAR             reduce using rule 85 (nonconditional -> FROM VAR nonconditionalF .)
    WHILE           reduce using rule 85 (nonconditional -> FROM VAR nonconditionalF .)
    FROM            reduce using rule 85 (nonconditional -> FROM VAR nonconditionalF .)
    R_CURPAR        reduce using rule 85 (nonconditional -> FROM VAR nonconditionalF .)
    SEMICOLON       reduce using rule 85 (nonconditional -> FROM VAR nonconditionalF .)


state 182

    (86) nonconditionalF -> exp . TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty

    TO              shift and go to state 238


state 183

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func . R_CURPAR SEMICOLON empty

    R_CURPAR        shift and go to state 239


state 184

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .

    COMMA           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    COLON           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)


state 185

    (25) funcF -> parameter R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 240


state 186

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    statement                      shift and go to state 241
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 187

    (33) parameter -> VAR COLON typepar SEMICOLON . parameterF
    (34) parameterF -> . parameter
    (35) parameterF -> . empty
    (33) parameter -> . VAR COLON typepar SEMICOLON parameterF
    (117) empty -> .

    VAR             shift and go to state 74
    R_PAR           reduce using rule 117 (empty -> .)

    parameterF                     shift and go to state 242
    parameter                      shift and go to state 243
    empty                          shift and go to state 244

state 188

    (36) typepar -> INT empty .

    SEMICOLON       reduce using rule 36 (typepar -> INT empty .)


state 189

    (37) typepar -> FLOAT empty .

    SEMICOLON       reduce using rule 37 (typepar -> FLOAT empty .)


state 190

    (38) typepar -> CHAR empty .

    SEMICOLON       reduce using rule 38 (typepar -> CHAR empty .)


state 191

    (39) typepar -> STRING empty .

    SEMICOLON       reduce using rule 39 (typepar -> STRING empty .)


state 192

    (40) typepar -> ID empty .

    SEMICOLON       reduce using rule 40 (typepar -> ID empty .)


state 193

    (77) assigmentF -> EQUAL exp empty .

    ID              reduce using rule 77 (assigmentF -> EQUAL exp empty .)
    RETURN          reduce using rule 77 (assigmentF -> EQUAL exp empty .)
    READ            reduce using rule 77 (assigmentF -> EQUAL exp empty .)
    WRITE           reduce using rule 77 (assigmentF -> EQUAL exp empty .)
    IF              reduce using rule 77 (assigmentF -> EQUAL exp empty .)
    VAR             reduce using rule 77 (assigmentF -> EQUAL exp empty .)
    WHILE           reduce using rule 77 (assigmentF -> EQUAL exp empty .)
    FROM            reduce using rule 77 (assigmentF -> EQUAL exp empty .)
    R_CURPAR        reduce using rule 77 (assigmentF -> EQUAL exp empty .)
    SEMICOLON       reduce using rule 77 (assigmentF -> EQUAL exp empty .)


state 194

    (89) exp -> ex expT .

    ID              reduce using rule 89 (exp -> ex expT .)
    RETURN          reduce using rule 89 (exp -> ex expT .)
    READ            reduce using rule 89 (exp -> ex expT .)
    WRITE           reduce using rule 89 (exp -> ex expT .)
    IF              reduce using rule 89 (exp -> ex expT .)
    VAR             reduce using rule 89 (exp -> ex expT .)
    WHILE           reduce using rule 89 (exp -> ex expT .)
    FROM            reduce using rule 89 (exp -> ex expT .)
    R_CURPAR        reduce using rule 89 (exp -> ex expT .)
    SEMICOLON       reduce using rule 89 (exp -> ex expT .)
    R_PAR           reduce using rule 89 (exp -> ex expT .)
    COMMA           reduce using rule 89 (exp -> ex expT .)
    R_BREAK         reduce using rule 89 (exp -> ex expT .)
    TO              reduce using rule 89 (exp -> ex expT .)
    DO              reduce using rule 89 (exp -> ex expT .)


state 195

    (90) expT -> LESS . expf
    (97) expf -> . ex empty
    (98) expf -> . ex bool empty
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    expf                           shift and go to state 245
    ex                             shift and go to state 246
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 196

    (91) expT -> GREATER . expf
    (97) expf -> . ex empty
    (98) expf -> . ex bool empty
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    expf                           shift and go to state 247
    ex                             shift and go to state 246
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 197

    (92) expT -> LESS_TH . expf
    (97) expf -> . ex empty
    (98) expf -> . ex bool empty
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    expf                           shift and go to state 248
    ex                             shift and go to state 246
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 198

    (93) expT -> GREAT_TH . expf
    (97) expf -> . ex empty
    (98) expf -> . ex bool empty
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    expf                           shift and go to state 249
    ex                             shift and go to state 246
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 199

    (94) expT -> SAME . expf
    (97) expf -> . ex empty
    (98) expf -> . ex bool empty
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    expf                           shift and go to state 250
    ex                             shift and go to state 246
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 200

    (95) expT -> DIF . expf
    (97) expf -> . ex empty
    (98) expf -> . ex bool empty
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    expf                           shift and go to state 251
    ex                             shift and go to state 246
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 201

    (96) expT -> empty .

    ID              reduce using rule 96 (expT -> empty .)
    RETURN          reduce using rule 96 (expT -> empty .)
    READ            reduce using rule 96 (expT -> empty .)
    WRITE           reduce using rule 96 (expT -> empty .)
    IF              reduce using rule 96 (expT -> empty .)
    VAR             reduce using rule 96 (expT -> empty .)
    WHILE           reduce using rule 96 (expT -> empty .)
    FROM            reduce using rule 96 (expT -> empty .)
    R_CURPAR        reduce using rule 96 (expT -> empty .)
    SEMICOLON       reduce using rule 96 (expT -> empty .)
    R_PAR           reduce using rule 96 (expT -> empty .)
    COMMA           reduce using rule 96 (expT -> empty .)
    R_BREAK         reduce using rule 96 (expT -> empty .)
    TO              reduce using rule 96 (expT -> empty .)
    DO              reduce using rule 96 (expT -> empty .)


state 202

    (99) ex -> term exF .

    LESS            reduce using rule 99 (ex -> term exF .)
    GREATER         reduce using rule 99 (ex -> term exF .)
    LESS_TH         reduce using rule 99 (ex -> term exF .)
    GREAT_TH        reduce using rule 99 (ex -> term exF .)
    SAME            reduce using rule 99 (ex -> term exF .)
    DIF             reduce using rule 99 (ex -> term exF .)
    ID              reduce using rule 99 (ex -> term exF .)
    RETURN          reduce using rule 99 (ex -> term exF .)
    READ            reduce using rule 99 (ex -> term exF .)
    WRITE           reduce using rule 99 (ex -> term exF .)
    IF              reduce using rule 99 (ex -> term exF .)
    VAR             reduce using rule 99 (ex -> term exF .)
    WHILE           reduce using rule 99 (ex -> term exF .)
    FROM            reduce using rule 99 (ex -> term exF .)
    R_CURPAR        reduce using rule 99 (ex -> term exF .)
    SEMICOLON       reduce using rule 99 (ex -> term exF .)
    R_PAR           reduce using rule 99 (ex -> term exF .)
    COMMA           reduce using rule 99 (ex -> term exF .)
    R_BREAK         reduce using rule 99 (ex -> term exF .)
    TO              reduce using rule 99 (ex -> term exF .)
    OR              reduce using rule 99 (ex -> term exF .)
    AND             reduce using rule 99 (ex -> term exF .)
    DO              reduce using rule 99 (ex -> term exF .)


state 203

    (100) exF -> PLUS . ex
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    ex                             shift and go to state 252
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 204

    (101) exF -> MINUS . ex
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    ex                             shift and go to state 253
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 205

    (102) exF -> empty .

    LESS            reduce using rule 102 (exF -> empty .)
    GREATER         reduce using rule 102 (exF -> empty .)
    LESS_TH         reduce using rule 102 (exF -> empty .)
    GREAT_TH        reduce using rule 102 (exF -> empty .)
    SAME            reduce using rule 102 (exF -> empty .)
    DIF             reduce using rule 102 (exF -> empty .)
    ID              reduce using rule 102 (exF -> empty .)
    RETURN          reduce using rule 102 (exF -> empty .)
    READ            reduce using rule 102 (exF -> empty .)
    WRITE           reduce using rule 102 (exF -> empty .)
    IF              reduce using rule 102 (exF -> empty .)
    VAR             reduce using rule 102 (exF -> empty .)
    WHILE           reduce using rule 102 (exF -> empty .)
    FROM            reduce using rule 102 (exF -> empty .)
    R_CURPAR        reduce using rule 102 (exF -> empty .)
    SEMICOLON       reduce using rule 102 (exF -> empty .)
    R_PAR           reduce using rule 102 (exF -> empty .)
    COMMA           reduce using rule 102 (exF -> empty .)
    R_BREAK         reduce using rule 102 (exF -> empty .)
    TO              reduce using rule 102 (exF -> empty .)
    OR              reduce using rule 102 (exF -> empty .)
    AND             reduce using rule 102 (exF -> empty .)
    DO              reduce using rule 102 (exF -> empty .)


state 206

    (103) term -> factor termF .

    PLUS            reduce using rule 103 (term -> factor termF .)
    MINUS           reduce using rule 103 (term -> factor termF .)
    LESS            reduce using rule 103 (term -> factor termF .)
    GREATER         reduce using rule 103 (term -> factor termF .)
    LESS_TH         reduce using rule 103 (term -> factor termF .)
    GREAT_TH        reduce using rule 103 (term -> factor termF .)
    SAME            reduce using rule 103 (term -> factor termF .)
    DIF             reduce using rule 103 (term -> factor termF .)
    ID              reduce using rule 103 (term -> factor termF .)
    RETURN          reduce using rule 103 (term -> factor termF .)
    READ            reduce using rule 103 (term -> factor termF .)
    WRITE           reduce using rule 103 (term -> factor termF .)
    IF              reduce using rule 103 (term -> factor termF .)
    VAR             reduce using rule 103 (term -> factor termF .)
    WHILE           reduce using rule 103 (term -> factor termF .)
    FROM            reduce using rule 103 (term -> factor termF .)
    R_CURPAR        reduce using rule 103 (term -> factor termF .)
    SEMICOLON       reduce using rule 103 (term -> factor termF .)
    R_PAR           reduce using rule 103 (term -> factor termF .)
    COMMA           reduce using rule 103 (term -> factor termF .)
    R_BREAK         reduce using rule 103 (term -> factor termF .)
    TO              reduce using rule 103 (term -> factor termF .)
    OR              reduce using rule 103 (term -> factor termF .)
    AND             reduce using rule 103 (term -> factor termF .)
    DO              reduce using rule 103 (term -> factor termF .)


state 207

    (104) termF -> MULT . term
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    term                           shift and go to state 254
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 208

    (105) termF -> DIV . term
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    term                           shift and go to state 255
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 209

    (106) termF -> empty .

    PLUS            reduce using rule 106 (termF -> empty .)
    MINUS           reduce using rule 106 (termF -> empty .)
    LESS            reduce using rule 106 (termF -> empty .)
    GREATER         reduce using rule 106 (termF -> empty .)
    LESS_TH         reduce using rule 106 (termF -> empty .)
    GREAT_TH        reduce using rule 106 (termF -> empty .)
    SAME            reduce using rule 106 (termF -> empty .)
    DIF             reduce using rule 106 (termF -> empty .)
    ID              reduce using rule 106 (termF -> empty .)
    RETURN          reduce using rule 106 (termF -> empty .)
    READ            reduce using rule 106 (termF -> empty .)
    WRITE           reduce using rule 106 (termF -> empty .)
    IF              reduce using rule 106 (termF -> empty .)
    VAR             reduce using rule 106 (termF -> empty .)
    WHILE           reduce using rule 106 (termF -> empty .)
    FROM            reduce using rule 106 (termF -> empty .)
    R_CURPAR        reduce using rule 106 (termF -> empty .)
    SEMICOLON       reduce using rule 106 (termF -> empty .)
    R_PAR           reduce using rule 106 (termF -> empty .)
    COMMA           reduce using rule 106 (termF -> empty .)
    R_BREAK         reduce using rule 106 (termF -> empty .)
    TO              reduce using rule 106 (termF -> empty .)
    OR              reduce using rule 106 (termF -> empty .)
    AND             reduce using rule 106 (termF -> empty .)
    DO              reduce using rule 106 (termF -> empty .)


state 210

    (107) factor -> L_PAR exp . R_PAR empty

    R_PAR           shift and go to state 256


state 211

    (109) factorT -> PLUS factorF .

    MULT            reduce using rule 109 (factorT -> PLUS factorF .)
    DIV             reduce using rule 109 (factorT -> PLUS factorF .)
    PLUS            reduce using rule 109 (factorT -> PLUS factorF .)
    MINUS           reduce using rule 109 (factorT -> PLUS factorF .)
    LESS            reduce using rule 109 (factorT -> PLUS factorF .)
    GREATER         reduce using rule 109 (factorT -> PLUS factorF .)
    LESS_TH         reduce using rule 109 (factorT -> PLUS factorF .)
    GREAT_TH        reduce using rule 109 (factorT -> PLUS factorF .)
    SAME            reduce using rule 109 (factorT -> PLUS factorF .)
    DIF             reduce using rule 109 (factorT -> PLUS factorF .)
    ID              reduce using rule 109 (factorT -> PLUS factorF .)
    RETURN          reduce using rule 109 (factorT -> PLUS factorF .)
    READ            reduce using rule 109 (factorT -> PLUS factorF .)
    WRITE           reduce using rule 109 (factorT -> PLUS factorF .)
    IF              reduce using rule 109 (factorT -> PLUS factorF .)
    VAR             reduce using rule 109 (factorT -> PLUS factorF .)
    WHILE           reduce using rule 109 (factorT -> PLUS factorF .)
    FROM            reduce using rule 109 (factorT -> PLUS factorF .)
    R_CURPAR        reduce using rule 109 (factorT -> PLUS factorF .)
    SEMICOLON       reduce using rule 109 (factorT -> PLUS factorF .)
    R_PAR           reduce using rule 109 (factorT -> PLUS factorF .)
    COMMA           reduce using rule 109 (factorT -> PLUS factorF .)
    R_BREAK         reduce using rule 109 (factorT -> PLUS factorF .)
    TO              reduce using rule 109 (factorT -> PLUS factorF .)
    OR              reduce using rule 109 (factorT -> PLUS factorF .)
    AND             reduce using rule 109 (factorT -> PLUS factorF .)
    DO              reduce using rule 109 (factorT -> PLUS factorF .)


state 212

    (110) factorT -> MINUS factorF .

    MULT            reduce using rule 110 (factorT -> MINUS factorF .)
    DIV             reduce using rule 110 (factorT -> MINUS factorF .)
    PLUS            reduce using rule 110 (factorT -> MINUS factorF .)
    MINUS           reduce using rule 110 (factorT -> MINUS factorF .)
    LESS            reduce using rule 110 (factorT -> MINUS factorF .)
    GREATER         reduce using rule 110 (factorT -> MINUS factorF .)
    LESS_TH         reduce using rule 110 (factorT -> MINUS factorF .)
    GREAT_TH        reduce using rule 110 (factorT -> MINUS factorF .)
    SAME            reduce using rule 110 (factorT -> MINUS factorF .)
    DIF             reduce using rule 110 (factorT -> MINUS factorF .)
    ID              reduce using rule 110 (factorT -> MINUS factorF .)
    RETURN          reduce using rule 110 (factorT -> MINUS factorF .)
    READ            reduce using rule 110 (factorT -> MINUS factorF .)
    WRITE           reduce using rule 110 (factorT -> MINUS factorF .)
    IF              reduce using rule 110 (factorT -> MINUS factorF .)
    VAR             reduce using rule 110 (factorT -> MINUS factorF .)
    WHILE           reduce using rule 110 (factorT -> MINUS factorF .)
    FROM            reduce using rule 110 (factorT -> MINUS factorF .)
    R_CURPAR        reduce using rule 110 (factorT -> MINUS factorF .)
    SEMICOLON       reduce using rule 110 (factorT -> MINUS factorF .)
    R_PAR           reduce using rule 110 (factorT -> MINUS factorF .)
    COMMA           reduce using rule 110 (factorT -> MINUS factorF .)
    R_BREAK         reduce using rule 110 (factorT -> MINUS factorF .)
    TO              reduce using rule 110 (factorT -> MINUS factorF .)
    OR              reduce using rule 110 (factorT -> MINUS factorF .)
    AND             reduce using rule 110 (factorT -> MINUS factorF .)
    DO              reduce using rule 110 (factorT -> MINUS factorF .)


state 213

    (112) factorF -> varcte empty .

    MULT            reduce using rule 112 (factorF -> varcte empty .)
    DIV             reduce using rule 112 (factorF -> varcte empty .)
    PLUS            reduce using rule 112 (factorF -> varcte empty .)
    MINUS           reduce using rule 112 (factorF -> varcte empty .)
    LESS            reduce using rule 112 (factorF -> varcte empty .)
    GREATER         reduce using rule 112 (factorF -> varcte empty .)
    LESS_TH         reduce using rule 112 (factorF -> varcte empty .)
    GREAT_TH        reduce using rule 112 (factorF -> varcte empty .)
    SAME            reduce using rule 112 (factorF -> varcte empty .)
    DIF             reduce using rule 112 (factorF -> varcte empty .)
    ID              reduce using rule 112 (factorF -> varcte empty .)
    RETURN          reduce using rule 112 (factorF -> varcte empty .)
    READ            reduce using rule 112 (factorF -> varcte empty .)
    WRITE           reduce using rule 112 (factorF -> varcte empty .)
    IF              reduce using rule 112 (factorF -> varcte empty .)
    VAR             reduce using rule 112 (factorF -> varcte empty .)
    WHILE           reduce using rule 112 (factorF -> varcte empty .)
    FROM            reduce using rule 112 (factorF -> varcte empty .)
    R_CURPAR        reduce using rule 112 (factorF -> varcte empty .)
    SEMICOLON       reduce using rule 112 (factorF -> varcte empty .)
    R_PAR           reduce using rule 112 (factorF -> varcte empty .)
    COMMA           reduce using rule 112 (factorF -> varcte empty .)
    R_BREAK         reduce using rule 112 (factorF -> varcte empty .)
    TO              reduce using rule 112 (factorF -> varcte empty .)
    OR              reduce using rule 112 (factorF -> varcte empty .)
    AND             reduce using rule 112 (factorF -> varcte empty .)
    DO              reduce using rule 112 (factorF -> varcte empty .)


state 214

    (113) varcte -> var empty .

    MULT            reduce using rule 113 (varcte -> var empty .)
    DIV             reduce using rule 113 (varcte -> var empty .)
    PLUS            reduce using rule 113 (varcte -> var empty .)
    MINUS           reduce using rule 113 (varcte -> var empty .)
    LESS            reduce using rule 113 (varcte -> var empty .)
    GREATER         reduce using rule 113 (varcte -> var empty .)
    LESS_TH         reduce using rule 113 (varcte -> var empty .)
    GREAT_TH        reduce using rule 113 (varcte -> var empty .)
    SAME            reduce using rule 113 (varcte -> var empty .)
    DIF             reduce using rule 113 (varcte -> var empty .)
    ID              reduce using rule 113 (varcte -> var empty .)
    RETURN          reduce using rule 113 (varcte -> var empty .)
    READ            reduce using rule 113 (varcte -> var empty .)
    WRITE           reduce using rule 113 (varcte -> var empty .)
    IF              reduce using rule 113 (varcte -> var empty .)
    VAR             reduce using rule 113 (varcte -> var empty .)
    WHILE           reduce using rule 113 (varcte -> var empty .)
    FROM            reduce using rule 113 (varcte -> var empty .)
    R_CURPAR        reduce using rule 113 (varcte -> var empty .)
    SEMICOLON       reduce using rule 113 (varcte -> var empty .)
    R_PAR           reduce using rule 113 (varcte -> var empty .)
    COMMA           reduce using rule 113 (varcte -> var empty .)
    R_BREAK         reduce using rule 113 (varcte -> var empty .)
    TO              reduce using rule 113 (varcte -> var empty .)
    OR              reduce using rule 113 (varcte -> var empty .)
    AND             reduce using rule 113 (varcte -> var empty .)
    DO              reduce using rule 113 (varcte -> var empty .)


state 215

    (114) varcte -> CTE_INT empty .

    MULT            reduce using rule 114 (varcte -> CTE_INT empty .)
    DIV             reduce using rule 114 (varcte -> CTE_INT empty .)
    PLUS            reduce using rule 114 (varcte -> CTE_INT empty .)
    MINUS           reduce using rule 114 (varcte -> CTE_INT empty .)
    LESS            reduce using rule 114 (varcte -> CTE_INT empty .)
    GREATER         reduce using rule 114 (varcte -> CTE_INT empty .)
    LESS_TH         reduce using rule 114 (varcte -> CTE_INT empty .)
    GREAT_TH        reduce using rule 114 (varcte -> CTE_INT empty .)
    SAME            reduce using rule 114 (varcte -> CTE_INT empty .)
    DIF             reduce using rule 114 (varcte -> CTE_INT empty .)
    ID              reduce using rule 114 (varcte -> CTE_INT empty .)
    RETURN          reduce using rule 114 (varcte -> CTE_INT empty .)
    READ            reduce using rule 114 (varcte -> CTE_INT empty .)
    WRITE           reduce using rule 114 (varcte -> CTE_INT empty .)
    IF              reduce using rule 114 (varcte -> CTE_INT empty .)
    VAR             reduce using rule 114 (varcte -> CTE_INT empty .)
    WHILE           reduce using rule 114 (varcte -> CTE_INT empty .)
    FROM            reduce using rule 114 (varcte -> CTE_INT empty .)
    R_CURPAR        reduce using rule 114 (varcte -> CTE_INT empty .)
    SEMICOLON       reduce using rule 114 (varcte -> CTE_INT empty .)
    R_PAR           reduce using rule 114 (varcte -> CTE_INT empty .)
    COMMA           reduce using rule 114 (varcte -> CTE_INT empty .)
    R_BREAK         reduce using rule 114 (varcte -> CTE_INT empty .)
    TO              reduce using rule 114 (varcte -> CTE_INT empty .)
    OR              reduce using rule 114 (varcte -> CTE_INT empty .)
    AND             reduce using rule 114 (varcte -> CTE_INT empty .)
    DO              reduce using rule 114 (varcte -> CTE_INT empty .)


state 216

    (115) varcte -> CTE_FLOAT empty .

    MULT            reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    DIV             reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    PLUS            reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    MINUS           reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    LESS            reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    GREATER         reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    LESS_TH         reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    GREAT_TH        reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    SAME            reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    DIF             reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    ID              reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    RETURN          reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    READ            reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    WRITE           reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    IF              reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    VAR             reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    WHILE           reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    FROM            reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    R_CURPAR        reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    SEMICOLON       reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    R_PAR           reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    COMMA           reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    R_BREAK         reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    TO              reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    OR              reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    AND             reduce using rule 115 (varcte -> CTE_FLOAT empty .)
    DO              reduce using rule 115 (varcte -> CTE_FLOAT empty .)


state 217

    (116) varcte -> CTE_STRING empty .

    MULT            reduce using rule 116 (varcte -> CTE_STRING empty .)
    DIV             reduce using rule 116 (varcte -> CTE_STRING empty .)
    PLUS            reduce using rule 116 (varcte -> CTE_STRING empty .)
    MINUS           reduce using rule 116 (varcte -> CTE_STRING empty .)
    LESS            reduce using rule 116 (varcte -> CTE_STRING empty .)
    GREATER         reduce using rule 116 (varcte -> CTE_STRING empty .)
    LESS_TH         reduce using rule 116 (varcte -> CTE_STRING empty .)
    GREAT_TH        reduce using rule 116 (varcte -> CTE_STRING empty .)
    SAME            reduce using rule 116 (varcte -> CTE_STRING empty .)
    DIF             reduce using rule 116 (varcte -> CTE_STRING empty .)
    ID              reduce using rule 116 (varcte -> CTE_STRING empty .)
    RETURN          reduce using rule 116 (varcte -> CTE_STRING empty .)
    READ            reduce using rule 116 (varcte -> CTE_STRING empty .)
    WRITE           reduce using rule 116 (varcte -> CTE_STRING empty .)
    IF              reduce using rule 116 (varcte -> CTE_STRING empty .)
    VAR             reduce using rule 116 (varcte -> CTE_STRING empty .)
    WHILE           reduce using rule 116 (varcte -> CTE_STRING empty .)
    FROM            reduce using rule 116 (varcte -> CTE_STRING empty .)
    R_CURPAR        reduce using rule 116 (varcte -> CTE_STRING empty .)
    SEMICOLON       reduce using rule 116 (varcte -> CTE_STRING empty .)
    R_PAR           reduce using rule 116 (varcte -> CTE_STRING empty .)
    COMMA           reduce using rule 116 (varcte -> CTE_STRING empty .)
    R_BREAK         reduce using rule 116 (varcte -> CTE_STRING empty .)
    TO              reduce using rule 116 (varcte -> CTE_STRING empty .)
    OR              reduce using rule 116 (varcte -> CTE_STRING empty .)
    AND             reduce using rule 116 (varcte -> CTE_STRING empty .)
    DO              reduce using rule 116 (varcte -> CTE_STRING empty .)


state 218

    (60) var -> ID DOT . VAR varF

    VAR             shift and go to state 167


state 219

    (78) assigmentF -> ope exp empty .

    ID              reduce using rule 78 (assigmentF -> ope exp empty .)
    RETURN          reduce using rule 78 (assigmentF -> ope exp empty .)
    READ            reduce using rule 78 (assigmentF -> ope exp empty .)
    WRITE           reduce using rule 78 (assigmentF -> ope exp empty .)
    IF              reduce using rule 78 (assigmentF -> ope exp empty .)
    VAR             reduce using rule 78 (assigmentF -> ope exp empty .)
    WHILE           reduce using rule 78 (assigmentF -> ope exp empty .)
    FROM            reduce using rule 78 (assigmentF -> ope exp empty .)
    R_CURPAR        reduce using rule 78 (assigmentF -> ope exp empty .)
    SEMICOLON       reduce using rule 78 (assigmentF -> ope exp empty .)


state 220

    (51) void -> ID DOT ID L_PAR . param R_PAR SEMICOLON empty
    (55) param -> . var paramF
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    VAR             shift and go to state 91
    ID              shift and go to state 160

    param                          shift and go to state 257
    var                            shift and go to state 169

state 221

    (60) var -> ID DOT VAR varF .

    EQUAL           reduce using rule 60 (var -> ID DOT VAR varF .)
    PLUS_EQ         reduce using rule 60 (var -> ID DOT VAR varF .)
    MIN_EQ          reduce using rule 60 (var -> ID DOT VAR varF .)
    MULT_EQ         reduce using rule 60 (var -> ID DOT VAR varF .)
    DIV_EQ          reduce using rule 60 (var -> ID DOT VAR varF .)
    MULT            reduce using rule 60 (var -> ID DOT VAR varF .)
    DIV             reduce using rule 60 (var -> ID DOT VAR varF .)
    PLUS            reduce using rule 60 (var -> ID DOT VAR varF .)
    MINUS           reduce using rule 60 (var -> ID DOT VAR varF .)
    LESS            reduce using rule 60 (var -> ID DOT VAR varF .)
    GREATER         reduce using rule 60 (var -> ID DOT VAR varF .)
    LESS_TH         reduce using rule 60 (var -> ID DOT VAR varF .)
    GREAT_TH        reduce using rule 60 (var -> ID DOT VAR varF .)
    SAME            reduce using rule 60 (var -> ID DOT VAR varF .)
    DIF             reduce using rule 60 (var -> ID DOT VAR varF .)
    ID              reduce using rule 60 (var -> ID DOT VAR varF .)
    RETURN          reduce using rule 60 (var -> ID DOT VAR varF .)
    READ            reduce using rule 60 (var -> ID DOT VAR varF .)
    WRITE           reduce using rule 60 (var -> ID DOT VAR varF .)
    IF              reduce using rule 60 (var -> ID DOT VAR varF .)
    VAR             reduce using rule 60 (var -> ID DOT VAR varF .)
    WHILE           reduce using rule 60 (var -> ID DOT VAR varF .)
    FROM            reduce using rule 60 (var -> ID DOT VAR varF .)
    R_CURPAR        reduce using rule 60 (var -> ID DOT VAR varF .)
    SEMICOLON       reduce using rule 60 (var -> ID DOT VAR varF .)
    COMMA           reduce using rule 60 (var -> ID DOT VAR varF .)
    R_PAR           reduce using rule 60 (var -> ID DOT VAR varF .)
    R_BREAK         reduce using rule 60 (var -> ID DOT VAR varF .)
    TO              reduce using rule 60 (var -> ID DOT VAR varF .)
    OR              reduce using rule 60 (var -> ID DOT VAR varF .)
    AND             reduce using rule 60 (var -> ID DOT VAR varF .)
    DO              reduce using rule 60 (var -> ID DOT VAR varF .)


state 222

    (52) void -> ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 258


state 223

    (55) param -> var paramF .

    R_PAR           reduce using rule 55 (param -> var paramF .)


state 224

    (56) paramF -> COMMA . param
    (55) param -> . var paramF
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    VAR             shift and go to state 91
    ID              shift and go to state 160

    param                          shift and go to state 259
    var                            shift and go to state 169

state 225

    (57) paramF -> empty .

    R_PAR           reduce using rule 57 (paramF -> empty .)


state 226

    (58) return -> RETURN L_PAR exp R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 260


state 227

    (64) readF -> var COMMA . readF
    (64) readF -> . var COMMA readF
    (65) readF -> . var R_PAR SEMICOLON empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    VAR             shift and go to state 91
    ID              shift and go to state 160

    var                            shift and go to state 172
    readF                          shift and go to state 261

state 228

    (65) readF -> var R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 262


state 229

    (67) writeT -> CTE_STRING writeF .

    ID              reduce using rule 67 (writeT -> CTE_STRING writeF .)
    RETURN          reduce using rule 67 (writeT -> CTE_STRING writeF .)
    READ            reduce using rule 67 (writeT -> CTE_STRING writeF .)
    WRITE           reduce using rule 67 (writeT -> CTE_STRING writeF .)
    IF              reduce using rule 67 (writeT -> CTE_STRING writeF .)
    VAR             reduce using rule 67 (writeT -> CTE_STRING writeF .)
    WHILE           reduce using rule 67 (writeT -> CTE_STRING writeF .)
    FROM            reduce using rule 67 (writeT -> CTE_STRING writeF .)
    R_CURPAR        reduce using rule 67 (writeT -> CTE_STRING writeF .)
    SEMICOLON       reduce using rule 67 (writeT -> CTE_STRING writeF .)


state 230

    (69) writeF -> COMMA . writeT
    (67) writeT -> . CTE_STRING writeF
    (68) writeT -> . exp writeF
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 174
    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    VAR             shift and go to state 91
    ID              shift and go to state 160

    writeT                         shift and go to state 263
    exp                            shift and go to state 175
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 231

    (70) writeF -> R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 264


state 232

    (68) writeT -> exp writeF .

    ID              reduce using rule 68 (writeT -> exp writeF .)
    RETURN          reduce using rule 68 (writeT -> exp writeF .)
    READ            reduce using rule 68 (writeT -> exp writeF .)
    WRITE           reduce using rule 68 (writeT -> exp writeF .)
    IF              reduce using rule 68 (writeT -> exp writeF .)
    VAR             reduce using rule 68 (writeT -> exp writeF .)
    WHILE           reduce using rule 68 (writeT -> exp writeF .)
    FROM            reduce using rule 68 (writeT -> exp writeF .)
    R_CURPAR        reduce using rule 68 (writeT -> exp writeF .)
    SEMICOLON       reduce using rule 68 (writeT -> exp writeF .)


state 233

    (73) if -> IF L_PAR exp R_PAR . THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    THEN            shift and go to state 265


state 234

    (53) arrfunc -> L_BREAK exp COMMA . exp R_BREAK empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 266
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 235

    (54) arrfunc -> L_BREAK exp R_BREAK . empty
    (117) empty -> .

    EQUAL           reduce using rule 117 (empty -> .)
    PLUS_EQ         reduce using rule 117 (empty -> .)
    MIN_EQ          reduce using rule 117 (empty -> .)
    MULT_EQ         reduce using rule 117 (empty -> .)
    DIV_EQ          reduce using rule 117 (empty -> .)
    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)
    L_PAR           reduce using rule 117 (empty -> .)
    CTE_INT         reduce using rule 117 (empty -> .)
    CTE_FLOAT       reduce using rule 117 (empty -> .)
    CTE_STRING      reduce using rule 117 (empty -> .)

    empty                          shift and go to state 267

state 236

    (83) conditional -> WHILE L_PAR exp R_PAR . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 268


state 237

    (84) nonconditional -> FROM VAR arrfunc nonconditionalF .

    ID              reduce using rule 84 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    RETURN          reduce using rule 84 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    READ            reduce using rule 84 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WRITE           reduce using rule 84 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    IF              reduce using rule 84 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    VAR             reduce using rule 84 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WHILE           reduce using rule 84 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    FROM            reduce using rule 84 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    R_CURPAR        reduce using rule 84 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    SEMICOLON       reduce using rule 84 (nonconditional -> FROM VAR arrfunc nonconditionalF .)


state 238

    (86) nonconditionalF -> exp TO . exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 269
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 239

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR . SEMICOLON empty

    SEMICOLON       shift and go to state 270


state 240

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    statement                      shift and go to state 271
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 241

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 272


state 242

    (33) parameter -> VAR COLON typepar SEMICOLON parameterF .

    R_PAR           reduce using rule 33 (parameter -> VAR COLON typepar SEMICOLON parameterF .)


state 243

    (34) parameterF -> parameter .

    R_PAR           reduce using rule 34 (parameterF -> parameter .)


state 244

    (35) parameterF -> empty .

    R_PAR           reduce using rule 35 (parameterF -> empty .)


state 245

    (90) expT -> LESS expf .

    ID              reduce using rule 90 (expT -> LESS expf .)
    RETURN          reduce using rule 90 (expT -> LESS expf .)
    READ            reduce using rule 90 (expT -> LESS expf .)
    WRITE           reduce using rule 90 (expT -> LESS expf .)
    IF              reduce using rule 90 (expT -> LESS expf .)
    VAR             reduce using rule 90 (expT -> LESS expf .)
    WHILE           reduce using rule 90 (expT -> LESS expf .)
    FROM            reduce using rule 90 (expT -> LESS expf .)
    R_CURPAR        reduce using rule 90 (expT -> LESS expf .)
    SEMICOLON       reduce using rule 90 (expT -> LESS expf .)
    R_PAR           reduce using rule 90 (expT -> LESS expf .)
    COMMA           reduce using rule 90 (expT -> LESS expf .)
    R_BREAK         reduce using rule 90 (expT -> LESS expf .)
    TO              reduce using rule 90 (expT -> LESS expf .)
    DO              reduce using rule 90 (expT -> LESS expf .)


state 246

    (97) expf -> ex . empty
    (98) expf -> ex . bool empty
    (117) empty -> .
    (87) bool -> . OR exp empty
    (88) bool -> . AND exp empty

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)
    OR              shift and go to state 275
    AND             shift and go to state 276

    empty                          shift and go to state 273
    bool                           shift and go to state 274

state 247

    (91) expT -> GREATER expf .

    ID              reduce using rule 91 (expT -> GREATER expf .)
    RETURN          reduce using rule 91 (expT -> GREATER expf .)
    READ            reduce using rule 91 (expT -> GREATER expf .)
    WRITE           reduce using rule 91 (expT -> GREATER expf .)
    IF              reduce using rule 91 (expT -> GREATER expf .)
    VAR             reduce using rule 91 (expT -> GREATER expf .)
    WHILE           reduce using rule 91 (expT -> GREATER expf .)
    FROM            reduce using rule 91 (expT -> GREATER expf .)
    R_CURPAR        reduce using rule 91 (expT -> GREATER expf .)
    SEMICOLON       reduce using rule 91 (expT -> GREATER expf .)
    R_PAR           reduce using rule 91 (expT -> GREATER expf .)
    COMMA           reduce using rule 91 (expT -> GREATER expf .)
    R_BREAK         reduce using rule 91 (expT -> GREATER expf .)
    TO              reduce using rule 91 (expT -> GREATER expf .)
    DO              reduce using rule 91 (expT -> GREATER expf .)


state 248

    (92) expT -> LESS_TH expf .

    ID              reduce using rule 92 (expT -> LESS_TH expf .)
    RETURN          reduce using rule 92 (expT -> LESS_TH expf .)
    READ            reduce using rule 92 (expT -> LESS_TH expf .)
    WRITE           reduce using rule 92 (expT -> LESS_TH expf .)
    IF              reduce using rule 92 (expT -> LESS_TH expf .)
    VAR             reduce using rule 92 (expT -> LESS_TH expf .)
    WHILE           reduce using rule 92 (expT -> LESS_TH expf .)
    FROM            reduce using rule 92 (expT -> LESS_TH expf .)
    R_CURPAR        reduce using rule 92 (expT -> LESS_TH expf .)
    SEMICOLON       reduce using rule 92 (expT -> LESS_TH expf .)
    R_PAR           reduce using rule 92 (expT -> LESS_TH expf .)
    COMMA           reduce using rule 92 (expT -> LESS_TH expf .)
    R_BREAK         reduce using rule 92 (expT -> LESS_TH expf .)
    TO              reduce using rule 92 (expT -> LESS_TH expf .)
    DO              reduce using rule 92 (expT -> LESS_TH expf .)


state 249

    (93) expT -> GREAT_TH expf .

    ID              reduce using rule 93 (expT -> GREAT_TH expf .)
    RETURN          reduce using rule 93 (expT -> GREAT_TH expf .)
    READ            reduce using rule 93 (expT -> GREAT_TH expf .)
    WRITE           reduce using rule 93 (expT -> GREAT_TH expf .)
    IF              reduce using rule 93 (expT -> GREAT_TH expf .)
    VAR             reduce using rule 93 (expT -> GREAT_TH expf .)
    WHILE           reduce using rule 93 (expT -> GREAT_TH expf .)
    FROM            reduce using rule 93 (expT -> GREAT_TH expf .)
    R_CURPAR        reduce using rule 93 (expT -> GREAT_TH expf .)
    SEMICOLON       reduce using rule 93 (expT -> GREAT_TH expf .)
    R_PAR           reduce using rule 93 (expT -> GREAT_TH expf .)
    COMMA           reduce using rule 93 (expT -> GREAT_TH expf .)
    R_BREAK         reduce using rule 93 (expT -> GREAT_TH expf .)
    TO              reduce using rule 93 (expT -> GREAT_TH expf .)
    DO              reduce using rule 93 (expT -> GREAT_TH expf .)


state 250

    (94) expT -> SAME expf .

    ID              reduce using rule 94 (expT -> SAME expf .)
    RETURN          reduce using rule 94 (expT -> SAME expf .)
    READ            reduce using rule 94 (expT -> SAME expf .)
    WRITE           reduce using rule 94 (expT -> SAME expf .)
    IF              reduce using rule 94 (expT -> SAME expf .)
    VAR             reduce using rule 94 (expT -> SAME expf .)
    WHILE           reduce using rule 94 (expT -> SAME expf .)
    FROM            reduce using rule 94 (expT -> SAME expf .)
    R_CURPAR        reduce using rule 94 (expT -> SAME expf .)
    SEMICOLON       reduce using rule 94 (expT -> SAME expf .)
    R_PAR           reduce using rule 94 (expT -> SAME expf .)
    COMMA           reduce using rule 94 (expT -> SAME expf .)
    R_BREAK         reduce using rule 94 (expT -> SAME expf .)
    TO              reduce using rule 94 (expT -> SAME expf .)
    DO              reduce using rule 94 (expT -> SAME expf .)


state 251

    (95) expT -> DIF expf .

    ID              reduce using rule 95 (expT -> DIF expf .)
    RETURN          reduce using rule 95 (expT -> DIF expf .)
    READ            reduce using rule 95 (expT -> DIF expf .)
    WRITE           reduce using rule 95 (expT -> DIF expf .)
    IF              reduce using rule 95 (expT -> DIF expf .)
    VAR             reduce using rule 95 (expT -> DIF expf .)
    WHILE           reduce using rule 95 (expT -> DIF expf .)
    FROM            reduce using rule 95 (expT -> DIF expf .)
    R_CURPAR        reduce using rule 95 (expT -> DIF expf .)
    SEMICOLON       reduce using rule 95 (expT -> DIF expf .)
    R_PAR           reduce using rule 95 (expT -> DIF expf .)
    COMMA           reduce using rule 95 (expT -> DIF expf .)
    R_BREAK         reduce using rule 95 (expT -> DIF expf .)
    TO              reduce using rule 95 (expT -> DIF expf .)
    DO              reduce using rule 95 (expT -> DIF expf .)


state 252

    (100) exF -> PLUS ex .

    LESS            reduce using rule 100 (exF -> PLUS ex .)
    GREATER         reduce using rule 100 (exF -> PLUS ex .)
    LESS_TH         reduce using rule 100 (exF -> PLUS ex .)
    GREAT_TH        reduce using rule 100 (exF -> PLUS ex .)
    SAME            reduce using rule 100 (exF -> PLUS ex .)
    DIF             reduce using rule 100 (exF -> PLUS ex .)
    ID              reduce using rule 100 (exF -> PLUS ex .)
    RETURN          reduce using rule 100 (exF -> PLUS ex .)
    READ            reduce using rule 100 (exF -> PLUS ex .)
    WRITE           reduce using rule 100 (exF -> PLUS ex .)
    IF              reduce using rule 100 (exF -> PLUS ex .)
    VAR             reduce using rule 100 (exF -> PLUS ex .)
    WHILE           reduce using rule 100 (exF -> PLUS ex .)
    FROM            reduce using rule 100 (exF -> PLUS ex .)
    R_CURPAR        reduce using rule 100 (exF -> PLUS ex .)
    SEMICOLON       reduce using rule 100 (exF -> PLUS ex .)
    R_PAR           reduce using rule 100 (exF -> PLUS ex .)
    COMMA           reduce using rule 100 (exF -> PLUS ex .)
    R_BREAK         reduce using rule 100 (exF -> PLUS ex .)
    TO              reduce using rule 100 (exF -> PLUS ex .)
    OR              reduce using rule 100 (exF -> PLUS ex .)
    AND             reduce using rule 100 (exF -> PLUS ex .)
    DO              reduce using rule 100 (exF -> PLUS ex .)


state 253

    (101) exF -> MINUS ex .

    LESS            reduce using rule 101 (exF -> MINUS ex .)
    GREATER         reduce using rule 101 (exF -> MINUS ex .)
    LESS_TH         reduce using rule 101 (exF -> MINUS ex .)
    GREAT_TH        reduce using rule 101 (exF -> MINUS ex .)
    SAME            reduce using rule 101 (exF -> MINUS ex .)
    DIF             reduce using rule 101 (exF -> MINUS ex .)
    ID              reduce using rule 101 (exF -> MINUS ex .)
    RETURN          reduce using rule 101 (exF -> MINUS ex .)
    READ            reduce using rule 101 (exF -> MINUS ex .)
    WRITE           reduce using rule 101 (exF -> MINUS ex .)
    IF              reduce using rule 101 (exF -> MINUS ex .)
    VAR             reduce using rule 101 (exF -> MINUS ex .)
    WHILE           reduce using rule 101 (exF -> MINUS ex .)
    FROM            reduce using rule 101 (exF -> MINUS ex .)
    R_CURPAR        reduce using rule 101 (exF -> MINUS ex .)
    SEMICOLON       reduce using rule 101 (exF -> MINUS ex .)
    R_PAR           reduce using rule 101 (exF -> MINUS ex .)
    COMMA           reduce using rule 101 (exF -> MINUS ex .)
    R_BREAK         reduce using rule 101 (exF -> MINUS ex .)
    TO              reduce using rule 101 (exF -> MINUS ex .)
    OR              reduce using rule 101 (exF -> MINUS ex .)
    AND             reduce using rule 101 (exF -> MINUS ex .)
    DO              reduce using rule 101 (exF -> MINUS ex .)


state 254

    (104) termF -> MULT term .

    PLUS            reduce using rule 104 (termF -> MULT term .)
    MINUS           reduce using rule 104 (termF -> MULT term .)
    LESS            reduce using rule 104 (termF -> MULT term .)
    GREATER         reduce using rule 104 (termF -> MULT term .)
    LESS_TH         reduce using rule 104 (termF -> MULT term .)
    GREAT_TH        reduce using rule 104 (termF -> MULT term .)
    SAME            reduce using rule 104 (termF -> MULT term .)
    DIF             reduce using rule 104 (termF -> MULT term .)
    ID              reduce using rule 104 (termF -> MULT term .)
    RETURN          reduce using rule 104 (termF -> MULT term .)
    READ            reduce using rule 104 (termF -> MULT term .)
    WRITE           reduce using rule 104 (termF -> MULT term .)
    IF              reduce using rule 104 (termF -> MULT term .)
    VAR             reduce using rule 104 (termF -> MULT term .)
    WHILE           reduce using rule 104 (termF -> MULT term .)
    FROM            reduce using rule 104 (termF -> MULT term .)
    R_CURPAR        reduce using rule 104 (termF -> MULT term .)
    SEMICOLON       reduce using rule 104 (termF -> MULT term .)
    R_PAR           reduce using rule 104 (termF -> MULT term .)
    COMMA           reduce using rule 104 (termF -> MULT term .)
    R_BREAK         reduce using rule 104 (termF -> MULT term .)
    TO              reduce using rule 104 (termF -> MULT term .)
    OR              reduce using rule 104 (termF -> MULT term .)
    AND             reduce using rule 104 (termF -> MULT term .)
    DO              reduce using rule 104 (termF -> MULT term .)


state 255

    (105) termF -> DIV term .

    PLUS            reduce using rule 105 (termF -> DIV term .)
    MINUS           reduce using rule 105 (termF -> DIV term .)
    LESS            reduce using rule 105 (termF -> DIV term .)
    GREATER         reduce using rule 105 (termF -> DIV term .)
    LESS_TH         reduce using rule 105 (termF -> DIV term .)
    GREAT_TH        reduce using rule 105 (termF -> DIV term .)
    SAME            reduce using rule 105 (termF -> DIV term .)
    DIF             reduce using rule 105 (termF -> DIV term .)
    ID              reduce using rule 105 (termF -> DIV term .)
    RETURN          reduce using rule 105 (termF -> DIV term .)
    READ            reduce using rule 105 (termF -> DIV term .)
    WRITE           reduce using rule 105 (termF -> DIV term .)
    IF              reduce using rule 105 (termF -> DIV term .)
    VAR             reduce using rule 105 (termF -> DIV term .)
    WHILE           reduce using rule 105 (termF -> DIV term .)
    FROM            reduce using rule 105 (termF -> DIV term .)
    R_CURPAR        reduce using rule 105 (termF -> DIV term .)
    SEMICOLON       reduce using rule 105 (termF -> DIV term .)
    R_PAR           reduce using rule 105 (termF -> DIV term .)
    COMMA           reduce using rule 105 (termF -> DIV term .)
    R_BREAK         reduce using rule 105 (termF -> DIV term .)
    TO              reduce using rule 105 (termF -> DIV term .)
    OR              reduce using rule 105 (termF -> DIV term .)
    AND             reduce using rule 105 (termF -> DIV term .)
    DO              reduce using rule 105 (termF -> DIV term .)


state 256

    (107) factor -> L_PAR exp R_PAR . empty
    (117) empty -> .

    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 277

state 257

    (51) void -> ID DOT ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 278


state 258

    (52) void -> ID L_PAR param R_PAR SEMICOLON . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 279

state 259

    (56) paramF -> COMMA param .

    R_PAR           reduce using rule 56 (paramF -> COMMA param .)


state 260

    (58) return -> RETURN L_PAR exp R_PAR SEMICOLON . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 280

state 261

    (64) readF -> var COMMA readF .

    ID              reduce using rule 64 (readF -> var COMMA readF .)
    RETURN          reduce using rule 64 (readF -> var COMMA readF .)
    READ            reduce using rule 64 (readF -> var COMMA readF .)
    WRITE           reduce using rule 64 (readF -> var COMMA readF .)
    IF              reduce using rule 64 (readF -> var COMMA readF .)
    VAR             reduce using rule 64 (readF -> var COMMA readF .)
    WHILE           reduce using rule 64 (readF -> var COMMA readF .)
    FROM            reduce using rule 64 (readF -> var COMMA readF .)
    R_CURPAR        reduce using rule 64 (readF -> var COMMA readF .)
    SEMICOLON       reduce using rule 64 (readF -> var COMMA readF .)


state 262

    (65) readF -> var R_PAR SEMICOLON . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 281

state 263

    (69) writeF -> COMMA writeT .

    ID              reduce using rule 69 (writeF -> COMMA writeT .)
    RETURN          reduce using rule 69 (writeF -> COMMA writeT .)
    READ            reduce using rule 69 (writeF -> COMMA writeT .)
    WRITE           reduce using rule 69 (writeF -> COMMA writeT .)
    IF              reduce using rule 69 (writeF -> COMMA writeT .)
    VAR             reduce using rule 69 (writeF -> COMMA writeT .)
    WHILE           reduce using rule 69 (writeF -> COMMA writeT .)
    FROM            reduce using rule 69 (writeF -> COMMA writeT .)
    R_CURPAR        reduce using rule 69 (writeF -> COMMA writeT .)
    SEMICOLON       reduce using rule 69 (writeF -> COMMA writeT .)


state 264

    (70) writeF -> R_PAR SEMICOLON . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 282

state 265

    (73) if -> IF L_PAR exp R_PAR THEN . L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_CURPAR        shift and go to state 283


state 266

    (53) arrfunc -> L_BREAK exp COMMA exp . R_BREAK empty

    R_BREAK         shift and go to state 284


state 267

    (54) arrfunc -> L_BREAK exp R_BREAK empty .

    EQUAL           reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MIN_EQ          reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT_EQ         reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV_EQ          reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT            reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV             reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS            reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MINUS           reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS            reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREATER         reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS_TH         reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREAT_TH        reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SAME            reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIF             reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    ID              reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    RETURN          reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    READ            reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WRITE           reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    IF              reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    VAR             reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WHILE           reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    FROM            reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_CURPAR        reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SEMICOLON       reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    COMMA           reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_PAR           reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_BREAK         reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    TO              reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    OR              reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    AND             reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DO              reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    L_PAR           reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_INT         reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_STRING      reduce using rule 54 (arrfunc -> L_BREAK exp R_BREAK empty .)


state 268

    (83) conditional -> WHILE L_PAR exp R_PAR DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 285


state 269

    (86) nonconditionalF -> exp TO exp . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 286


state 270

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON . empty
    (117) empty -> .

    CLASS           reduce using rule 117 (empty -> .)
    VARS            reduce using rule 117 (empty -> .)
    MAIN            reduce using rule 117 (empty -> .)
    INT             reduce using rule 117 (empty -> .)
    FLOAT           reduce using rule 117 (empty -> .)
    CHAR            reduce using rule 117 (empty -> .)
    STRING          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    VOID            reduce using rule 117 (empty -> .)

    empty                          shift and go to state 287

state 271

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 288


state 272

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (117) empty -> .

    MAIN            reduce using rule 117 (empty -> .)
    INT             reduce using rule 117 (empty -> .)
    FLOAT           reduce using rule 117 (empty -> .)
    CHAR            reduce using rule 117 (empty -> .)
    STRING          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    VOID            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)

    empty                          shift and go to state 289

state 273

    (97) expf -> ex empty .

    ID              reduce using rule 97 (expf -> ex empty .)
    RETURN          reduce using rule 97 (expf -> ex empty .)
    READ            reduce using rule 97 (expf -> ex empty .)
    WRITE           reduce using rule 97 (expf -> ex empty .)
    IF              reduce using rule 97 (expf -> ex empty .)
    VAR             reduce using rule 97 (expf -> ex empty .)
    WHILE           reduce using rule 97 (expf -> ex empty .)
    FROM            reduce using rule 97 (expf -> ex empty .)
    R_CURPAR        reduce using rule 97 (expf -> ex empty .)
    SEMICOLON       reduce using rule 97 (expf -> ex empty .)
    R_PAR           reduce using rule 97 (expf -> ex empty .)
    COMMA           reduce using rule 97 (expf -> ex empty .)
    R_BREAK         reduce using rule 97 (expf -> ex empty .)
    TO              reduce using rule 97 (expf -> ex empty .)
    DO              reduce using rule 97 (expf -> ex empty .)


state 274

    (98) expf -> ex bool . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 290

state 275

    (87) bool -> OR . exp empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 291
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 276

    (88) bool -> AND . exp empty
    (89) exp -> . ex expT
    (99) ex -> . term exF
    (103) term -> . factor termF
    (107) factor -> . L_PAR exp R_PAR empty
    (108) factor -> . factorT
    (109) factorT -> . PLUS factorF
    (110) factorT -> . MINUS factorF
    (111) factorT -> . factorF
    (112) factorF -> . varcte empty
    (113) varcte -> . var empty
    (114) varcte -> . CTE_INT empty
    (115) varcte -> . CTE_FLOAT empty
    (116) varcte -> . CTE_STRING empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 150
    PLUS            shift and go to state 152
    MINUS           shift and go to state 154
    CTE_INT         shift and go to state 157
    CTE_FLOAT       shift and go to state 158
    CTE_STRING      shift and go to state 159
    VAR             shift and go to state 91
    ID              shift and go to state 160

    exp                            shift and go to state 292
    ex                             shift and go to state 147
    term                           shift and go to state 148
    factor                         shift and go to state 149
    factorT                        shift and go to state 151
    factorF                        shift and go to state 153
    varcte                         shift and go to state 155
    var                            shift and go to state 156

state 277

    (107) factor -> L_PAR exp R_PAR empty .

    MULT            reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    DIV             reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    PLUS            reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    MINUS           reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    LESS            reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    GREATER         reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    LESS_TH         reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    GREAT_TH        reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    SAME            reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    DIF             reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    ID              reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    RETURN          reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    READ            reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    WRITE           reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    IF              reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    VAR             reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    WHILE           reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    FROM            reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    R_CURPAR        reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    SEMICOLON       reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    R_PAR           reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    COMMA           reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    R_BREAK         reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    TO              reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    OR              reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    AND             reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)
    DO              reduce using rule 107 (factor -> L_PAR exp R_PAR empty .)


state 278

    (51) void -> ID DOT ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 293


state 279

    (52) void -> ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)


state 280

    (58) return -> RETURN L_PAR exp R_PAR SEMICOLON empty .

    ID              reduce using rule 58 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 58 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    READ            reduce using rule 58 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 58 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    IF              reduce using rule 58 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    VAR             reduce using rule 58 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 58 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    FROM            reduce using rule 58 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 58 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 58 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)


state 281

    (65) readF -> var R_PAR SEMICOLON empty .

    ID              reduce using rule 65 (readF -> var R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 65 (readF -> var R_PAR SEMICOLON empty .)
    READ            reduce using rule 65 (readF -> var R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 65 (readF -> var R_PAR SEMICOLON empty .)
    IF              reduce using rule 65 (readF -> var R_PAR SEMICOLON empty .)
    VAR             reduce using rule 65 (readF -> var R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 65 (readF -> var R_PAR SEMICOLON empty .)
    FROM            reduce using rule 65 (readF -> var R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 65 (readF -> var R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 65 (readF -> var R_PAR SEMICOLON empty .)


state 282

    (70) writeF -> R_PAR SEMICOLON empty .

    ID              reduce using rule 70 (writeF -> R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 70 (writeF -> R_PAR SEMICOLON empty .)
    READ            reduce using rule 70 (writeF -> R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 70 (writeF -> R_PAR SEMICOLON empty .)
    IF              reduce using rule 70 (writeF -> R_PAR SEMICOLON empty .)
    VAR             reduce using rule 70 (writeF -> R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 70 (writeF -> R_PAR SEMICOLON empty .)
    FROM            reduce using rule 70 (writeF -> R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 70 (writeF -> R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 70 (writeF -> R_PAR SEMICOLON empty .)


state 283

    (73) if -> IF L_PAR exp R_PAR THEN L_CURPAR . statement SEMICOLON R_CURPAR ifF
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    statement                      shift and go to state 294
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 284

    (53) arrfunc -> L_BREAK exp COMMA exp R_BREAK . empty
    (117) empty -> .

    EQUAL           reduce using rule 117 (empty -> .)
    PLUS_EQ         reduce using rule 117 (empty -> .)
    MIN_EQ          reduce using rule 117 (empty -> .)
    MULT_EQ         reduce using rule 117 (empty -> .)
    DIV_EQ          reduce using rule 117 (empty -> .)
    MULT            reduce using rule 117 (empty -> .)
    DIV             reduce using rule 117 (empty -> .)
    PLUS            reduce using rule 117 (empty -> .)
    MINUS           reduce using rule 117 (empty -> .)
    LESS            reduce using rule 117 (empty -> .)
    GREATER         reduce using rule 117 (empty -> .)
    LESS_TH         reduce using rule 117 (empty -> .)
    GREAT_TH        reduce using rule 117 (empty -> .)
    SAME            reduce using rule 117 (empty -> .)
    DIF             reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)
    L_PAR           reduce using rule 117 (empty -> .)
    CTE_INT         reduce using rule 117 (empty -> .)
    CTE_FLOAT       reduce using rule 117 (empty -> .)
    CTE_STRING      reduce using rule 117 (empty -> .)

    empty                          shift and go to state 295

state 285

    (83) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    statement                      shift and go to state 296
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 286

    (86) nonconditionalF -> exp TO exp DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 297


state 287

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .

    CLASS           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VARS            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    MAIN            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    INT             reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    FLOAT           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    CHAR            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    STRING          reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    ID              reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VOID            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)


state 288

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (117) empty -> .

    MAIN            reduce using rule 117 (empty -> .)
    INT             reduce using rule 117 (empty -> .)
    FLOAT           reduce using rule 117 (empty -> .)
    CHAR            reduce using rule 117 (empty -> .)
    STRING          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    VOID            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)

    empty                          shift and go to state 298

state 289

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    STRING          reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 290

    (98) expf -> ex bool empty .

    ID              reduce using rule 98 (expf -> ex bool empty .)
    RETURN          reduce using rule 98 (expf -> ex bool empty .)
    READ            reduce using rule 98 (expf -> ex bool empty .)
    WRITE           reduce using rule 98 (expf -> ex bool empty .)
    IF              reduce using rule 98 (expf -> ex bool empty .)
    VAR             reduce using rule 98 (expf -> ex bool empty .)
    WHILE           reduce using rule 98 (expf -> ex bool empty .)
    FROM            reduce using rule 98 (expf -> ex bool empty .)
    R_CURPAR        reduce using rule 98 (expf -> ex bool empty .)
    SEMICOLON       reduce using rule 98 (expf -> ex bool empty .)
    R_PAR           reduce using rule 98 (expf -> ex bool empty .)
    COMMA           reduce using rule 98 (expf -> ex bool empty .)
    R_BREAK         reduce using rule 98 (expf -> ex bool empty .)
    TO              reduce using rule 98 (expf -> ex bool empty .)
    DO              reduce using rule 98 (expf -> ex bool empty .)


state 291

    (87) bool -> OR exp . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 299

state 292

    (88) bool -> AND exp . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)
    R_PAR           reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    R_BREAK         reduce using rule 117 (empty -> .)
    TO              reduce using rule 117 (empty -> .)
    DO              reduce using rule 117 (empty -> .)

    empty                          shift and go to state 300

state 293

    (51) void -> ID DOT ID L_PAR param R_PAR SEMICOLON . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 301

state 294

    (73) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement . SEMICOLON R_CURPAR ifF

    SEMICOLON       shift and go to state 302


state 295

    (53) arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .

    EQUAL           reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MIN_EQ          reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT_EQ         reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV_EQ          reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT            reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV             reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS            reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MINUS           reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS            reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREATER         reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS_TH         reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREAT_TH        reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SAME            reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIF             reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    ID              reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    RETURN          reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    READ            reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WRITE           reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    IF              reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    VAR             reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WHILE           reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    FROM            reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_CURPAR        reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SEMICOLON       reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    COMMA           reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_PAR           reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_BREAK         reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    TO              reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    OR              reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    AND             reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DO              reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    L_PAR           reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_INT         reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_STRING      reduce using rule 53 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)


state 296

    (83) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 303


state 297

    (86) nonconditionalF -> exp TO exp DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    statement                      shift and go to state 304
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 298

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    STRING          reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 299

    (87) bool -> OR exp empty .

    ID              reduce using rule 87 (bool -> OR exp empty .)
    RETURN          reduce using rule 87 (bool -> OR exp empty .)
    READ            reduce using rule 87 (bool -> OR exp empty .)
    WRITE           reduce using rule 87 (bool -> OR exp empty .)
    IF              reduce using rule 87 (bool -> OR exp empty .)
    VAR             reduce using rule 87 (bool -> OR exp empty .)
    WHILE           reduce using rule 87 (bool -> OR exp empty .)
    FROM            reduce using rule 87 (bool -> OR exp empty .)
    R_CURPAR        reduce using rule 87 (bool -> OR exp empty .)
    SEMICOLON       reduce using rule 87 (bool -> OR exp empty .)
    R_PAR           reduce using rule 87 (bool -> OR exp empty .)
    COMMA           reduce using rule 87 (bool -> OR exp empty .)
    R_BREAK         reduce using rule 87 (bool -> OR exp empty .)
    TO              reduce using rule 87 (bool -> OR exp empty .)
    DO              reduce using rule 87 (bool -> OR exp empty .)


state 300

    (88) bool -> AND exp empty .

    ID              reduce using rule 88 (bool -> AND exp empty .)
    RETURN          reduce using rule 88 (bool -> AND exp empty .)
    READ            reduce using rule 88 (bool -> AND exp empty .)
    WRITE           reduce using rule 88 (bool -> AND exp empty .)
    IF              reduce using rule 88 (bool -> AND exp empty .)
    VAR             reduce using rule 88 (bool -> AND exp empty .)
    WHILE           reduce using rule 88 (bool -> AND exp empty .)
    FROM            reduce using rule 88 (bool -> AND exp empty .)
    R_CURPAR        reduce using rule 88 (bool -> AND exp empty .)
    SEMICOLON       reduce using rule 88 (bool -> AND exp empty .)
    R_PAR           reduce using rule 88 (bool -> AND exp empty .)
    COMMA           reduce using rule 88 (bool -> AND exp empty .)
    R_BREAK         reduce using rule 88 (bool -> AND exp empty .)
    TO              reduce using rule 88 (bool -> AND exp empty .)
    DO              reduce using rule 88 (bool -> AND exp empty .)


state 301

    (51) void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)


state 302

    (73) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON . R_CURPAR ifF

    R_CURPAR        shift and go to state 305


state 303

    (83) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 306


state 304

    (86) nonconditionalF -> exp TO exp DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 307


state 305

    (73) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR . ifF
    (74) ifF -> . ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) ifF -> . empty
    (117) empty -> .

    ELSE            shift and go to state 309
    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    ifF                            shift and go to state 308
    empty                          shift and go to state 310

state 306

    (83) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 311

state 307

    (86) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 312


state 308

    (73) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .

    ID              reduce using rule 73 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    RETURN          reduce using rule 73 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    READ            reduce using rule 73 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WRITE           reduce using rule 73 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    IF              reduce using rule 73 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    VAR             reduce using rule 73 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WHILE           reduce using rule 73 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    FROM            reduce using rule 73 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    R_CURPAR        reduce using rule 73 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    SEMICOLON       reduce using rule 73 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)


state 309

    (74) ifF -> ELSE . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 313


state 310

    (75) ifF -> empty .

    ID              reduce using rule 75 (ifF -> empty .)
    RETURN          reduce using rule 75 (ifF -> empty .)
    READ            reduce using rule 75 (ifF -> empty .)
    WRITE           reduce using rule 75 (ifF -> empty .)
    IF              reduce using rule 75 (ifF -> empty .)
    VAR             reduce using rule 75 (ifF -> empty .)
    WHILE           reduce using rule 75 (ifF -> empty .)
    FROM            reduce using rule 75 (ifF -> empty .)
    R_CURPAR        reduce using rule 75 (ifF -> empty .)
    SEMICOLON       reduce using rule 75 (ifF -> empty .)


state 311

    (83) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 83 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 83 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 83 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 83 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 83 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 83 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 83 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 83 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 83 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 83 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 312

    (86) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 314

state 313

    (74) ifF -> ELSE L_CURPAR . statement SEMICOLON R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (76) assigment -> . var assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (58) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (63) read -> . READ L_PAR readF
    (66) write -> . WRITE L_PAR writeT
    (73) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (71) repeat -> . conditional empty
    (72) repeat -> . nonconditional empty
    (59) var -> . VAR varF
    (60) var -> . ID DOT VAR varF
    (83) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (84) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (85) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 84
    RETURN          shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    VAR             shift and go to state 91
    WHILE           shift and go to state 92
    FROM            shift and go to state 93

    statement                      shift and go to state 315
    assigment                      shift and go to state 76
    void                           shift and go to state 77
    return                         shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    if                             shift and go to state 81
    repeat                         shift and go to state 82
    var                            shift and go to state 83
    conditional                    shift and go to state 89
    nonconditional                 shift and go to state 90

state 314

    (86) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 86 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 86 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 86 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 86 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 86 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 86 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 86 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 86 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 86 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 86 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 315

    (74) ifF -> ELSE L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 316


state 316

    (74) ifF -> ELSE L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 317


state 317

    (74) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR . empty
    (117) empty -> .

    ID              reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    VAR             reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    FROM            reduce using rule 117 (empty -> .)
    R_CURPAR        reduce using rule 117 (empty -> .)
    SEMICOLON       reduce using rule 117 (empty -> .)

    empty                          shift and go to state 318

state 318

    (74) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 74 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 74 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 74 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 74 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 74 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 74 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 74 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 74 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 74 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 74 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 174 resolved as shift
WARNING: shift/reduce conflict for R_PAR in state 174 resolved as shift
