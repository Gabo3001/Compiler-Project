Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON programT
Rule 2     programT -> class programT
Rule 3     programT -> vars programF
Rule 4     programT -> programF
Rule 5     programF -> func programF
Rule 6     programF -> main empty
Rule 7     class -> CLASS ID classT
Rule 8     classT -> LESS INHERIT ID GREATER classF
Rule 9     classT -> classF
Rule 10    classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty
Rule 11    vars -> VARS dec empty
Rule 12    dec -> VAR arr decF
Rule 13    dec -> VAR decF
Rule 14    decF -> COMMA dec
Rule 15    decF -> COLON type SEMICOLON dec
Rule 16    decF -> COLON type SEMICOLON empty
Rule 17    type -> INT empty
Rule 18    type -> FLOAT empty
Rule 19    type -> CHAR empty
Rule 20    type -> ID empty
Rule 21    arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
Rule 22    arr -> L_BREAK CTE_INT R_BREAK empty
Rule 23    func -> typeFunc FUNCTION ID L_PAR funcF
Rule 24    funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 25    funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 26    typeFunc -> INT empty
Rule 27    typeFunc -> FLOAT empty
Rule 28    typeFunc -> CHAR empty
Rule 29    typeFunc -> ID empty
Rule 30    typeFunc -> VOID empty
Rule 31    parameter -> VAR COLON typepar SEMICOLON parameterF
Rule 32    parameterF -> parameter
Rule 33    parameterF -> empty
Rule 34    typepar -> INT empty
Rule 35    typepar -> FLOAT empty
Rule 36    typepar -> CHAR empty
Rule 37    typepar -> ID empty
Rule 38    main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
Rule 39    statement -> assigment statementF
Rule 40    statement -> void statementF
Rule 41    statement -> return statementF
Rule 42    statement -> read statementF
Rule 43    statement -> write statementF
Rule 44    statement -> if statementF
Rule 45    statement -> repeat statementF
Rule 46    statementF -> statement
Rule 47    statementF -> empty
Rule 48    void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty
Rule 49    void -> ID L_PAR param R_PAR SEMICOLON empty
Rule 50    arrfunc -> L_BREAK exp COMMA exp R_BREAK empty
Rule 51    arrfunc -> L_BREAK exp R_BREAK empty
Rule 52    param -> var paramF
Rule 53    paramF -> COMMA param
Rule 54    paramF -> empty
Rule 55    return -> RETURN L_PAR exp R_PAR SEMICOLON empty
Rule 56    var -> VAR varF
Rule 57    var -> ID DOT VAR varF
Rule 58    varF -> arrfunc empty
Rule 59    varF -> empty
Rule 60    read -> READ L_PAR readF
Rule 61    readF -> var COMMA readF
Rule 62    readF -> var R_PAR SEMICOLON empty
Rule 63    write -> WRITE L_PAR writeT
Rule 64    writeT -> CTE_CHAR writeF
Rule 65    writeT -> exp writeF
Rule 66    writeF -> COMMA writeT
Rule 67    writeF -> R_PAR SEMICOLON empty
Rule 68    repeat -> conditional empty
Rule 69    repeat -> nonconditional empty
Rule 70    if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
Rule 71    ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 72    ifF -> empty
Rule 73    assigment -> var assigmentF
Rule 74    assigmentF -> EQUAL exp empty
Rule 75    assigmentF -> ope exp empty
Rule 76    ope -> PLUS_EQ empty
Rule 77    ope -> MIN_EQ empty
Rule 78    ope -> MULT_EQ empty
Rule 79    ope -> DIV_EQ empty
Rule 80    conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 81    nonconditional -> FROM VAR arrfunc nonconditionalF
Rule 82    nonconditional -> FROM VAR nonconditionalF
Rule 83    nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 84    bool -> OR exp empty
Rule 85    bool -> AND exp empty
Rule 86    exp -> ex expT
Rule 87    expT -> LESS expf
Rule 88    expT -> GREATER expf
Rule 89    expT -> LESS_TH expf
Rule 90    expT -> GREAT_TH expf
Rule 91    expT -> SAME expf
Rule 92    expT -> DIF expf
Rule 93    expT -> empty
Rule 94    expf -> ex empty
Rule 95    expf -> ex bool empty
Rule 96    ex -> term exF
Rule 97    exF -> PLUS ex
Rule 98    exF -> MINUS ex
Rule 99    exF -> empty
Rule 100   term -> factor termF
Rule 101   termF -> MULT term
Rule 102   termF -> DIV term
Rule 103   termF -> empty
Rule 104   factor -> L_PAR exp R_PAR empty
Rule 105   factor -> factorT
Rule 106   factorT -> PLUS factorF
Rule 107   factorT -> MINUS factorF
Rule 108   factorT -> factorF
Rule 109   factorF -> varcte empty
Rule 110   varcte -> var empty
Rule 111   varcte -> CTE_INT empty
Rule 112   varcte -> CTE_FLOAT empty
Rule 113   varcte -> CTE_CHAR empty
Rule 114   empty -> <empty>

Terminals, with rules where they appear

AND                  : 85
ATTRIBUTES           : 10
CHAR                 : 19 28 36
CLASS                : 7
COLON                : 15 16 31
COMMA                : 14 21 50 53 61 66
CTE_CHAR             : 64 113
CTE_FLOAT            : 112
CTE_INT              : 21 21 22 111
DIF                  : 92
DIV                  : 102
DIV_EQ               : 79
DO                   : 80 83
DOT                  : 48 57
ELSE                 : 71
EQUAL                : 74
FLOAT                : 18 27 35
FROM                 : 81 82
FUNCTION             : 23
GREATER              : 8 88
GREAT_TH             : 90
ID                   : 1 7 8 20 23 29 37 48 48 49 57
IF                   : 70
INHERIT              : 8
INT                  : 17 26 34
LESS                 : 8 87
LESS_TH              : 89
L_BREAK              : 21 22 50 51
L_CURPAR             : 10 24 25 38 70 71 80 83
L_PAR                : 23 38 48 49 55 60 63 70 80 104
MAIN                 : 38
METHODS              : 10
MINUS                : 98 107
MIN_EQ               : 77
MULT                 : 101
MULT_EQ              : 78
OR                   : 84
PLUS                 : 97 106
PLUS_EQ              : 76
PROGRAM              : 1
READ                 : 60
RETURN               : 55
R_BREAK              : 21 22 50 51
R_CURPAR             : 10 24 25 38 70 71 80 83
R_PAR                : 24 25 38 48 49 55 62 67 70 80 104
SAME                 : 91
SEMICOLON            : 1 10 10 15 16 24 25 31 48 49 55 62 67 70 71 80 83
THEN                 : 70
TO                   : 83
VAR                  : 12 13 31 56 57 81 82
VARS                 : 11
VOID                 : 30
WHILE                : 80
WRITE                : 63
error                : 

Nonterminals, with rules where they appear

arr                  : 12
arrfunc              : 58 81
assigment            : 39
assigmentF           : 73
bool                 : 95
class                : 2
classF               : 8 9
classT               : 7
conditional          : 68
dec                  : 10 11 14 15 24 25
decF                 : 12 13
empty                : 6 10 11 16 17 18 19 20 21 22 24 25 26 27 28 29 30 33 34 35 36 37 38 47 48 49 50 51 54 55 58 59 62 67 68 69 71 72 74 75 76 77 78 79 80 83 84 85 93 94 95 99 103 104 109 110 111 112 113
ex                   : 86 94 95 97 98
exF                  : 96
exp                  : 50 50 51 55 65 70 74 75 80 83 83 84 85 104
expT                 : 86
expf                 : 87 88 89 90 91 92
factor               : 100
factorF              : 106 107 108
factorT              : 105
func                 : 5 10
funcF                : 23
if                   : 44
ifF                  : 70
main                 : 6
nonconditional       : 69
nonconditionalF      : 81 82
ope                  : 75
param                : 48 49 53
paramF               : 52
parameter            : 24 32
parameterF           : 31
program              : 0
programF             : 3 4 5
programT             : 1 2
read                 : 42
readF                : 60 61
repeat               : 45
return               : 41
statement            : 24 25 38 46 70 71 80 83
statementF           : 39 40 41 42 43 44 45
term                 : 96 101 102
termF                : 100
type                 : 15 16
typeFunc             : 23
typepar              : 31
var                  : 52 61 62 73 110
varF                 : 56 57
varcte               : 109
vars                 : 3
void                 : 40
write                : 43
writeF               : 64 65
writeT               : 63 66

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON programT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON programT

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    CLASS           shift and go to state 10
    VARS            shift and go to state 11
    MAIN            shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    ID              shift and go to state 5
    VOID            shift and go to state 19

    programT                       shift and go to state 6
    class                          shift and go to state 7
    vars                           shift and go to state 8
    programF                       shift and go to state 9
    func                           shift and go to state 12
    main                           shift and go to state 13
    typeFunc                       shift and go to state 14

state 5

    (29) typeFunc -> ID . empty
    (114) empty -> .

    FUNCTION        reduce using rule 114 (empty -> .)

    empty                          shift and go to state 20

state 6

    (1) program -> PROGRAM ID SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON programT .)


state 7

    (2) programT -> class . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    CLASS           shift and go to state 10
    VARS            shift and go to state 11
    MAIN            shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    ID              shift and go to state 5
    VOID            shift and go to state 19

    class                          shift and go to state 7
    programT                       shift and go to state 21
    vars                           shift and go to state 8
    programF                       shift and go to state 9
    func                           shift and go to state 12
    main                           shift and go to state 13
    typeFunc                       shift and go to state 14

state 8

    (3) programT -> vars . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    MAIN            shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    ID              shift and go to state 5
    VOID            shift and go to state 19

    programF                       shift and go to state 22
    func                           shift and go to state 12
    main                           shift and go to state 13
    typeFunc                       shift and go to state 14

state 9

    (4) programT -> programF .

    $end            reduce using rule 4 (programT -> programF .)


state 10

    (7) class -> CLASS . ID classT

    ID              shift and go to state 23


state 11

    (11) vars -> VARS . dec empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 25

    dec                            shift and go to state 24

state 12

    (5) programF -> func . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    MAIN            shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    ID              shift and go to state 5
    VOID            shift and go to state 19

    func                           shift and go to state 12
    programF                       shift and go to state 26
    main                           shift and go to state 13
    typeFunc                       shift and go to state 14

state 13

    (6) programF -> main . empty
    (114) empty -> .

    $end            reduce using rule 114 (empty -> .)

    empty                          shift and go to state 27

state 14

    (23) func -> typeFunc . FUNCTION ID L_PAR funcF

    FUNCTION        shift and go to state 28


state 15

    (38) main -> MAIN . L_PAR R_PAR L_CURPAR statement R_CURPAR empty

    L_PAR           shift and go to state 29


state 16

    (26) typeFunc -> INT . empty
    (114) empty -> .

    FUNCTION        reduce using rule 114 (empty -> .)

    empty                          shift and go to state 30

state 17

    (27) typeFunc -> FLOAT . empty
    (114) empty -> .

    FUNCTION        reduce using rule 114 (empty -> .)

    empty                          shift and go to state 31

state 18

    (28) typeFunc -> CHAR . empty
    (114) empty -> .

    FUNCTION        reduce using rule 114 (empty -> .)

    empty                          shift and go to state 32

state 19

    (30) typeFunc -> VOID . empty
    (114) empty -> .

    FUNCTION        reduce using rule 114 (empty -> .)

    empty                          shift and go to state 33

state 20

    (29) typeFunc -> ID empty .

    FUNCTION        reduce using rule 29 (typeFunc -> ID empty .)


state 21

    (2) programT -> class programT .

    $end            reduce using rule 2 (programT -> class programT .)


state 22

    (3) programT -> vars programF .

    $end            reduce using rule 3 (programT -> vars programF .)


state 23

    (7) class -> CLASS ID . classT
    (8) classT -> . LESS INHERIT ID GREATER classF
    (9) classT -> . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    LESS            shift and go to state 35
    SEMICOLON       shift and go to state 37

    classT                         shift and go to state 34
    classF                         shift and go to state 36

state 24

    (11) vars -> VARS dec . empty
    (114) empty -> .

    MAIN            reduce using rule 114 (empty -> .)
    INT             reduce using rule 114 (empty -> .)
    FLOAT           reduce using rule 114 (empty -> .)
    CHAR            reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    VOID            reduce using rule 114 (empty -> .)

    empty                          shift and go to state 38

state 25

    (12) dec -> VAR . arr decF
    (13) dec -> VAR . decF
    (21) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (22) arr -> . L_BREAK CTE_INT R_BREAK empty
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type SEMICOLON dec
    (16) decF -> . COLON type SEMICOLON empty

    L_BREAK         shift and go to state 41
    COMMA           shift and go to state 42
    COLON           shift and go to state 43

    arr                            shift and go to state 39
    decF                           shift and go to state 40

state 26

    (5) programF -> func programF .

    $end            reduce using rule 5 (programF -> func programF .)


state 27

    (6) programF -> main empty .

    $end            reduce using rule 6 (programF -> main empty .)


state 28

    (23) func -> typeFunc FUNCTION . ID L_PAR funcF

    ID              shift and go to state 44


state 29

    (38) main -> MAIN L_PAR . R_PAR L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 45


state 30

    (26) typeFunc -> INT empty .

    FUNCTION        reduce using rule 26 (typeFunc -> INT empty .)


state 31

    (27) typeFunc -> FLOAT empty .

    FUNCTION        reduce using rule 27 (typeFunc -> FLOAT empty .)


state 32

    (28) typeFunc -> CHAR empty .

    FUNCTION        reduce using rule 28 (typeFunc -> CHAR empty .)


state 33

    (30) typeFunc -> VOID empty .

    FUNCTION        reduce using rule 30 (typeFunc -> VOID empty .)


state 34

    (7) class -> CLASS ID classT .

    CLASS           reduce using rule 7 (class -> CLASS ID classT .)
    VARS            reduce using rule 7 (class -> CLASS ID classT .)
    MAIN            reduce using rule 7 (class -> CLASS ID classT .)
    INT             reduce using rule 7 (class -> CLASS ID classT .)
    FLOAT           reduce using rule 7 (class -> CLASS ID classT .)
    CHAR            reduce using rule 7 (class -> CLASS ID classT .)
    ID              reduce using rule 7 (class -> CLASS ID classT .)
    VOID            reduce using rule 7 (class -> CLASS ID classT .)


state 35

    (8) classT -> LESS . INHERIT ID GREATER classF

    INHERIT         shift and go to state 46


state 36

    (9) classT -> classF .

    CLASS           reduce using rule 9 (classT -> classF .)
    VARS            reduce using rule 9 (classT -> classF .)
    MAIN            reduce using rule 9 (classT -> classF .)
    INT             reduce using rule 9 (classT -> classF .)
    FLOAT           reduce using rule 9 (classT -> classF .)
    CHAR            reduce using rule 9 (classT -> classF .)
    ID              reduce using rule 9 (classT -> classF .)
    VOID            reduce using rule 9 (classT -> classF .)


state 37

    (10) classF -> SEMICOLON . L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    L_CURPAR        shift and go to state 47


state 38

    (11) vars -> VARS dec empty .

    MAIN            reduce using rule 11 (vars -> VARS dec empty .)
    INT             reduce using rule 11 (vars -> VARS dec empty .)
    FLOAT           reduce using rule 11 (vars -> VARS dec empty .)
    CHAR            reduce using rule 11 (vars -> VARS dec empty .)
    ID              reduce using rule 11 (vars -> VARS dec empty .)
    VOID            reduce using rule 11 (vars -> VARS dec empty .)


state 39

    (12) dec -> VAR arr . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type SEMICOLON dec
    (16) decF -> . COLON type SEMICOLON empty

    COMMA           shift and go to state 42
    COLON           shift and go to state 43

    decF                           shift and go to state 48

state 40

    (13) dec -> VAR decF .

    MAIN            reduce using rule 13 (dec -> VAR decF .)
    INT             reduce using rule 13 (dec -> VAR decF .)
    FLOAT           reduce using rule 13 (dec -> VAR decF .)
    CHAR            reduce using rule 13 (dec -> VAR decF .)
    ID              reduce using rule 13 (dec -> VAR decF .)
    VOID            reduce using rule 13 (dec -> VAR decF .)
    METHODS         reduce using rule 13 (dec -> VAR decF .)
    L_CURPAR        reduce using rule 13 (dec -> VAR decF .)


state 41

    (21) arr -> L_BREAK . CTE_INT COMMA CTE_INT R_BREAK empty
    (22) arr -> L_BREAK . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 49


state 42

    (14) decF -> COMMA . dec
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 25

    dec                            shift and go to state 50

state 43

    (15) decF -> COLON . type SEMICOLON dec
    (16) decF -> COLON . type SEMICOLON empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . ID empty

    INT             shift and go to state 52
    FLOAT           shift and go to state 53
    CHAR            shift and go to state 54
    ID              shift and go to state 55

    type                           shift and go to state 51

state 44

    (23) func -> typeFunc FUNCTION ID . L_PAR funcF

    L_PAR           shift and go to state 56


state 45

    (38) main -> MAIN L_PAR R_PAR . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 57


state 46

    (8) classT -> LESS INHERIT . ID GREATER classF

    ID              shift and go to state 58


state 47

    (10) classF -> SEMICOLON L_CURPAR . ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    ATTRIBUTES      shift and go to state 59


state 48

    (12) dec -> VAR arr decF .

    MAIN            reduce using rule 12 (dec -> VAR arr decF .)
    INT             reduce using rule 12 (dec -> VAR arr decF .)
    FLOAT           reduce using rule 12 (dec -> VAR arr decF .)
    CHAR            reduce using rule 12 (dec -> VAR arr decF .)
    ID              reduce using rule 12 (dec -> VAR arr decF .)
    VOID            reduce using rule 12 (dec -> VAR arr decF .)
    METHODS         reduce using rule 12 (dec -> VAR arr decF .)
    L_CURPAR        reduce using rule 12 (dec -> VAR arr decF .)


state 49

    (21) arr -> L_BREAK CTE_INT . COMMA CTE_INT R_BREAK empty
    (22) arr -> L_BREAK CTE_INT . R_BREAK empty

    COMMA           shift and go to state 60
    R_BREAK         shift and go to state 61


state 50

    (14) decF -> COMMA dec .

    MAIN            reduce using rule 14 (decF -> COMMA dec .)
    INT             reduce using rule 14 (decF -> COMMA dec .)
    FLOAT           reduce using rule 14 (decF -> COMMA dec .)
    CHAR            reduce using rule 14 (decF -> COMMA dec .)
    ID              reduce using rule 14 (decF -> COMMA dec .)
    VOID            reduce using rule 14 (decF -> COMMA dec .)
    METHODS         reduce using rule 14 (decF -> COMMA dec .)
    L_CURPAR        reduce using rule 14 (decF -> COMMA dec .)


state 51

    (15) decF -> COLON type . SEMICOLON dec
    (16) decF -> COLON type . SEMICOLON empty

    SEMICOLON       shift and go to state 62


state 52

    (17) type -> INT . empty
    (114) empty -> .

    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 63

state 53

    (18) type -> FLOAT . empty
    (114) empty -> .

    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 64

state 54

    (19) type -> CHAR . empty
    (114) empty -> .

    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 65

state 55

    (20) type -> ID . empty
    (114) empty -> .

    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 66

state 56

    (23) func -> typeFunc FUNCTION ID L_PAR . funcF
    (24) funcF -> . parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (25) funcF -> . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (31) parameter -> . VAR COLON typepar SEMICOLON parameterF

    R_PAR           shift and go to state 69
    VAR             shift and go to state 70

    funcF                          shift and go to state 67
    parameter                      shift and go to state 68

state 57

    (38) main -> MAIN L_PAR R_PAR L_CURPAR . statement R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    statement                      shift and go to state 71
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 58

    (8) classT -> LESS INHERIT ID . GREATER classF

    GREATER         shift and go to state 90


state 59

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES . dec METHODS func R_CURPAR SEMICOLON empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 25

    dec                            shift and go to state 91

state 60

    (21) arr -> L_BREAK CTE_INT COMMA . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 92


state 61

    (22) arr -> L_BREAK CTE_INT R_BREAK . empty
    (114) empty -> .

    COMMA           reduce using rule 114 (empty -> .)
    COLON           reduce using rule 114 (empty -> .)

    empty                          shift and go to state 93

state 62

    (15) decF -> COLON type SEMICOLON . dec
    (16) decF -> COLON type SEMICOLON . empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF
    (114) empty -> .

    VAR             shift and go to state 25
    MAIN            reduce using rule 114 (empty -> .)
    INT             reduce using rule 114 (empty -> .)
    FLOAT           reduce using rule 114 (empty -> .)
    CHAR            reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    VOID            reduce using rule 114 (empty -> .)
    METHODS         reduce using rule 114 (empty -> .)
    L_CURPAR        reduce using rule 114 (empty -> .)

    dec                            shift and go to state 94
    empty                          shift and go to state 95

state 63

    (17) type -> INT empty .

    SEMICOLON       reduce using rule 17 (type -> INT empty .)


state 64

    (18) type -> FLOAT empty .

    SEMICOLON       reduce using rule 18 (type -> FLOAT empty .)


state 65

    (19) type -> CHAR empty .

    SEMICOLON       reduce using rule 19 (type -> CHAR empty .)


state 66

    (20) type -> ID empty .

    SEMICOLON       reduce using rule 20 (type -> ID empty .)


state 67

    (23) func -> typeFunc FUNCTION ID L_PAR funcF .

    MAIN            reduce using rule 23 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    INT             reduce using rule 23 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    FLOAT           reduce using rule 23 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    CHAR            reduce using rule 23 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    ID              reduce using rule 23 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    VOID            reduce using rule 23 (func -> typeFunc FUNCTION ID L_PAR funcF .)
    R_CURPAR        reduce using rule 23 (func -> typeFunc FUNCTION ID L_PAR funcF .)


state 68

    (24) funcF -> parameter . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 96


state 69

    (25) funcF -> R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 97


state 70

    (31) parameter -> VAR . COLON typepar SEMICOLON parameterF

    COLON           shift and go to state 98


state 71

    (38) main -> MAIN L_PAR R_PAR L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 99


state 72

    (39) statement -> assigment . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (114) empty -> .
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    assigment                      shift and go to state 72
    statementF                     shift and go to state 100
    statement                      shift and go to state 101
    empty                          shift and go to state 102
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 73

    (40) statement -> void . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (114) empty -> .
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    void                           shift and go to state 73
    statementF                     shift and go to state 103
    statement                      shift and go to state 101
    empty                          shift and go to state 102
    assigment                      shift and go to state 72
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 74

    (41) statement -> return . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (114) empty -> .
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    return                         shift and go to state 74
    statementF                     shift and go to state 104
    statement                      shift and go to state 101
    empty                          shift and go to state 102
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 75

    (42) statement -> read . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (114) empty -> .
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    read                           shift and go to state 75
    statementF                     shift and go to state 105
    statement                      shift and go to state 101
    empty                          shift and go to state 102
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 76

    (43) statement -> write . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (114) empty -> .
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    write                          shift and go to state 76
    statementF                     shift and go to state 106
    statement                      shift and go to state 101
    empty                          shift and go to state 102
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 77

    (44) statement -> if . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (114) empty -> .
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    if                             shift and go to state 77
    statementF                     shift and go to state 107
    statement                      shift and go to state 101
    empty                          shift and go to state 102
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 78

    (45) statement -> repeat . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (114) empty -> .
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    repeat                         shift and go to state 78
    statementF                     shift and go to state 108
    statement                      shift and go to state 101
    empty                          shift and go to state 102
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 79

    (73) assigment -> var . assigmentF
    (74) assigmentF -> . EQUAL exp empty
    (75) assigmentF -> . ope exp empty
    (76) ope -> . PLUS_EQ empty
    (77) ope -> . MIN_EQ empty
    (78) ope -> . MULT_EQ empty
    (79) ope -> . DIV_EQ empty

    EQUAL           shift and go to state 110
    PLUS_EQ         shift and go to state 112
    MIN_EQ          shift and go to state 113
    MULT_EQ         shift and go to state 114
    DIV_EQ          shift and go to state 115

    assigmentF                     shift and go to state 109
    ope                            shift and go to state 111

state 80

    (48) void -> ID . DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> ID . L_PAR param R_PAR SEMICOLON empty
    (57) var -> ID . DOT VAR varF

    DOT             shift and go to state 116
    L_PAR           shift and go to state 117


state 81

    (55) return -> RETURN . L_PAR exp R_PAR SEMICOLON empty

    L_PAR           shift and go to state 118


state 82

    (60) read -> READ . L_PAR readF

    L_PAR           shift and go to state 119


state 83

    (63) write -> WRITE . L_PAR writeT

    L_PAR           shift and go to state 120


state 84

    (70) if -> IF . L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_PAR           shift and go to state 121


state 85

    (68) repeat -> conditional . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 122

state 86

    (69) repeat -> nonconditional . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 123

state 87

    (56) var -> VAR . varF
    (58) varF -> . arrfunc empty
    (59) varF -> . empty
    (50) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (51) arrfunc -> . L_BREAK exp R_BREAK empty
    (114) empty -> .

    L_BREAK         shift and go to state 127
    EQUAL           reduce using rule 114 (empty -> .)
    PLUS_EQ         reduce using rule 114 (empty -> .)
    MIN_EQ          reduce using rule 114 (empty -> .)
    MULT_EQ         reduce using rule 114 (empty -> .)
    DIV_EQ          reduce using rule 114 (empty -> .)
    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    varF                           shift and go to state 124
    arrfunc                        shift and go to state 125
    empty                          shift and go to state 126

state 88

    (80) conditional -> WHILE . L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    L_PAR           shift and go to state 128


state 89

    (81) nonconditional -> FROM . VAR arrfunc nonconditionalF
    (82) nonconditional -> FROM . VAR nonconditionalF

    VAR             shift and go to state 129


state 90

    (8) classT -> LESS INHERIT ID GREATER . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    SEMICOLON       shift and go to state 37

    classF                         shift and go to state 130

state 91

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec . METHODS func R_CURPAR SEMICOLON empty

    METHODS         shift and go to state 131


state 92

    (21) arr -> L_BREAK CTE_INT COMMA CTE_INT . R_BREAK empty

    R_BREAK         shift and go to state 132


state 93

    (22) arr -> L_BREAK CTE_INT R_BREAK empty .

    COMMA           reduce using rule 22 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    COLON           reduce using rule 22 (arr -> L_BREAK CTE_INT R_BREAK empty .)


state 94

    (15) decF -> COLON type SEMICOLON dec .

    MAIN            reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    INT             reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    FLOAT           reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    CHAR            reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    ID              reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    VOID            reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    METHODS         reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    L_CURPAR        reduce using rule 15 (decF -> COLON type SEMICOLON dec .)


state 95

    (16) decF -> COLON type SEMICOLON empty .

    MAIN            reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    INT             reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    FLOAT           reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    CHAR            reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    ID              reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    VOID            reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    METHODS         reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    L_CURPAR        reduce using rule 16 (decF -> COLON type SEMICOLON empty .)


state 96

    (24) funcF -> parameter R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 133


state 97

    (25) funcF -> R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 25

    dec                            shift and go to state 134

state 98

    (31) parameter -> VAR COLON . typepar SEMICOLON parameterF
    (34) typepar -> . INT empty
    (35) typepar -> . FLOAT empty
    (36) typepar -> . CHAR empty
    (37) typepar -> . ID empty

    INT             shift and go to state 136
    FLOAT           shift and go to state 137
    CHAR            shift and go to state 138
    ID              shift and go to state 139

    typepar                        shift and go to state 135

state 99

    (38) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR . empty
    (114) empty -> .

    $end            reduce using rule 114 (empty -> .)

    empty                          shift and go to state 140

state 100

    (39) statement -> assigment statementF .

    R_CURPAR        reduce using rule 39 (statement -> assigment statementF .)
    SEMICOLON       reduce using rule 39 (statement -> assigment statementF .)


state 101

    (46) statementF -> statement .

    R_CURPAR        reduce using rule 46 (statementF -> statement .)
    SEMICOLON       reduce using rule 46 (statementF -> statement .)


state 102

    (47) statementF -> empty .

    R_CURPAR        reduce using rule 47 (statementF -> empty .)
    SEMICOLON       reduce using rule 47 (statementF -> empty .)


state 103

    (40) statement -> void statementF .

    R_CURPAR        reduce using rule 40 (statement -> void statementF .)
    SEMICOLON       reduce using rule 40 (statement -> void statementF .)


state 104

    (41) statement -> return statementF .

    R_CURPAR        reduce using rule 41 (statement -> return statementF .)
    SEMICOLON       reduce using rule 41 (statement -> return statementF .)


state 105

    (42) statement -> read statementF .

    R_CURPAR        reduce using rule 42 (statement -> read statementF .)
    SEMICOLON       reduce using rule 42 (statement -> read statementF .)


state 106

    (43) statement -> write statementF .

    R_CURPAR        reduce using rule 43 (statement -> write statementF .)
    SEMICOLON       reduce using rule 43 (statement -> write statementF .)


state 107

    (44) statement -> if statementF .

    R_CURPAR        reduce using rule 44 (statement -> if statementF .)
    SEMICOLON       reduce using rule 44 (statement -> if statementF .)


state 108

    (45) statement -> repeat statementF .

    R_CURPAR        reduce using rule 45 (statement -> repeat statementF .)
    SEMICOLON       reduce using rule 45 (statement -> repeat statementF .)


state 109

    (73) assigment -> var assigmentF .

    ID              reduce using rule 73 (assigment -> var assigmentF .)
    RETURN          reduce using rule 73 (assigment -> var assigmentF .)
    READ            reduce using rule 73 (assigment -> var assigmentF .)
    WRITE           reduce using rule 73 (assigment -> var assigmentF .)
    IF              reduce using rule 73 (assigment -> var assigmentF .)
    VAR             reduce using rule 73 (assigment -> var assigmentF .)
    WHILE           reduce using rule 73 (assigment -> var assigmentF .)
    FROM            reduce using rule 73 (assigment -> var assigmentF .)
    R_CURPAR        reduce using rule 73 (assigment -> var assigmentF .)
    SEMICOLON       reduce using rule 73 (assigment -> var assigmentF .)


state 110

    (74) assigmentF -> EQUAL . exp empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 141
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 111

    (75) assigmentF -> ope . exp empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 156
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 112

    (76) ope -> PLUS_EQ . empty
    (114) empty -> .

    L_PAR           reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    CTE_INT         reduce using rule 114 (empty -> .)
    CTE_FLOAT       reduce using rule 114 (empty -> .)
    CTE_CHAR        reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 157

state 113

    (77) ope -> MIN_EQ . empty
    (114) empty -> .

    L_PAR           reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    CTE_INT         reduce using rule 114 (empty -> .)
    CTE_FLOAT       reduce using rule 114 (empty -> .)
    CTE_CHAR        reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 158

state 114

    (78) ope -> MULT_EQ . empty
    (114) empty -> .

    L_PAR           reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    CTE_INT         reduce using rule 114 (empty -> .)
    CTE_FLOAT       reduce using rule 114 (empty -> .)
    CTE_CHAR        reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 159

state 115

    (79) ope -> DIV_EQ . empty
    (114) empty -> .

    L_PAR           reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    CTE_INT         reduce using rule 114 (empty -> .)
    CTE_FLOAT       reduce using rule 114 (empty -> .)
    CTE_CHAR        reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 160

state 116

    (48) void -> ID DOT . ID L_PAR param R_PAR SEMICOLON empty
    (57) var -> ID DOT . VAR varF

    ID              shift and go to state 161
    VAR             shift and go to state 162


state 117

    (49) void -> ID L_PAR . param R_PAR SEMICOLON empty
    (52) param -> . var paramF
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    VAR             shift and go to state 87
    ID              shift and go to state 155

    param                          shift and go to state 163
    var                            shift and go to state 164

state 118

    (55) return -> RETURN L_PAR . exp R_PAR SEMICOLON empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 165
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 119

    (60) read -> READ L_PAR . readF
    (61) readF -> . var COMMA readF
    (62) readF -> . var R_PAR SEMICOLON empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    VAR             shift and go to state 87
    ID              shift and go to state 155

    readF                          shift and go to state 166
    var                            shift and go to state 167

state 120

    (63) write -> WRITE L_PAR . writeT
    (64) writeT -> . CTE_CHAR writeF
    (65) writeT -> . exp writeF
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    CTE_CHAR        shift and go to state 169
    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    VAR             shift and go to state 87
    ID              shift and go to state 155

    writeT                         shift and go to state 168
    exp                            shift and go to state 170
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 121

    (70) if -> IF L_PAR . exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 171
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 122

    (68) repeat -> conditional empty .

    ID              reduce using rule 68 (repeat -> conditional empty .)
    RETURN          reduce using rule 68 (repeat -> conditional empty .)
    READ            reduce using rule 68 (repeat -> conditional empty .)
    WRITE           reduce using rule 68 (repeat -> conditional empty .)
    IF              reduce using rule 68 (repeat -> conditional empty .)
    VAR             reduce using rule 68 (repeat -> conditional empty .)
    WHILE           reduce using rule 68 (repeat -> conditional empty .)
    FROM            reduce using rule 68 (repeat -> conditional empty .)
    R_CURPAR        reduce using rule 68 (repeat -> conditional empty .)
    SEMICOLON       reduce using rule 68 (repeat -> conditional empty .)


state 123

    (69) repeat -> nonconditional empty .

    ID              reduce using rule 69 (repeat -> nonconditional empty .)
    RETURN          reduce using rule 69 (repeat -> nonconditional empty .)
    READ            reduce using rule 69 (repeat -> nonconditional empty .)
    WRITE           reduce using rule 69 (repeat -> nonconditional empty .)
    IF              reduce using rule 69 (repeat -> nonconditional empty .)
    VAR             reduce using rule 69 (repeat -> nonconditional empty .)
    WHILE           reduce using rule 69 (repeat -> nonconditional empty .)
    FROM            reduce using rule 69 (repeat -> nonconditional empty .)
    R_CURPAR        reduce using rule 69 (repeat -> nonconditional empty .)
    SEMICOLON       reduce using rule 69 (repeat -> nonconditional empty .)


state 124

    (56) var -> VAR varF .

    EQUAL           reduce using rule 56 (var -> VAR varF .)
    PLUS_EQ         reduce using rule 56 (var -> VAR varF .)
    MIN_EQ          reduce using rule 56 (var -> VAR varF .)
    MULT_EQ         reduce using rule 56 (var -> VAR varF .)
    DIV_EQ          reduce using rule 56 (var -> VAR varF .)
    MULT            reduce using rule 56 (var -> VAR varF .)
    DIV             reduce using rule 56 (var -> VAR varF .)
    PLUS            reduce using rule 56 (var -> VAR varF .)
    MINUS           reduce using rule 56 (var -> VAR varF .)
    LESS            reduce using rule 56 (var -> VAR varF .)
    GREATER         reduce using rule 56 (var -> VAR varF .)
    LESS_TH         reduce using rule 56 (var -> VAR varF .)
    GREAT_TH        reduce using rule 56 (var -> VAR varF .)
    SAME            reduce using rule 56 (var -> VAR varF .)
    DIF             reduce using rule 56 (var -> VAR varF .)
    ID              reduce using rule 56 (var -> VAR varF .)
    RETURN          reduce using rule 56 (var -> VAR varF .)
    READ            reduce using rule 56 (var -> VAR varF .)
    WRITE           reduce using rule 56 (var -> VAR varF .)
    IF              reduce using rule 56 (var -> VAR varF .)
    VAR             reduce using rule 56 (var -> VAR varF .)
    WHILE           reduce using rule 56 (var -> VAR varF .)
    FROM            reduce using rule 56 (var -> VAR varF .)
    R_CURPAR        reduce using rule 56 (var -> VAR varF .)
    SEMICOLON       reduce using rule 56 (var -> VAR varF .)
    COMMA           reduce using rule 56 (var -> VAR varF .)
    R_PAR           reduce using rule 56 (var -> VAR varF .)
    R_BREAK         reduce using rule 56 (var -> VAR varF .)
    TO              reduce using rule 56 (var -> VAR varF .)
    OR              reduce using rule 56 (var -> VAR varF .)
    AND             reduce using rule 56 (var -> VAR varF .)
    DO              reduce using rule 56 (var -> VAR varF .)


state 125

    (58) varF -> arrfunc . empty
    (114) empty -> .

    EQUAL           reduce using rule 114 (empty -> .)
    PLUS_EQ         reduce using rule 114 (empty -> .)
    MIN_EQ          reduce using rule 114 (empty -> .)
    MULT_EQ         reduce using rule 114 (empty -> .)
    DIV_EQ          reduce using rule 114 (empty -> .)
    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 172

state 126

    (59) varF -> empty .

    EQUAL           reduce using rule 59 (varF -> empty .)
    PLUS_EQ         reduce using rule 59 (varF -> empty .)
    MIN_EQ          reduce using rule 59 (varF -> empty .)
    MULT_EQ         reduce using rule 59 (varF -> empty .)
    DIV_EQ          reduce using rule 59 (varF -> empty .)
    MULT            reduce using rule 59 (varF -> empty .)
    DIV             reduce using rule 59 (varF -> empty .)
    PLUS            reduce using rule 59 (varF -> empty .)
    MINUS           reduce using rule 59 (varF -> empty .)
    LESS            reduce using rule 59 (varF -> empty .)
    GREATER         reduce using rule 59 (varF -> empty .)
    LESS_TH         reduce using rule 59 (varF -> empty .)
    GREAT_TH        reduce using rule 59 (varF -> empty .)
    SAME            reduce using rule 59 (varF -> empty .)
    DIF             reduce using rule 59 (varF -> empty .)
    ID              reduce using rule 59 (varF -> empty .)
    RETURN          reduce using rule 59 (varF -> empty .)
    READ            reduce using rule 59 (varF -> empty .)
    WRITE           reduce using rule 59 (varF -> empty .)
    IF              reduce using rule 59 (varF -> empty .)
    VAR             reduce using rule 59 (varF -> empty .)
    WHILE           reduce using rule 59 (varF -> empty .)
    FROM            reduce using rule 59 (varF -> empty .)
    R_CURPAR        reduce using rule 59 (varF -> empty .)
    SEMICOLON       reduce using rule 59 (varF -> empty .)
    COMMA           reduce using rule 59 (varF -> empty .)
    R_PAR           reduce using rule 59 (varF -> empty .)
    R_BREAK         reduce using rule 59 (varF -> empty .)
    TO              reduce using rule 59 (varF -> empty .)
    OR              reduce using rule 59 (varF -> empty .)
    AND             reduce using rule 59 (varF -> empty .)
    DO              reduce using rule 59 (varF -> empty .)


state 127

    (50) arrfunc -> L_BREAK . exp COMMA exp R_BREAK empty
    (51) arrfunc -> L_BREAK . exp R_BREAK empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 173
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 128

    (80) conditional -> WHILE L_PAR . exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 174
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 129

    (81) nonconditional -> FROM VAR . arrfunc nonconditionalF
    (82) nonconditional -> FROM VAR . nonconditionalF
    (50) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (51) arrfunc -> . L_BREAK exp R_BREAK empty
    (83) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_BREAK         shift and go to state 127
    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    arrfunc                        shift and go to state 175
    nonconditionalF                shift and go to state 176
    exp                            shift and go to state 177
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 130

    (8) classT -> LESS INHERIT ID GREATER classF .

    CLASS           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VARS            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    MAIN            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    INT             reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    FLOAT           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    CHAR            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    ID              reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VOID            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)


state 131

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS . func R_CURPAR SEMICOLON empty
    (23) func -> . typeFunc FUNCTION ID L_PAR funcF
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    ID              shift and go to state 5
    VOID            shift and go to state 19

    func                           shift and go to state 178
    typeFunc                       shift and go to state 14

state 132

    (21) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK . empty
    (114) empty -> .

    COMMA           reduce using rule 114 (empty -> .)
    COLON           reduce using rule 114 (empty -> .)

    empty                          shift and go to state 179

state 133

    (24) funcF -> parameter R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 25

    dec                            shift and go to state 180

state 134

    (25) funcF -> R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 181


state 135

    (31) parameter -> VAR COLON typepar . SEMICOLON parameterF

    SEMICOLON       shift and go to state 182


state 136

    (34) typepar -> INT . empty
    (114) empty -> .

    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 183

state 137

    (35) typepar -> FLOAT . empty
    (114) empty -> .

    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 184

state 138

    (36) typepar -> CHAR . empty
    (114) empty -> .

    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 185

state 139

    (37) typepar -> ID . empty
    (114) empty -> .

    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 186

state 140

    (38) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .

    $end            reduce using rule 38 (main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .)


state 141

    (74) assigmentF -> EQUAL exp . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 187

state 142

    (86) exp -> ex . expT
    (87) expT -> . LESS expf
    (88) expT -> . GREATER expf
    (89) expT -> . LESS_TH expf
    (90) expT -> . GREAT_TH expf
    (91) expT -> . SAME expf
    (92) expT -> . DIF expf
    (93) expT -> . empty
    (114) empty -> .

    LESS            shift and go to state 189
    GREATER         shift and go to state 190
    LESS_TH         shift and go to state 191
    GREAT_TH        shift and go to state 192
    SAME            shift and go to state 193
    DIF             shift and go to state 194
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    expT                           shift and go to state 188
    empty                          shift and go to state 195

state 143

    (96) ex -> term . exF
    (97) exF -> . PLUS ex
    (98) exF -> . MINUS ex
    (99) exF -> . empty
    (114) empty -> .

    PLUS            shift and go to state 197
    MINUS           shift and go to state 198
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    exF                            shift and go to state 196
    empty                          shift and go to state 199

state 144

    (100) term -> factor . termF
    (101) termF -> . MULT term
    (102) termF -> . DIV term
    (103) termF -> . empty
    (114) empty -> .

    MULT            shift and go to state 201
    DIV             shift and go to state 202
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    termF                          shift and go to state 200
    empty                          shift and go to state 203

state 145

    (104) factor -> L_PAR . exp R_PAR empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 204
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 146

    (105) factor -> factorT .

    MULT            reduce using rule 105 (factor -> factorT .)
    DIV             reduce using rule 105 (factor -> factorT .)
    PLUS            reduce using rule 105 (factor -> factorT .)
    MINUS           reduce using rule 105 (factor -> factorT .)
    LESS            reduce using rule 105 (factor -> factorT .)
    GREATER         reduce using rule 105 (factor -> factorT .)
    LESS_TH         reduce using rule 105 (factor -> factorT .)
    GREAT_TH        reduce using rule 105 (factor -> factorT .)
    SAME            reduce using rule 105 (factor -> factorT .)
    DIF             reduce using rule 105 (factor -> factorT .)
    ID              reduce using rule 105 (factor -> factorT .)
    RETURN          reduce using rule 105 (factor -> factorT .)
    READ            reduce using rule 105 (factor -> factorT .)
    WRITE           reduce using rule 105 (factor -> factorT .)
    IF              reduce using rule 105 (factor -> factorT .)
    VAR             reduce using rule 105 (factor -> factorT .)
    WHILE           reduce using rule 105 (factor -> factorT .)
    FROM            reduce using rule 105 (factor -> factorT .)
    R_CURPAR        reduce using rule 105 (factor -> factorT .)
    SEMICOLON       reduce using rule 105 (factor -> factorT .)
    R_PAR           reduce using rule 105 (factor -> factorT .)
    COMMA           reduce using rule 105 (factor -> factorT .)
    R_BREAK         reduce using rule 105 (factor -> factorT .)
    TO              reduce using rule 105 (factor -> factorT .)
    OR              reduce using rule 105 (factor -> factorT .)
    AND             reduce using rule 105 (factor -> factorT .)
    DO              reduce using rule 105 (factor -> factorT .)


state 147

    (106) factorT -> PLUS . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    factorF                        shift and go to state 205
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 148

    (108) factorT -> factorF .

    MULT            reduce using rule 108 (factorT -> factorF .)
    DIV             reduce using rule 108 (factorT -> factorF .)
    PLUS            reduce using rule 108 (factorT -> factorF .)
    MINUS           reduce using rule 108 (factorT -> factorF .)
    LESS            reduce using rule 108 (factorT -> factorF .)
    GREATER         reduce using rule 108 (factorT -> factorF .)
    LESS_TH         reduce using rule 108 (factorT -> factorF .)
    GREAT_TH        reduce using rule 108 (factorT -> factorF .)
    SAME            reduce using rule 108 (factorT -> factorF .)
    DIF             reduce using rule 108 (factorT -> factorF .)
    ID              reduce using rule 108 (factorT -> factorF .)
    RETURN          reduce using rule 108 (factorT -> factorF .)
    READ            reduce using rule 108 (factorT -> factorF .)
    WRITE           reduce using rule 108 (factorT -> factorF .)
    IF              reduce using rule 108 (factorT -> factorF .)
    VAR             reduce using rule 108 (factorT -> factorF .)
    WHILE           reduce using rule 108 (factorT -> factorF .)
    FROM            reduce using rule 108 (factorT -> factorF .)
    R_CURPAR        reduce using rule 108 (factorT -> factorF .)
    SEMICOLON       reduce using rule 108 (factorT -> factorF .)
    R_PAR           reduce using rule 108 (factorT -> factorF .)
    COMMA           reduce using rule 108 (factorT -> factorF .)
    R_BREAK         reduce using rule 108 (factorT -> factorF .)
    TO              reduce using rule 108 (factorT -> factorF .)
    OR              reduce using rule 108 (factorT -> factorF .)
    AND             reduce using rule 108 (factorT -> factorF .)
    DO              reduce using rule 108 (factorT -> factorF .)


state 149

    (107) factorT -> MINUS . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    factorF                        shift and go to state 206
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 150

    (109) factorF -> varcte . empty
    (114) empty -> .

    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 207

state 151

    (110) varcte -> var . empty
    (114) empty -> .

    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 208

state 152

    (111) varcte -> CTE_INT . empty
    (114) empty -> .

    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 209

state 153

    (112) varcte -> CTE_FLOAT . empty
    (114) empty -> .

    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 210

state 154

    (113) varcte -> CTE_CHAR . empty
    (114) empty -> .

    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 211

state 155

    (57) var -> ID . DOT VAR varF

    DOT             shift and go to state 212


state 156

    (75) assigmentF -> ope exp . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 213

state 157

    (76) ope -> PLUS_EQ empty .

    L_PAR           reduce using rule 76 (ope -> PLUS_EQ empty .)
    PLUS            reduce using rule 76 (ope -> PLUS_EQ empty .)
    MINUS           reduce using rule 76 (ope -> PLUS_EQ empty .)
    CTE_INT         reduce using rule 76 (ope -> PLUS_EQ empty .)
    CTE_FLOAT       reduce using rule 76 (ope -> PLUS_EQ empty .)
    CTE_CHAR        reduce using rule 76 (ope -> PLUS_EQ empty .)
    VAR             reduce using rule 76 (ope -> PLUS_EQ empty .)
    ID              reduce using rule 76 (ope -> PLUS_EQ empty .)


state 158

    (77) ope -> MIN_EQ empty .

    L_PAR           reduce using rule 77 (ope -> MIN_EQ empty .)
    PLUS            reduce using rule 77 (ope -> MIN_EQ empty .)
    MINUS           reduce using rule 77 (ope -> MIN_EQ empty .)
    CTE_INT         reduce using rule 77 (ope -> MIN_EQ empty .)
    CTE_FLOAT       reduce using rule 77 (ope -> MIN_EQ empty .)
    CTE_CHAR        reduce using rule 77 (ope -> MIN_EQ empty .)
    VAR             reduce using rule 77 (ope -> MIN_EQ empty .)
    ID              reduce using rule 77 (ope -> MIN_EQ empty .)


state 159

    (78) ope -> MULT_EQ empty .

    L_PAR           reduce using rule 78 (ope -> MULT_EQ empty .)
    PLUS            reduce using rule 78 (ope -> MULT_EQ empty .)
    MINUS           reduce using rule 78 (ope -> MULT_EQ empty .)
    CTE_INT         reduce using rule 78 (ope -> MULT_EQ empty .)
    CTE_FLOAT       reduce using rule 78 (ope -> MULT_EQ empty .)
    CTE_CHAR        reduce using rule 78 (ope -> MULT_EQ empty .)
    VAR             reduce using rule 78 (ope -> MULT_EQ empty .)
    ID              reduce using rule 78 (ope -> MULT_EQ empty .)


state 160

    (79) ope -> DIV_EQ empty .

    L_PAR           reduce using rule 79 (ope -> DIV_EQ empty .)
    PLUS            reduce using rule 79 (ope -> DIV_EQ empty .)
    MINUS           reduce using rule 79 (ope -> DIV_EQ empty .)
    CTE_INT         reduce using rule 79 (ope -> DIV_EQ empty .)
    CTE_FLOAT       reduce using rule 79 (ope -> DIV_EQ empty .)
    CTE_CHAR        reduce using rule 79 (ope -> DIV_EQ empty .)
    VAR             reduce using rule 79 (ope -> DIV_EQ empty .)
    ID              reduce using rule 79 (ope -> DIV_EQ empty .)


state 161

    (48) void -> ID DOT ID . L_PAR param R_PAR SEMICOLON empty

    L_PAR           shift and go to state 214


state 162

    (57) var -> ID DOT VAR . varF
    (58) varF -> . arrfunc empty
    (59) varF -> . empty
    (50) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (51) arrfunc -> . L_BREAK exp R_BREAK empty
    (114) empty -> .

    L_BREAK         shift and go to state 127
    EQUAL           reduce using rule 114 (empty -> .)
    PLUS_EQ         reduce using rule 114 (empty -> .)
    MIN_EQ          reduce using rule 114 (empty -> .)
    MULT_EQ         reduce using rule 114 (empty -> .)
    DIV_EQ          reduce using rule 114 (empty -> .)
    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    varF                           shift and go to state 215
    arrfunc                        shift and go to state 125
    empty                          shift and go to state 126

state 163

    (49) void -> ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 216


state 164

    (52) param -> var . paramF
    (53) paramF -> . COMMA param
    (54) paramF -> . empty
    (114) empty -> .

    COMMA           shift and go to state 218
    R_PAR           reduce using rule 114 (empty -> .)

    paramF                         shift and go to state 217
    empty                          shift and go to state 219

state 165

    (55) return -> RETURN L_PAR exp . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 220


state 166

    (60) read -> READ L_PAR readF .

    ID              reduce using rule 60 (read -> READ L_PAR readF .)
    RETURN          reduce using rule 60 (read -> READ L_PAR readF .)
    READ            reduce using rule 60 (read -> READ L_PAR readF .)
    WRITE           reduce using rule 60 (read -> READ L_PAR readF .)
    IF              reduce using rule 60 (read -> READ L_PAR readF .)
    VAR             reduce using rule 60 (read -> READ L_PAR readF .)
    WHILE           reduce using rule 60 (read -> READ L_PAR readF .)
    FROM            reduce using rule 60 (read -> READ L_PAR readF .)
    R_CURPAR        reduce using rule 60 (read -> READ L_PAR readF .)
    SEMICOLON       reduce using rule 60 (read -> READ L_PAR readF .)


state 167

    (61) readF -> var . COMMA readF
    (62) readF -> var . R_PAR SEMICOLON empty

    COMMA           shift and go to state 221
    R_PAR           shift and go to state 222


state 168

    (63) write -> WRITE L_PAR writeT .

    ID              reduce using rule 63 (write -> WRITE L_PAR writeT .)
    RETURN          reduce using rule 63 (write -> WRITE L_PAR writeT .)
    READ            reduce using rule 63 (write -> WRITE L_PAR writeT .)
    WRITE           reduce using rule 63 (write -> WRITE L_PAR writeT .)
    IF              reduce using rule 63 (write -> WRITE L_PAR writeT .)
    VAR             reduce using rule 63 (write -> WRITE L_PAR writeT .)
    WHILE           reduce using rule 63 (write -> WRITE L_PAR writeT .)
    FROM            reduce using rule 63 (write -> WRITE L_PAR writeT .)
    R_CURPAR        reduce using rule 63 (write -> WRITE L_PAR writeT .)
    SEMICOLON       reduce using rule 63 (write -> WRITE L_PAR writeT .)


state 169

    (64) writeT -> CTE_CHAR . writeF
    (113) varcte -> CTE_CHAR . empty
    (66) writeF -> . COMMA writeT
    (67) writeF -> . R_PAR SEMICOLON empty
    (114) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for R_PAR resolved as shift
    COMMA           shift and go to state 224
    R_PAR           shift and go to state 225
    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)

  ! COMMA           [ reduce using rule 114 (empty -> .) ]
  ! R_PAR           [ reduce using rule 114 (empty -> .) ]

    writeF                         shift and go to state 223
    empty                          shift and go to state 211

state 170

    (65) writeT -> exp . writeF
    (66) writeF -> . COMMA writeT
    (67) writeF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 224
    R_PAR           shift and go to state 225

    writeF                         shift and go to state 226

state 171

    (70) if -> IF L_PAR exp . R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    R_PAR           shift and go to state 227


state 172

    (58) varF -> arrfunc empty .

    EQUAL           reduce using rule 58 (varF -> arrfunc empty .)
    PLUS_EQ         reduce using rule 58 (varF -> arrfunc empty .)
    MIN_EQ          reduce using rule 58 (varF -> arrfunc empty .)
    MULT_EQ         reduce using rule 58 (varF -> arrfunc empty .)
    DIV_EQ          reduce using rule 58 (varF -> arrfunc empty .)
    MULT            reduce using rule 58 (varF -> arrfunc empty .)
    DIV             reduce using rule 58 (varF -> arrfunc empty .)
    PLUS            reduce using rule 58 (varF -> arrfunc empty .)
    MINUS           reduce using rule 58 (varF -> arrfunc empty .)
    LESS            reduce using rule 58 (varF -> arrfunc empty .)
    GREATER         reduce using rule 58 (varF -> arrfunc empty .)
    LESS_TH         reduce using rule 58 (varF -> arrfunc empty .)
    GREAT_TH        reduce using rule 58 (varF -> arrfunc empty .)
    SAME            reduce using rule 58 (varF -> arrfunc empty .)
    DIF             reduce using rule 58 (varF -> arrfunc empty .)
    ID              reduce using rule 58 (varF -> arrfunc empty .)
    RETURN          reduce using rule 58 (varF -> arrfunc empty .)
    READ            reduce using rule 58 (varF -> arrfunc empty .)
    WRITE           reduce using rule 58 (varF -> arrfunc empty .)
    IF              reduce using rule 58 (varF -> arrfunc empty .)
    VAR             reduce using rule 58 (varF -> arrfunc empty .)
    WHILE           reduce using rule 58 (varF -> arrfunc empty .)
    FROM            reduce using rule 58 (varF -> arrfunc empty .)
    R_CURPAR        reduce using rule 58 (varF -> arrfunc empty .)
    SEMICOLON       reduce using rule 58 (varF -> arrfunc empty .)
    COMMA           reduce using rule 58 (varF -> arrfunc empty .)
    R_PAR           reduce using rule 58 (varF -> arrfunc empty .)
    R_BREAK         reduce using rule 58 (varF -> arrfunc empty .)
    TO              reduce using rule 58 (varF -> arrfunc empty .)
    OR              reduce using rule 58 (varF -> arrfunc empty .)
    AND             reduce using rule 58 (varF -> arrfunc empty .)
    DO              reduce using rule 58 (varF -> arrfunc empty .)


state 173

    (50) arrfunc -> L_BREAK exp . COMMA exp R_BREAK empty
    (51) arrfunc -> L_BREAK exp . R_BREAK empty

    COMMA           shift and go to state 228
    R_BREAK         shift and go to state 229


state 174

    (80) conditional -> WHILE L_PAR exp . R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    R_PAR           shift and go to state 230


state 175

    (81) nonconditional -> FROM VAR arrfunc . nonconditionalF
    (83) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    nonconditionalF                shift and go to state 231
    exp                            shift and go to state 177
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 176

    (82) nonconditional -> FROM VAR nonconditionalF .

    ID              reduce using rule 82 (nonconditional -> FROM VAR nonconditionalF .)
    RETURN          reduce using rule 82 (nonconditional -> FROM VAR nonconditionalF .)
    READ            reduce using rule 82 (nonconditional -> FROM VAR nonconditionalF .)
    WRITE           reduce using rule 82 (nonconditional -> FROM VAR nonconditionalF .)
    IF              reduce using rule 82 (nonconditional -> FROM VAR nonconditionalF .)
    VAR             reduce using rule 82 (nonconditional -> FROM VAR nonconditionalF .)
    WHILE           reduce using rule 82 (nonconditional -> FROM VAR nonconditionalF .)
    FROM            reduce using rule 82 (nonconditional -> FROM VAR nonconditionalF .)
    R_CURPAR        reduce using rule 82 (nonconditional -> FROM VAR nonconditionalF .)
    SEMICOLON       reduce using rule 82 (nonconditional -> FROM VAR nonconditionalF .)


state 177

    (83) nonconditionalF -> exp . TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty

    TO              shift and go to state 232


state 178

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func . R_CURPAR SEMICOLON empty

    R_CURPAR        shift and go to state 233


state 179

    (21) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .

    COMMA           reduce using rule 21 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    COLON           reduce using rule 21 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)


state 180

    (24) funcF -> parameter R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 234


state 181

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    statement                      shift and go to state 235
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 182

    (31) parameter -> VAR COLON typepar SEMICOLON . parameterF
    (32) parameterF -> . parameter
    (33) parameterF -> . empty
    (31) parameter -> . VAR COLON typepar SEMICOLON parameterF
    (114) empty -> .

    VAR             shift and go to state 70
    R_PAR           reduce using rule 114 (empty -> .)

    parameterF                     shift and go to state 236
    parameter                      shift and go to state 237
    empty                          shift and go to state 238

state 183

    (34) typepar -> INT empty .

    SEMICOLON       reduce using rule 34 (typepar -> INT empty .)


state 184

    (35) typepar -> FLOAT empty .

    SEMICOLON       reduce using rule 35 (typepar -> FLOAT empty .)


state 185

    (36) typepar -> CHAR empty .

    SEMICOLON       reduce using rule 36 (typepar -> CHAR empty .)


state 186

    (37) typepar -> ID empty .

    SEMICOLON       reduce using rule 37 (typepar -> ID empty .)


state 187

    (74) assigmentF -> EQUAL exp empty .

    ID              reduce using rule 74 (assigmentF -> EQUAL exp empty .)
    RETURN          reduce using rule 74 (assigmentF -> EQUAL exp empty .)
    READ            reduce using rule 74 (assigmentF -> EQUAL exp empty .)
    WRITE           reduce using rule 74 (assigmentF -> EQUAL exp empty .)
    IF              reduce using rule 74 (assigmentF -> EQUAL exp empty .)
    VAR             reduce using rule 74 (assigmentF -> EQUAL exp empty .)
    WHILE           reduce using rule 74 (assigmentF -> EQUAL exp empty .)
    FROM            reduce using rule 74 (assigmentF -> EQUAL exp empty .)
    R_CURPAR        reduce using rule 74 (assigmentF -> EQUAL exp empty .)
    SEMICOLON       reduce using rule 74 (assigmentF -> EQUAL exp empty .)


state 188

    (86) exp -> ex expT .

    ID              reduce using rule 86 (exp -> ex expT .)
    RETURN          reduce using rule 86 (exp -> ex expT .)
    READ            reduce using rule 86 (exp -> ex expT .)
    WRITE           reduce using rule 86 (exp -> ex expT .)
    IF              reduce using rule 86 (exp -> ex expT .)
    VAR             reduce using rule 86 (exp -> ex expT .)
    WHILE           reduce using rule 86 (exp -> ex expT .)
    FROM            reduce using rule 86 (exp -> ex expT .)
    R_CURPAR        reduce using rule 86 (exp -> ex expT .)
    SEMICOLON       reduce using rule 86 (exp -> ex expT .)
    R_PAR           reduce using rule 86 (exp -> ex expT .)
    COMMA           reduce using rule 86 (exp -> ex expT .)
    R_BREAK         reduce using rule 86 (exp -> ex expT .)
    TO              reduce using rule 86 (exp -> ex expT .)
    DO              reduce using rule 86 (exp -> ex expT .)


state 189

    (87) expT -> LESS . expf
    (94) expf -> . ex empty
    (95) expf -> . ex bool empty
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    expf                           shift and go to state 239
    ex                             shift and go to state 240
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 190

    (88) expT -> GREATER . expf
    (94) expf -> . ex empty
    (95) expf -> . ex bool empty
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    expf                           shift and go to state 241
    ex                             shift and go to state 240
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 191

    (89) expT -> LESS_TH . expf
    (94) expf -> . ex empty
    (95) expf -> . ex bool empty
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    expf                           shift and go to state 242
    ex                             shift and go to state 240
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 192

    (90) expT -> GREAT_TH . expf
    (94) expf -> . ex empty
    (95) expf -> . ex bool empty
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    expf                           shift and go to state 243
    ex                             shift and go to state 240
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 193

    (91) expT -> SAME . expf
    (94) expf -> . ex empty
    (95) expf -> . ex bool empty
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    expf                           shift and go to state 244
    ex                             shift and go to state 240
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 194

    (92) expT -> DIF . expf
    (94) expf -> . ex empty
    (95) expf -> . ex bool empty
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    expf                           shift and go to state 245
    ex                             shift and go to state 240
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 195

    (93) expT -> empty .

    ID              reduce using rule 93 (expT -> empty .)
    RETURN          reduce using rule 93 (expT -> empty .)
    READ            reduce using rule 93 (expT -> empty .)
    WRITE           reduce using rule 93 (expT -> empty .)
    IF              reduce using rule 93 (expT -> empty .)
    VAR             reduce using rule 93 (expT -> empty .)
    WHILE           reduce using rule 93 (expT -> empty .)
    FROM            reduce using rule 93 (expT -> empty .)
    R_CURPAR        reduce using rule 93 (expT -> empty .)
    SEMICOLON       reduce using rule 93 (expT -> empty .)
    R_PAR           reduce using rule 93 (expT -> empty .)
    COMMA           reduce using rule 93 (expT -> empty .)
    R_BREAK         reduce using rule 93 (expT -> empty .)
    TO              reduce using rule 93 (expT -> empty .)
    DO              reduce using rule 93 (expT -> empty .)


state 196

    (96) ex -> term exF .

    LESS            reduce using rule 96 (ex -> term exF .)
    GREATER         reduce using rule 96 (ex -> term exF .)
    LESS_TH         reduce using rule 96 (ex -> term exF .)
    GREAT_TH        reduce using rule 96 (ex -> term exF .)
    SAME            reduce using rule 96 (ex -> term exF .)
    DIF             reduce using rule 96 (ex -> term exF .)
    ID              reduce using rule 96 (ex -> term exF .)
    RETURN          reduce using rule 96 (ex -> term exF .)
    READ            reduce using rule 96 (ex -> term exF .)
    WRITE           reduce using rule 96 (ex -> term exF .)
    IF              reduce using rule 96 (ex -> term exF .)
    VAR             reduce using rule 96 (ex -> term exF .)
    WHILE           reduce using rule 96 (ex -> term exF .)
    FROM            reduce using rule 96 (ex -> term exF .)
    R_CURPAR        reduce using rule 96 (ex -> term exF .)
    SEMICOLON       reduce using rule 96 (ex -> term exF .)
    R_PAR           reduce using rule 96 (ex -> term exF .)
    COMMA           reduce using rule 96 (ex -> term exF .)
    R_BREAK         reduce using rule 96 (ex -> term exF .)
    TO              reduce using rule 96 (ex -> term exF .)
    OR              reduce using rule 96 (ex -> term exF .)
    AND             reduce using rule 96 (ex -> term exF .)
    DO              reduce using rule 96 (ex -> term exF .)


state 197

    (97) exF -> PLUS . ex
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    ex                             shift and go to state 246
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 198

    (98) exF -> MINUS . ex
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    ex                             shift and go to state 247
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 199

    (99) exF -> empty .

    LESS            reduce using rule 99 (exF -> empty .)
    GREATER         reduce using rule 99 (exF -> empty .)
    LESS_TH         reduce using rule 99 (exF -> empty .)
    GREAT_TH        reduce using rule 99 (exF -> empty .)
    SAME            reduce using rule 99 (exF -> empty .)
    DIF             reduce using rule 99 (exF -> empty .)
    ID              reduce using rule 99 (exF -> empty .)
    RETURN          reduce using rule 99 (exF -> empty .)
    READ            reduce using rule 99 (exF -> empty .)
    WRITE           reduce using rule 99 (exF -> empty .)
    IF              reduce using rule 99 (exF -> empty .)
    VAR             reduce using rule 99 (exF -> empty .)
    WHILE           reduce using rule 99 (exF -> empty .)
    FROM            reduce using rule 99 (exF -> empty .)
    R_CURPAR        reduce using rule 99 (exF -> empty .)
    SEMICOLON       reduce using rule 99 (exF -> empty .)
    R_PAR           reduce using rule 99 (exF -> empty .)
    COMMA           reduce using rule 99 (exF -> empty .)
    R_BREAK         reduce using rule 99 (exF -> empty .)
    TO              reduce using rule 99 (exF -> empty .)
    OR              reduce using rule 99 (exF -> empty .)
    AND             reduce using rule 99 (exF -> empty .)
    DO              reduce using rule 99 (exF -> empty .)


state 200

    (100) term -> factor termF .

    PLUS            reduce using rule 100 (term -> factor termF .)
    MINUS           reduce using rule 100 (term -> factor termF .)
    LESS            reduce using rule 100 (term -> factor termF .)
    GREATER         reduce using rule 100 (term -> factor termF .)
    LESS_TH         reduce using rule 100 (term -> factor termF .)
    GREAT_TH        reduce using rule 100 (term -> factor termF .)
    SAME            reduce using rule 100 (term -> factor termF .)
    DIF             reduce using rule 100 (term -> factor termF .)
    ID              reduce using rule 100 (term -> factor termF .)
    RETURN          reduce using rule 100 (term -> factor termF .)
    READ            reduce using rule 100 (term -> factor termF .)
    WRITE           reduce using rule 100 (term -> factor termF .)
    IF              reduce using rule 100 (term -> factor termF .)
    VAR             reduce using rule 100 (term -> factor termF .)
    WHILE           reduce using rule 100 (term -> factor termF .)
    FROM            reduce using rule 100 (term -> factor termF .)
    R_CURPAR        reduce using rule 100 (term -> factor termF .)
    SEMICOLON       reduce using rule 100 (term -> factor termF .)
    R_PAR           reduce using rule 100 (term -> factor termF .)
    COMMA           reduce using rule 100 (term -> factor termF .)
    R_BREAK         reduce using rule 100 (term -> factor termF .)
    TO              reduce using rule 100 (term -> factor termF .)
    OR              reduce using rule 100 (term -> factor termF .)
    AND             reduce using rule 100 (term -> factor termF .)
    DO              reduce using rule 100 (term -> factor termF .)


state 201

    (101) termF -> MULT . term
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    term                           shift and go to state 248
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 202

    (102) termF -> DIV . term
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    term                           shift and go to state 249
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 203

    (103) termF -> empty .

    PLUS            reduce using rule 103 (termF -> empty .)
    MINUS           reduce using rule 103 (termF -> empty .)
    LESS            reduce using rule 103 (termF -> empty .)
    GREATER         reduce using rule 103 (termF -> empty .)
    LESS_TH         reduce using rule 103 (termF -> empty .)
    GREAT_TH        reduce using rule 103 (termF -> empty .)
    SAME            reduce using rule 103 (termF -> empty .)
    DIF             reduce using rule 103 (termF -> empty .)
    ID              reduce using rule 103 (termF -> empty .)
    RETURN          reduce using rule 103 (termF -> empty .)
    READ            reduce using rule 103 (termF -> empty .)
    WRITE           reduce using rule 103 (termF -> empty .)
    IF              reduce using rule 103 (termF -> empty .)
    VAR             reduce using rule 103 (termF -> empty .)
    WHILE           reduce using rule 103 (termF -> empty .)
    FROM            reduce using rule 103 (termF -> empty .)
    R_CURPAR        reduce using rule 103 (termF -> empty .)
    SEMICOLON       reduce using rule 103 (termF -> empty .)
    R_PAR           reduce using rule 103 (termF -> empty .)
    COMMA           reduce using rule 103 (termF -> empty .)
    R_BREAK         reduce using rule 103 (termF -> empty .)
    TO              reduce using rule 103 (termF -> empty .)
    OR              reduce using rule 103 (termF -> empty .)
    AND             reduce using rule 103 (termF -> empty .)
    DO              reduce using rule 103 (termF -> empty .)


state 204

    (104) factor -> L_PAR exp . R_PAR empty

    R_PAR           shift and go to state 250


state 205

    (106) factorT -> PLUS factorF .

    MULT            reduce using rule 106 (factorT -> PLUS factorF .)
    DIV             reduce using rule 106 (factorT -> PLUS factorF .)
    PLUS            reduce using rule 106 (factorT -> PLUS factorF .)
    MINUS           reduce using rule 106 (factorT -> PLUS factorF .)
    LESS            reduce using rule 106 (factorT -> PLUS factorF .)
    GREATER         reduce using rule 106 (factorT -> PLUS factorF .)
    LESS_TH         reduce using rule 106 (factorT -> PLUS factorF .)
    GREAT_TH        reduce using rule 106 (factorT -> PLUS factorF .)
    SAME            reduce using rule 106 (factorT -> PLUS factorF .)
    DIF             reduce using rule 106 (factorT -> PLUS factorF .)
    ID              reduce using rule 106 (factorT -> PLUS factorF .)
    RETURN          reduce using rule 106 (factorT -> PLUS factorF .)
    READ            reduce using rule 106 (factorT -> PLUS factorF .)
    WRITE           reduce using rule 106 (factorT -> PLUS factorF .)
    IF              reduce using rule 106 (factorT -> PLUS factorF .)
    VAR             reduce using rule 106 (factorT -> PLUS factorF .)
    WHILE           reduce using rule 106 (factorT -> PLUS factorF .)
    FROM            reduce using rule 106 (factorT -> PLUS factorF .)
    R_CURPAR        reduce using rule 106 (factorT -> PLUS factorF .)
    SEMICOLON       reduce using rule 106 (factorT -> PLUS factorF .)
    R_PAR           reduce using rule 106 (factorT -> PLUS factorF .)
    COMMA           reduce using rule 106 (factorT -> PLUS factorF .)
    R_BREAK         reduce using rule 106 (factorT -> PLUS factorF .)
    TO              reduce using rule 106 (factorT -> PLUS factorF .)
    OR              reduce using rule 106 (factorT -> PLUS factorF .)
    AND             reduce using rule 106 (factorT -> PLUS factorF .)
    DO              reduce using rule 106 (factorT -> PLUS factorF .)


state 206

    (107) factorT -> MINUS factorF .

    MULT            reduce using rule 107 (factorT -> MINUS factorF .)
    DIV             reduce using rule 107 (factorT -> MINUS factorF .)
    PLUS            reduce using rule 107 (factorT -> MINUS factorF .)
    MINUS           reduce using rule 107 (factorT -> MINUS factorF .)
    LESS            reduce using rule 107 (factorT -> MINUS factorF .)
    GREATER         reduce using rule 107 (factorT -> MINUS factorF .)
    LESS_TH         reduce using rule 107 (factorT -> MINUS factorF .)
    GREAT_TH        reduce using rule 107 (factorT -> MINUS factorF .)
    SAME            reduce using rule 107 (factorT -> MINUS factorF .)
    DIF             reduce using rule 107 (factorT -> MINUS factorF .)
    ID              reduce using rule 107 (factorT -> MINUS factorF .)
    RETURN          reduce using rule 107 (factorT -> MINUS factorF .)
    READ            reduce using rule 107 (factorT -> MINUS factorF .)
    WRITE           reduce using rule 107 (factorT -> MINUS factorF .)
    IF              reduce using rule 107 (factorT -> MINUS factorF .)
    VAR             reduce using rule 107 (factorT -> MINUS factorF .)
    WHILE           reduce using rule 107 (factorT -> MINUS factorF .)
    FROM            reduce using rule 107 (factorT -> MINUS factorF .)
    R_CURPAR        reduce using rule 107 (factorT -> MINUS factorF .)
    SEMICOLON       reduce using rule 107 (factorT -> MINUS factorF .)
    R_PAR           reduce using rule 107 (factorT -> MINUS factorF .)
    COMMA           reduce using rule 107 (factorT -> MINUS factorF .)
    R_BREAK         reduce using rule 107 (factorT -> MINUS factorF .)
    TO              reduce using rule 107 (factorT -> MINUS factorF .)
    OR              reduce using rule 107 (factorT -> MINUS factorF .)
    AND             reduce using rule 107 (factorT -> MINUS factorF .)
    DO              reduce using rule 107 (factorT -> MINUS factorF .)


state 207

    (109) factorF -> varcte empty .

    MULT            reduce using rule 109 (factorF -> varcte empty .)
    DIV             reduce using rule 109 (factorF -> varcte empty .)
    PLUS            reduce using rule 109 (factorF -> varcte empty .)
    MINUS           reduce using rule 109 (factorF -> varcte empty .)
    LESS            reduce using rule 109 (factorF -> varcte empty .)
    GREATER         reduce using rule 109 (factorF -> varcte empty .)
    LESS_TH         reduce using rule 109 (factorF -> varcte empty .)
    GREAT_TH        reduce using rule 109 (factorF -> varcte empty .)
    SAME            reduce using rule 109 (factorF -> varcte empty .)
    DIF             reduce using rule 109 (factorF -> varcte empty .)
    ID              reduce using rule 109 (factorF -> varcte empty .)
    RETURN          reduce using rule 109 (factorF -> varcte empty .)
    READ            reduce using rule 109 (factorF -> varcte empty .)
    WRITE           reduce using rule 109 (factorF -> varcte empty .)
    IF              reduce using rule 109 (factorF -> varcte empty .)
    VAR             reduce using rule 109 (factorF -> varcte empty .)
    WHILE           reduce using rule 109 (factorF -> varcte empty .)
    FROM            reduce using rule 109 (factorF -> varcte empty .)
    R_CURPAR        reduce using rule 109 (factorF -> varcte empty .)
    SEMICOLON       reduce using rule 109 (factorF -> varcte empty .)
    R_PAR           reduce using rule 109 (factorF -> varcte empty .)
    COMMA           reduce using rule 109 (factorF -> varcte empty .)
    R_BREAK         reduce using rule 109 (factorF -> varcte empty .)
    TO              reduce using rule 109 (factorF -> varcte empty .)
    OR              reduce using rule 109 (factorF -> varcte empty .)
    AND             reduce using rule 109 (factorF -> varcte empty .)
    DO              reduce using rule 109 (factorF -> varcte empty .)


state 208

    (110) varcte -> var empty .

    MULT            reduce using rule 110 (varcte -> var empty .)
    DIV             reduce using rule 110 (varcte -> var empty .)
    PLUS            reduce using rule 110 (varcte -> var empty .)
    MINUS           reduce using rule 110 (varcte -> var empty .)
    LESS            reduce using rule 110 (varcte -> var empty .)
    GREATER         reduce using rule 110 (varcte -> var empty .)
    LESS_TH         reduce using rule 110 (varcte -> var empty .)
    GREAT_TH        reduce using rule 110 (varcte -> var empty .)
    SAME            reduce using rule 110 (varcte -> var empty .)
    DIF             reduce using rule 110 (varcte -> var empty .)
    ID              reduce using rule 110 (varcte -> var empty .)
    RETURN          reduce using rule 110 (varcte -> var empty .)
    READ            reduce using rule 110 (varcte -> var empty .)
    WRITE           reduce using rule 110 (varcte -> var empty .)
    IF              reduce using rule 110 (varcte -> var empty .)
    VAR             reduce using rule 110 (varcte -> var empty .)
    WHILE           reduce using rule 110 (varcte -> var empty .)
    FROM            reduce using rule 110 (varcte -> var empty .)
    R_CURPAR        reduce using rule 110 (varcte -> var empty .)
    SEMICOLON       reduce using rule 110 (varcte -> var empty .)
    R_PAR           reduce using rule 110 (varcte -> var empty .)
    COMMA           reduce using rule 110 (varcte -> var empty .)
    R_BREAK         reduce using rule 110 (varcte -> var empty .)
    TO              reduce using rule 110 (varcte -> var empty .)
    OR              reduce using rule 110 (varcte -> var empty .)
    AND             reduce using rule 110 (varcte -> var empty .)
    DO              reduce using rule 110 (varcte -> var empty .)


state 209

    (111) varcte -> CTE_INT empty .

    MULT            reduce using rule 111 (varcte -> CTE_INT empty .)
    DIV             reduce using rule 111 (varcte -> CTE_INT empty .)
    PLUS            reduce using rule 111 (varcte -> CTE_INT empty .)
    MINUS           reduce using rule 111 (varcte -> CTE_INT empty .)
    LESS            reduce using rule 111 (varcte -> CTE_INT empty .)
    GREATER         reduce using rule 111 (varcte -> CTE_INT empty .)
    LESS_TH         reduce using rule 111 (varcte -> CTE_INT empty .)
    GREAT_TH        reduce using rule 111 (varcte -> CTE_INT empty .)
    SAME            reduce using rule 111 (varcte -> CTE_INT empty .)
    DIF             reduce using rule 111 (varcte -> CTE_INT empty .)
    ID              reduce using rule 111 (varcte -> CTE_INT empty .)
    RETURN          reduce using rule 111 (varcte -> CTE_INT empty .)
    READ            reduce using rule 111 (varcte -> CTE_INT empty .)
    WRITE           reduce using rule 111 (varcte -> CTE_INT empty .)
    IF              reduce using rule 111 (varcte -> CTE_INT empty .)
    VAR             reduce using rule 111 (varcte -> CTE_INT empty .)
    WHILE           reduce using rule 111 (varcte -> CTE_INT empty .)
    FROM            reduce using rule 111 (varcte -> CTE_INT empty .)
    R_CURPAR        reduce using rule 111 (varcte -> CTE_INT empty .)
    SEMICOLON       reduce using rule 111 (varcte -> CTE_INT empty .)
    R_PAR           reduce using rule 111 (varcte -> CTE_INT empty .)
    COMMA           reduce using rule 111 (varcte -> CTE_INT empty .)
    R_BREAK         reduce using rule 111 (varcte -> CTE_INT empty .)
    TO              reduce using rule 111 (varcte -> CTE_INT empty .)
    OR              reduce using rule 111 (varcte -> CTE_INT empty .)
    AND             reduce using rule 111 (varcte -> CTE_INT empty .)
    DO              reduce using rule 111 (varcte -> CTE_INT empty .)


state 210

    (112) varcte -> CTE_FLOAT empty .

    MULT            reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    DIV             reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    PLUS            reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    MINUS           reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    LESS            reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    GREATER         reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    LESS_TH         reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    GREAT_TH        reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    SAME            reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    DIF             reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    ID              reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    RETURN          reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    READ            reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    WRITE           reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    IF              reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    VAR             reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    WHILE           reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    FROM            reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    R_CURPAR        reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    SEMICOLON       reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    R_PAR           reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    COMMA           reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    R_BREAK         reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    TO              reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    OR              reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    AND             reduce using rule 112 (varcte -> CTE_FLOAT empty .)
    DO              reduce using rule 112 (varcte -> CTE_FLOAT empty .)


state 211

    (113) varcte -> CTE_CHAR empty .

    MULT            reduce using rule 113 (varcte -> CTE_CHAR empty .)
    DIV             reduce using rule 113 (varcte -> CTE_CHAR empty .)
    PLUS            reduce using rule 113 (varcte -> CTE_CHAR empty .)
    MINUS           reduce using rule 113 (varcte -> CTE_CHAR empty .)
    LESS            reduce using rule 113 (varcte -> CTE_CHAR empty .)
    GREATER         reduce using rule 113 (varcte -> CTE_CHAR empty .)
    LESS_TH         reduce using rule 113 (varcte -> CTE_CHAR empty .)
    GREAT_TH        reduce using rule 113 (varcte -> CTE_CHAR empty .)
    SAME            reduce using rule 113 (varcte -> CTE_CHAR empty .)
    DIF             reduce using rule 113 (varcte -> CTE_CHAR empty .)
    ID              reduce using rule 113 (varcte -> CTE_CHAR empty .)
    RETURN          reduce using rule 113 (varcte -> CTE_CHAR empty .)
    READ            reduce using rule 113 (varcte -> CTE_CHAR empty .)
    WRITE           reduce using rule 113 (varcte -> CTE_CHAR empty .)
    IF              reduce using rule 113 (varcte -> CTE_CHAR empty .)
    VAR             reduce using rule 113 (varcte -> CTE_CHAR empty .)
    WHILE           reduce using rule 113 (varcte -> CTE_CHAR empty .)
    FROM            reduce using rule 113 (varcte -> CTE_CHAR empty .)
    R_CURPAR        reduce using rule 113 (varcte -> CTE_CHAR empty .)
    SEMICOLON       reduce using rule 113 (varcte -> CTE_CHAR empty .)
    R_PAR           reduce using rule 113 (varcte -> CTE_CHAR empty .)
    COMMA           reduce using rule 113 (varcte -> CTE_CHAR empty .)
    R_BREAK         reduce using rule 113 (varcte -> CTE_CHAR empty .)
    TO              reduce using rule 113 (varcte -> CTE_CHAR empty .)
    OR              reduce using rule 113 (varcte -> CTE_CHAR empty .)
    AND             reduce using rule 113 (varcte -> CTE_CHAR empty .)
    DO              reduce using rule 113 (varcte -> CTE_CHAR empty .)


state 212

    (57) var -> ID DOT . VAR varF

    VAR             shift and go to state 162


state 213

    (75) assigmentF -> ope exp empty .

    ID              reduce using rule 75 (assigmentF -> ope exp empty .)
    RETURN          reduce using rule 75 (assigmentF -> ope exp empty .)
    READ            reduce using rule 75 (assigmentF -> ope exp empty .)
    WRITE           reduce using rule 75 (assigmentF -> ope exp empty .)
    IF              reduce using rule 75 (assigmentF -> ope exp empty .)
    VAR             reduce using rule 75 (assigmentF -> ope exp empty .)
    WHILE           reduce using rule 75 (assigmentF -> ope exp empty .)
    FROM            reduce using rule 75 (assigmentF -> ope exp empty .)
    R_CURPAR        reduce using rule 75 (assigmentF -> ope exp empty .)
    SEMICOLON       reduce using rule 75 (assigmentF -> ope exp empty .)


state 214

    (48) void -> ID DOT ID L_PAR . param R_PAR SEMICOLON empty
    (52) param -> . var paramF
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    VAR             shift and go to state 87
    ID              shift and go to state 155

    param                          shift and go to state 251
    var                            shift and go to state 164

state 215

    (57) var -> ID DOT VAR varF .

    EQUAL           reduce using rule 57 (var -> ID DOT VAR varF .)
    PLUS_EQ         reduce using rule 57 (var -> ID DOT VAR varF .)
    MIN_EQ          reduce using rule 57 (var -> ID DOT VAR varF .)
    MULT_EQ         reduce using rule 57 (var -> ID DOT VAR varF .)
    DIV_EQ          reduce using rule 57 (var -> ID DOT VAR varF .)
    MULT            reduce using rule 57 (var -> ID DOT VAR varF .)
    DIV             reduce using rule 57 (var -> ID DOT VAR varF .)
    PLUS            reduce using rule 57 (var -> ID DOT VAR varF .)
    MINUS           reduce using rule 57 (var -> ID DOT VAR varF .)
    LESS            reduce using rule 57 (var -> ID DOT VAR varF .)
    GREATER         reduce using rule 57 (var -> ID DOT VAR varF .)
    LESS_TH         reduce using rule 57 (var -> ID DOT VAR varF .)
    GREAT_TH        reduce using rule 57 (var -> ID DOT VAR varF .)
    SAME            reduce using rule 57 (var -> ID DOT VAR varF .)
    DIF             reduce using rule 57 (var -> ID DOT VAR varF .)
    ID              reduce using rule 57 (var -> ID DOT VAR varF .)
    RETURN          reduce using rule 57 (var -> ID DOT VAR varF .)
    READ            reduce using rule 57 (var -> ID DOT VAR varF .)
    WRITE           reduce using rule 57 (var -> ID DOT VAR varF .)
    IF              reduce using rule 57 (var -> ID DOT VAR varF .)
    VAR             reduce using rule 57 (var -> ID DOT VAR varF .)
    WHILE           reduce using rule 57 (var -> ID DOT VAR varF .)
    FROM            reduce using rule 57 (var -> ID DOT VAR varF .)
    R_CURPAR        reduce using rule 57 (var -> ID DOT VAR varF .)
    SEMICOLON       reduce using rule 57 (var -> ID DOT VAR varF .)
    COMMA           reduce using rule 57 (var -> ID DOT VAR varF .)
    R_PAR           reduce using rule 57 (var -> ID DOT VAR varF .)
    R_BREAK         reduce using rule 57 (var -> ID DOT VAR varF .)
    TO              reduce using rule 57 (var -> ID DOT VAR varF .)
    OR              reduce using rule 57 (var -> ID DOT VAR varF .)
    AND             reduce using rule 57 (var -> ID DOT VAR varF .)
    DO              reduce using rule 57 (var -> ID DOT VAR varF .)


state 216

    (49) void -> ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 252


state 217

    (52) param -> var paramF .

    R_PAR           reduce using rule 52 (param -> var paramF .)


state 218

    (53) paramF -> COMMA . param
    (52) param -> . var paramF
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    VAR             shift and go to state 87
    ID              shift and go to state 155

    param                          shift and go to state 253
    var                            shift and go to state 164

state 219

    (54) paramF -> empty .

    R_PAR           reduce using rule 54 (paramF -> empty .)


state 220

    (55) return -> RETURN L_PAR exp R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 254


state 221

    (61) readF -> var COMMA . readF
    (61) readF -> . var COMMA readF
    (62) readF -> . var R_PAR SEMICOLON empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    VAR             shift and go to state 87
    ID              shift and go to state 155

    var                            shift and go to state 167
    readF                          shift and go to state 255

state 222

    (62) readF -> var R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 256


state 223

    (64) writeT -> CTE_CHAR writeF .

    ID              reduce using rule 64 (writeT -> CTE_CHAR writeF .)
    RETURN          reduce using rule 64 (writeT -> CTE_CHAR writeF .)
    READ            reduce using rule 64 (writeT -> CTE_CHAR writeF .)
    WRITE           reduce using rule 64 (writeT -> CTE_CHAR writeF .)
    IF              reduce using rule 64 (writeT -> CTE_CHAR writeF .)
    VAR             reduce using rule 64 (writeT -> CTE_CHAR writeF .)
    WHILE           reduce using rule 64 (writeT -> CTE_CHAR writeF .)
    FROM            reduce using rule 64 (writeT -> CTE_CHAR writeF .)
    R_CURPAR        reduce using rule 64 (writeT -> CTE_CHAR writeF .)
    SEMICOLON       reduce using rule 64 (writeT -> CTE_CHAR writeF .)


state 224

    (66) writeF -> COMMA . writeT
    (64) writeT -> . CTE_CHAR writeF
    (65) writeT -> . exp writeF
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    CTE_CHAR        shift and go to state 169
    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    VAR             shift and go to state 87
    ID              shift and go to state 155

    writeT                         shift and go to state 257
    exp                            shift and go to state 170
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 225

    (67) writeF -> R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 258


state 226

    (65) writeT -> exp writeF .

    ID              reduce using rule 65 (writeT -> exp writeF .)
    RETURN          reduce using rule 65 (writeT -> exp writeF .)
    READ            reduce using rule 65 (writeT -> exp writeF .)
    WRITE           reduce using rule 65 (writeT -> exp writeF .)
    IF              reduce using rule 65 (writeT -> exp writeF .)
    VAR             reduce using rule 65 (writeT -> exp writeF .)
    WHILE           reduce using rule 65 (writeT -> exp writeF .)
    FROM            reduce using rule 65 (writeT -> exp writeF .)
    R_CURPAR        reduce using rule 65 (writeT -> exp writeF .)
    SEMICOLON       reduce using rule 65 (writeT -> exp writeF .)


state 227

    (70) if -> IF L_PAR exp R_PAR . THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    THEN            shift and go to state 259


state 228

    (50) arrfunc -> L_BREAK exp COMMA . exp R_BREAK empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 260
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 229

    (51) arrfunc -> L_BREAK exp R_BREAK . empty
    (114) empty -> .

    EQUAL           reduce using rule 114 (empty -> .)
    PLUS_EQ         reduce using rule 114 (empty -> .)
    MIN_EQ          reduce using rule 114 (empty -> .)
    MULT_EQ         reduce using rule 114 (empty -> .)
    DIV_EQ          reduce using rule 114 (empty -> .)
    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)
    L_PAR           reduce using rule 114 (empty -> .)
    CTE_INT         reduce using rule 114 (empty -> .)
    CTE_FLOAT       reduce using rule 114 (empty -> .)
    CTE_CHAR        reduce using rule 114 (empty -> .)

    empty                          shift and go to state 261

state 230

    (80) conditional -> WHILE L_PAR exp R_PAR . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 262


state 231

    (81) nonconditional -> FROM VAR arrfunc nonconditionalF .

    ID              reduce using rule 81 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    RETURN          reduce using rule 81 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    READ            reduce using rule 81 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WRITE           reduce using rule 81 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    IF              reduce using rule 81 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    VAR             reduce using rule 81 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WHILE           reduce using rule 81 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    FROM            reduce using rule 81 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    R_CURPAR        reduce using rule 81 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    SEMICOLON       reduce using rule 81 (nonconditional -> FROM VAR arrfunc nonconditionalF .)


state 232

    (83) nonconditionalF -> exp TO . exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 263
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 233

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR . SEMICOLON empty

    SEMICOLON       shift and go to state 264


state 234

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    statement                      shift and go to state 265
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 235

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 266


state 236

    (31) parameter -> VAR COLON typepar SEMICOLON parameterF .

    R_PAR           reduce using rule 31 (parameter -> VAR COLON typepar SEMICOLON parameterF .)


state 237

    (32) parameterF -> parameter .

    R_PAR           reduce using rule 32 (parameterF -> parameter .)


state 238

    (33) parameterF -> empty .

    R_PAR           reduce using rule 33 (parameterF -> empty .)


state 239

    (87) expT -> LESS expf .

    ID              reduce using rule 87 (expT -> LESS expf .)
    RETURN          reduce using rule 87 (expT -> LESS expf .)
    READ            reduce using rule 87 (expT -> LESS expf .)
    WRITE           reduce using rule 87 (expT -> LESS expf .)
    IF              reduce using rule 87 (expT -> LESS expf .)
    VAR             reduce using rule 87 (expT -> LESS expf .)
    WHILE           reduce using rule 87 (expT -> LESS expf .)
    FROM            reduce using rule 87 (expT -> LESS expf .)
    R_CURPAR        reduce using rule 87 (expT -> LESS expf .)
    SEMICOLON       reduce using rule 87 (expT -> LESS expf .)
    R_PAR           reduce using rule 87 (expT -> LESS expf .)
    COMMA           reduce using rule 87 (expT -> LESS expf .)
    R_BREAK         reduce using rule 87 (expT -> LESS expf .)
    TO              reduce using rule 87 (expT -> LESS expf .)
    DO              reduce using rule 87 (expT -> LESS expf .)


state 240

    (94) expf -> ex . empty
    (95) expf -> ex . bool empty
    (114) empty -> .
    (84) bool -> . OR exp empty
    (85) bool -> . AND exp empty

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)
    OR              shift and go to state 269
    AND             shift and go to state 270

    empty                          shift and go to state 267
    bool                           shift and go to state 268

state 241

    (88) expT -> GREATER expf .

    ID              reduce using rule 88 (expT -> GREATER expf .)
    RETURN          reduce using rule 88 (expT -> GREATER expf .)
    READ            reduce using rule 88 (expT -> GREATER expf .)
    WRITE           reduce using rule 88 (expT -> GREATER expf .)
    IF              reduce using rule 88 (expT -> GREATER expf .)
    VAR             reduce using rule 88 (expT -> GREATER expf .)
    WHILE           reduce using rule 88 (expT -> GREATER expf .)
    FROM            reduce using rule 88 (expT -> GREATER expf .)
    R_CURPAR        reduce using rule 88 (expT -> GREATER expf .)
    SEMICOLON       reduce using rule 88 (expT -> GREATER expf .)
    R_PAR           reduce using rule 88 (expT -> GREATER expf .)
    COMMA           reduce using rule 88 (expT -> GREATER expf .)
    R_BREAK         reduce using rule 88 (expT -> GREATER expf .)
    TO              reduce using rule 88 (expT -> GREATER expf .)
    DO              reduce using rule 88 (expT -> GREATER expf .)


state 242

    (89) expT -> LESS_TH expf .

    ID              reduce using rule 89 (expT -> LESS_TH expf .)
    RETURN          reduce using rule 89 (expT -> LESS_TH expf .)
    READ            reduce using rule 89 (expT -> LESS_TH expf .)
    WRITE           reduce using rule 89 (expT -> LESS_TH expf .)
    IF              reduce using rule 89 (expT -> LESS_TH expf .)
    VAR             reduce using rule 89 (expT -> LESS_TH expf .)
    WHILE           reduce using rule 89 (expT -> LESS_TH expf .)
    FROM            reduce using rule 89 (expT -> LESS_TH expf .)
    R_CURPAR        reduce using rule 89 (expT -> LESS_TH expf .)
    SEMICOLON       reduce using rule 89 (expT -> LESS_TH expf .)
    R_PAR           reduce using rule 89 (expT -> LESS_TH expf .)
    COMMA           reduce using rule 89 (expT -> LESS_TH expf .)
    R_BREAK         reduce using rule 89 (expT -> LESS_TH expf .)
    TO              reduce using rule 89 (expT -> LESS_TH expf .)
    DO              reduce using rule 89 (expT -> LESS_TH expf .)


state 243

    (90) expT -> GREAT_TH expf .

    ID              reduce using rule 90 (expT -> GREAT_TH expf .)
    RETURN          reduce using rule 90 (expT -> GREAT_TH expf .)
    READ            reduce using rule 90 (expT -> GREAT_TH expf .)
    WRITE           reduce using rule 90 (expT -> GREAT_TH expf .)
    IF              reduce using rule 90 (expT -> GREAT_TH expf .)
    VAR             reduce using rule 90 (expT -> GREAT_TH expf .)
    WHILE           reduce using rule 90 (expT -> GREAT_TH expf .)
    FROM            reduce using rule 90 (expT -> GREAT_TH expf .)
    R_CURPAR        reduce using rule 90 (expT -> GREAT_TH expf .)
    SEMICOLON       reduce using rule 90 (expT -> GREAT_TH expf .)
    R_PAR           reduce using rule 90 (expT -> GREAT_TH expf .)
    COMMA           reduce using rule 90 (expT -> GREAT_TH expf .)
    R_BREAK         reduce using rule 90 (expT -> GREAT_TH expf .)
    TO              reduce using rule 90 (expT -> GREAT_TH expf .)
    DO              reduce using rule 90 (expT -> GREAT_TH expf .)


state 244

    (91) expT -> SAME expf .

    ID              reduce using rule 91 (expT -> SAME expf .)
    RETURN          reduce using rule 91 (expT -> SAME expf .)
    READ            reduce using rule 91 (expT -> SAME expf .)
    WRITE           reduce using rule 91 (expT -> SAME expf .)
    IF              reduce using rule 91 (expT -> SAME expf .)
    VAR             reduce using rule 91 (expT -> SAME expf .)
    WHILE           reduce using rule 91 (expT -> SAME expf .)
    FROM            reduce using rule 91 (expT -> SAME expf .)
    R_CURPAR        reduce using rule 91 (expT -> SAME expf .)
    SEMICOLON       reduce using rule 91 (expT -> SAME expf .)
    R_PAR           reduce using rule 91 (expT -> SAME expf .)
    COMMA           reduce using rule 91 (expT -> SAME expf .)
    R_BREAK         reduce using rule 91 (expT -> SAME expf .)
    TO              reduce using rule 91 (expT -> SAME expf .)
    DO              reduce using rule 91 (expT -> SAME expf .)


state 245

    (92) expT -> DIF expf .

    ID              reduce using rule 92 (expT -> DIF expf .)
    RETURN          reduce using rule 92 (expT -> DIF expf .)
    READ            reduce using rule 92 (expT -> DIF expf .)
    WRITE           reduce using rule 92 (expT -> DIF expf .)
    IF              reduce using rule 92 (expT -> DIF expf .)
    VAR             reduce using rule 92 (expT -> DIF expf .)
    WHILE           reduce using rule 92 (expT -> DIF expf .)
    FROM            reduce using rule 92 (expT -> DIF expf .)
    R_CURPAR        reduce using rule 92 (expT -> DIF expf .)
    SEMICOLON       reduce using rule 92 (expT -> DIF expf .)
    R_PAR           reduce using rule 92 (expT -> DIF expf .)
    COMMA           reduce using rule 92 (expT -> DIF expf .)
    R_BREAK         reduce using rule 92 (expT -> DIF expf .)
    TO              reduce using rule 92 (expT -> DIF expf .)
    DO              reduce using rule 92 (expT -> DIF expf .)


state 246

    (97) exF -> PLUS ex .

    LESS            reduce using rule 97 (exF -> PLUS ex .)
    GREATER         reduce using rule 97 (exF -> PLUS ex .)
    LESS_TH         reduce using rule 97 (exF -> PLUS ex .)
    GREAT_TH        reduce using rule 97 (exF -> PLUS ex .)
    SAME            reduce using rule 97 (exF -> PLUS ex .)
    DIF             reduce using rule 97 (exF -> PLUS ex .)
    ID              reduce using rule 97 (exF -> PLUS ex .)
    RETURN          reduce using rule 97 (exF -> PLUS ex .)
    READ            reduce using rule 97 (exF -> PLUS ex .)
    WRITE           reduce using rule 97 (exF -> PLUS ex .)
    IF              reduce using rule 97 (exF -> PLUS ex .)
    VAR             reduce using rule 97 (exF -> PLUS ex .)
    WHILE           reduce using rule 97 (exF -> PLUS ex .)
    FROM            reduce using rule 97 (exF -> PLUS ex .)
    R_CURPAR        reduce using rule 97 (exF -> PLUS ex .)
    SEMICOLON       reduce using rule 97 (exF -> PLUS ex .)
    R_PAR           reduce using rule 97 (exF -> PLUS ex .)
    COMMA           reduce using rule 97 (exF -> PLUS ex .)
    R_BREAK         reduce using rule 97 (exF -> PLUS ex .)
    TO              reduce using rule 97 (exF -> PLUS ex .)
    OR              reduce using rule 97 (exF -> PLUS ex .)
    AND             reduce using rule 97 (exF -> PLUS ex .)
    DO              reduce using rule 97 (exF -> PLUS ex .)


state 247

    (98) exF -> MINUS ex .

    LESS            reduce using rule 98 (exF -> MINUS ex .)
    GREATER         reduce using rule 98 (exF -> MINUS ex .)
    LESS_TH         reduce using rule 98 (exF -> MINUS ex .)
    GREAT_TH        reduce using rule 98 (exF -> MINUS ex .)
    SAME            reduce using rule 98 (exF -> MINUS ex .)
    DIF             reduce using rule 98 (exF -> MINUS ex .)
    ID              reduce using rule 98 (exF -> MINUS ex .)
    RETURN          reduce using rule 98 (exF -> MINUS ex .)
    READ            reduce using rule 98 (exF -> MINUS ex .)
    WRITE           reduce using rule 98 (exF -> MINUS ex .)
    IF              reduce using rule 98 (exF -> MINUS ex .)
    VAR             reduce using rule 98 (exF -> MINUS ex .)
    WHILE           reduce using rule 98 (exF -> MINUS ex .)
    FROM            reduce using rule 98 (exF -> MINUS ex .)
    R_CURPAR        reduce using rule 98 (exF -> MINUS ex .)
    SEMICOLON       reduce using rule 98 (exF -> MINUS ex .)
    R_PAR           reduce using rule 98 (exF -> MINUS ex .)
    COMMA           reduce using rule 98 (exF -> MINUS ex .)
    R_BREAK         reduce using rule 98 (exF -> MINUS ex .)
    TO              reduce using rule 98 (exF -> MINUS ex .)
    OR              reduce using rule 98 (exF -> MINUS ex .)
    AND             reduce using rule 98 (exF -> MINUS ex .)
    DO              reduce using rule 98 (exF -> MINUS ex .)


state 248

    (101) termF -> MULT term .

    PLUS            reduce using rule 101 (termF -> MULT term .)
    MINUS           reduce using rule 101 (termF -> MULT term .)
    LESS            reduce using rule 101 (termF -> MULT term .)
    GREATER         reduce using rule 101 (termF -> MULT term .)
    LESS_TH         reduce using rule 101 (termF -> MULT term .)
    GREAT_TH        reduce using rule 101 (termF -> MULT term .)
    SAME            reduce using rule 101 (termF -> MULT term .)
    DIF             reduce using rule 101 (termF -> MULT term .)
    ID              reduce using rule 101 (termF -> MULT term .)
    RETURN          reduce using rule 101 (termF -> MULT term .)
    READ            reduce using rule 101 (termF -> MULT term .)
    WRITE           reduce using rule 101 (termF -> MULT term .)
    IF              reduce using rule 101 (termF -> MULT term .)
    VAR             reduce using rule 101 (termF -> MULT term .)
    WHILE           reduce using rule 101 (termF -> MULT term .)
    FROM            reduce using rule 101 (termF -> MULT term .)
    R_CURPAR        reduce using rule 101 (termF -> MULT term .)
    SEMICOLON       reduce using rule 101 (termF -> MULT term .)
    R_PAR           reduce using rule 101 (termF -> MULT term .)
    COMMA           reduce using rule 101 (termF -> MULT term .)
    R_BREAK         reduce using rule 101 (termF -> MULT term .)
    TO              reduce using rule 101 (termF -> MULT term .)
    OR              reduce using rule 101 (termF -> MULT term .)
    AND             reduce using rule 101 (termF -> MULT term .)
    DO              reduce using rule 101 (termF -> MULT term .)


state 249

    (102) termF -> DIV term .

    PLUS            reduce using rule 102 (termF -> DIV term .)
    MINUS           reduce using rule 102 (termF -> DIV term .)
    LESS            reduce using rule 102 (termF -> DIV term .)
    GREATER         reduce using rule 102 (termF -> DIV term .)
    LESS_TH         reduce using rule 102 (termF -> DIV term .)
    GREAT_TH        reduce using rule 102 (termF -> DIV term .)
    SAME            reduce using rule 102 (termF -> DIV term .)
    DIF             reduce using rule 102 (termF -> DIV term .)
    ID              reduce using rule 102 (termF -> DIV term .)
    RETURN          reduce using rule 102 (termF -> DIV term .)
    READ            reduce using rule 102 (termF -> DIV term .)
    WRITE           reduce using rule 102 (termF -> DIV term .)
    IF              reduce using rule 102 (termF -> DIV term .)
    VAR             reduce using rule 102 (termF -> DIV term .)
    WHILE           reduce using rule 102 (termF -> DIV term .)
    FROM            reduce using rule 102 (termF -> DIV term .)
    R_CURPAR        reduce using rule 102 (termF -> DIV term .)
    SEMICOLON       reduce using rule 102 (termF -> DIV term .)
    R_PAR           reduce using rule 102 (termF -> DIV term .)
    COMMA           reduce using rule 102 (termF -> DIV term .)
    R_BREAK         reduce using rule 102 (termF -> DIV term .)
    TO              reduce using rule 102 (termF -> DIV term .)
    OR              reduce using rule 102 (termF -> DIV term .)
    AND             reduce using rule 102 (termF -> DIV term .)
    DO              reduce using rule 102 (termF -> DIV term .)


state 250

    (104) factor -> L_PAR exp R_PAR . empty
    (114) empty -> .

    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 271

state 251

    (48) void -> ID DOT ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 272


state 252

    (49) void -> ID L_PAR param R_PAR SEMICOLON . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 273

state 253

    (53) paramF -> COMMA param .

    R_PAR           reduce using rule 53 (paramF -> COMMA param .)


state 254

    (55) return -> RETURN L_PAR exp R_PAR SEMICOLON . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 274

state 255

    (61) readF -> var COMMA readF .

    ID              reduce using rule 61 (readF -> var COMMA readF .)
    RETURN          reduce using rule 61 (readF -> var COMMA readF .)
    READ            reduce using rule 61 (readF -> var COMMA readF .)
    WRITE           reduce using rule 61 (readF -> var COMMA readF .)
    IF              reduce using rule 61 (readF -> var COMMA readF .)
    VAR             reduce using rule 61 (readF -> var COMMA readF .)
    WHILE           reduce using rule 61 (readF -> var COMMA readF .)
    FROM            reduce using rule 61 (readF -> var COMMA readF .)
    R_CURPAR        reduce using rule 61 (readF -> var COMMA readF .)
    SEMICOLON       reduce using rule 61 (readF -> var COMMA readF .)


state 256

    (62) readF -> var R_PAR SEMICOLON . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 275

state 257

    (66) writeF -> COMMA writeT .

    ID              reduce using rule 66 (writeF -> COMMA writeT .)
    RETURN          reduce using rule 66 (writeF -> COMMA writeT .)
    READ            reduce using rule 66 (writeF -> COMMA writeT .)
    WRITE           reduce using rule 66 (writeF -> COMMA writeT .)
    IF              reduce using rule 66 (writeF -> COMMA writeT .)
    VAR             reduce using rule 66 (writeF -> COMMA writeT .)
    WHILE           reduce using rule 66 (writeF -> COMMA writeT .)
    FROM            reduce using rule 66 (writeF -> COMMA writeT .)
    R_CURPAR        reduce using rule 66 (writeF -> COMMA writeT .)
    SEMICOLON       reduce using rule 66 (writeF -> COMMA writeT .)


state 258

    (67) writeF -> R_PAR SEMICOLON . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 276

state 259

    (70) if -> IF L_PAR exp R_PAR THEN . L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_CURPAR        shift and go to state 277


state 260

    (50) arrfunc -> L_BREAK exp COMMA exp . R_BREAK empty

    R_BREAK         shift and go to state 278


state 261

    (51) arrfunc -> L_BREAK exp R_BREAK empty .

    EQUAL           reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MIN_EQ          reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT_EQ         reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV_EQ          reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT            reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV             reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS            reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MINUS           reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS            reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREATER         reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS_TH         reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREAT_TH        reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SAME            reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIF             reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    ID              reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    RETURN          reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    READ            reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WRITE           reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    IF              reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    VAR             reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WHILE           reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    FROM            reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_CURPAR        reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SEMICOLON       reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    COMMA           reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_PAR           reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_BREAK         reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    TO              reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    OR              reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    AND             reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DO              reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    L_PAR           reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_INT         reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 51 (arrfunc -> L_BREAK exp R_BREAK empty .)


state 262

    (80) conditional -> WHILE L_PAR exp R_PAR DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 279


state 263

    (83) nonconditionalF -> exp TO exp . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 280


state 264

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON . empty
    (114) empty -> .

    CLASS           reduce using rule 114 (empty -> .)
    VARS            reduce using rule 114 (empty -> .)
    MAIN            reduce using rule 114 (empty -> .)
    INT             reduce using rule 114 (empty -> .)
    FLOAT           reduce using rule 114 (empty -> .)
    CHAR            reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    VOID            reduce using rule 114 (empty -> .)

    empty                          shift and go to state 281

state 265

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 282


state 266

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (114) empty -> .

    MAIN            reduce using rule 114 (empty -> .)
    INT             reduce using rule 114 (empty -> .)
    FLOAT           reduce using rule 114 (empty -> .)
    CHAR            reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    VOID            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)

    empty                          shift and go to state 283

state 267

    (94) expf -> ex empty .

    ID              reduce using rule 94 (expf -> ex empty .)
    RETURN          reduce using rule 94 (expf -> ex empty .)
    READ            reduce using rule 94 (expf -> ex empty .)
    WRITE           reduce using rule 94 (expf -> ex empty .)
    IF              reduce using rule 94 (expf -> ex empty .)
    VAR             reduce using rule 94 (expf -> ex empty .)
    WHILE           reduce using rule 94 (expf -> ex empty .)
    FROM            reduce using rule 94 (expf -> ex empty .)
    R_CURPAR        reduce using rule 94 (expf -> ex empty .)
    SEMICOLON       reduce using rule 94 (expf -> ex empty .)
    R_PAR           reduce using rule 94 (expf -> ex empty .)
    COMMA           reduce using rule 94 (expf -> ex empty .)
    R_BREAK         reduce using rule 94 (expf -> ex empty .)
    TO              reduce using rule 94 (expf -> ex empty .)
    DO              reduce using rule 94 (expf -> ex empty .)


state 268

    (95) expf -> ex bool . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 284

state 269

    (84) bool -> OR . exp empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 285
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 270

    (85) bool -> AND . exp empty
    (86) exp -> . ex expT
    (96) ex -> . term exF
    (100) term -> . factor termF
    (104) factor -> . L_PAR exp R_PAR empty
    (105) factor -> . factorT
    (106) factorT -> . PLUS factorF
    (107) factorT -> . MINUS factorF
    (108) factorT -> . factorF
    (109) factorF -> . varcte empty
    (110) varcte -> . var empty
    (111) varcte -> . CTE_INT empty
    (112) varcte -> . CTE_FLOAT empty
    (113) varcte -> . CTE_CHAR empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 145
    PLUS            shift and go to state 147
    MINUS           shift and go to state 149
    CTE_INT         shift and go to state 152
    CTE_FLOAT       shift and go to state 153
    CTE_CHAR        shift and go to state 154
    VAR             shift and go to state 87
    ID              shift and go to state 155

    exp                            shift and go to state 286
    ex                             shift and go to state 142
    term                           shift and go to state 143
    factor                         shift and go to state 144
    factorT                        shift and go to state 146
    factorF                        shift and go to state 148
    varcte                         shift and go to state 150
    var                            shift and go to state 151

state 271

    (104) factor -> L_PAR exp R_PAR empty .

    MULT            reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    DIV             reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    PLUS            reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    MINUS           reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    LESS            reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    GREATER         reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    LESS_TH         reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    GREAT_TH        reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    SAME            reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    DIF             reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    ID              reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    RETURN          reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    READ            reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    WRITE           reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    IF              reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    VAR             reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    WHILE           reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    FROM            reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    R_CURPAR        reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    SEMICOLON       reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    R_PAR           reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    COMMA           reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    R_BREAK         reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    TO              reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    OR              reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    AND             reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)
    DO              reduce using rule 104 (factor -> L_PAR exp R_PAR empty .)


state 272

    (48) void -> ID DOT ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 287


state 273

    (49) void -> ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)


state 274

    (55) return -> RETURN L_PAR exp R_PAR SEMICOLON empty .

    ID              reduce using rule 55 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 55 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    READ            reduce using rule 55 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 55 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    IF              reduce using rule 55 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    VAR             reduce using rule 55 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 55 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    FROM            reduce using rule 55 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 55 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 55 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)


state 275

    (62) readF -> var R_PAR SEMICOLON empty .

    ID              reduce using rule 62 (readF -> var R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 62 (readF -> var R_PAR SEMICOLON empty .)
    READ            reduce using rule 62 (readF -> var R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 62 (readF -> var R_PAR SEMICOLON empty .)
    IF              reduce using rule 62 (readF -> var R_PAR SEMICOLON empty .)
    VAR             reduce using rule 62 (readF -> var R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 62 (readF -> var R_PAR SEMICOLON empty .)
    FROM            reduce using rule 62 (readF -> var R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 62 (readF -> var R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 62 (readF -> var R_PAR SEMICOLON empty .)


state 276

    (67) writeF -> R_PAR SEMICOLON empty .

    ID              reduce using rule 67 (writeF -> R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 67 (writeF -> R_PAR SEMICOLON empty .)
    READ            reduce using rule 67 (writeF -> R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 67 (writeF -> R_PAR SEMICOLON empty .)
    IF              reduce using rule 67 (writeF -> R_PAR SEMICOLON empty .)
    VAR             reduce using rule 67 (writeF -> R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 67 (writeF -> R_PAR SEMICOLON empty .)
    FROM            reduce using rule 67 (writeF -> R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 67 (writeF -> R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 67 (writeF -> R_PAR SEMICOLON empty .)


state 277

    (70) if -> IF L_PAR exp R_PAR THEN L_CURPAR . statement SEMICOLON R_CURPAR ifF
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    statement                      shift and go to state 288
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 278

    (50) arrfunc -> L_BREAK exp COMMA exp R_BREAK . empty
    (114) empty -> .

    EQUAL           reduce using rule 114 (empty -> .)
    PLUS_EQ         reduce using rule 114 (empty -> .)
    MIN_EQ          reduce using rule 114 (empty -> .)
    MULT_EQ         reduce using rule 114 (empty -> .)
    DIV_EQ          reduce using rule 114 (empty -> .)
    MULT            reduce using rule 114 (empty -> .)
    DIV             reduce using rule 114 (empty -> .)
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    LESS            reduce using rule 114 (empty -> .)
    GREATER         reduce using rule 114 (empty -> .)
    LESS_TH         reduce using rule 114 (empty -> .)
    GREAT_TH        reduce using rule 114 (empty -> .)
    SAME            reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    OR              reduce using rule 114 (empty -> .)
    AND             reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)
    L_PAR           reduce using rule 114 (empty -> .)
    CTE_INT         reduce using rule 114 (empty -> .)
    CTE_FLOAT       reduce using rule 114 (empty -> .)
    CTE_CHAR        reduce using rule 114 (empty -> .)

    empty                          shift and go to state 289

state 279

    (80) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    statement                      shift and go to state 290
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 280

    (83) nonconditionalF -> exp TO exp DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 291


state 281

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .

    CLASS           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VARS            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    MAIN            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    INT             reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    FLOAT           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    CHAR            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    ID              reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VOID            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)


state 282

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (114) empty -> .

    MAIN            reduce using rule 114 (empty -> .)
    INT             reduce using rule 114 (empty -> .)
    FLOAT           reduce using rule 114 (empty -> .)
    CHAR            reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    VOID            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)

    empty                          shift and go to state 292

state 283

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 284

    (95) expf -> ex bool empty .

    ID              reduce using rule 95 (expf -> ex bool empty .)
    RETURN          reduce using rule 95 (expf -> ex bool empty .)
    READ            reduce using rule 95 (expf -> ex bool empty .)
    WRITE           reduce using rule 95 (expf -> ex bool empty .)
    IF              reduce using rule 95 (expf -> ex bool empty .)
    VAR             reduce using rule 95 (expf -> ex bool empty .)
    WHILE           reduce using rule 95 (expf -> ex bool empty .)
    FROM            reduce using rule 95 (expf -> ex bool empty .)
    R_CURPAR        reduce using rule 95 (expf -> ex bool empty .)
    SEMICOLON       reduce using rule 95 (expf -> ex bool empty .)
    R_PAR           reduce using rule 95 (expf -> ex bool empty .)
    COMMA           reduce using rule 95 (expf -> ex bool empty .)
    R_BREAK         reduce using rule 95 (expf -> ex bool empty .)
    TO              reduce using rule 95 (expf -> ex bool empty .)
    DO              reduce using rule 95 (expf -> ex bool empty .)


state 285

    (84) bool -> OR exp . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 293

state 286

    (85) bool -> AND exp . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)
    R_PAR           reduce using rule 114 (empty -> .)
    COMMA           reduce using rule 114 (empty -> .)
    R_BREAK         reduce using rule 114 (empty -> .)
    TO              reduce using rule 114 (empty -> .)
    DO              reduce using rule 114 (empty -> .)

    empty                          shift and go to state 294

state 287

    (48) void -> ID DOT ID L_PAR param R_PAR SEMICOLON . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 295

state 288

    (70) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement . SEMICOLON R_CURPAR ifF

    SEMICOLON       shift and go to state 296


state 289

    (50) arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .

    EQUAL           reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MIN_EQ          reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT_EQ         reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV_EQ          reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT            reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV             reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS            reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MINUS           reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS            reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREATER         reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS_TH         reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREAT_TH        reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SAME            reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIF             reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    ID              reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    RETURN          reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    READ            reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WRITE           reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    IF              reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    VAR             reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WHILE           reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    FROM            reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_CURPAR        reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SEMICOLON       reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    COMMA           reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_PAR           reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_BREAK         reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    TO              reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    OR              reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    AND             reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DO              reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    L_PAR           reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_INT         reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 50 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)


state 290

    (80) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 297


state 291

    (83) nonconditionalF -> exp TO exp DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    statement                      shift and go to state 298
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 292

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 293

    (84) bool -> OR exp empty .

    ID              reduce using rule 84 (bool -> OR exp empty .)
    RETURN          reduce using rule 84 (bool -> OR exp empty .)
    READ            reduce using rule 84 (bool -> OR exp empty .)
    WRITE           reduce using rule 84 (bool -> OR exp empty .)
    IF              reduce using rule 84 (bool -> OR exp empty .)
    VAR             reduce using rule 84 (bool -> OR exp empty .)
    WHILE           reduce using rule 84 (bool -> OR exp empty .)
    FROM            reduce using rule 84 (bool -> OR exp empty .)
    R_CURPAR        reduce using rule 84 (bool -> OR exp empty .)
    SEMICOLON       reduce using rule 84 (bool -> OR exp empty .)
    R_PAR           reduce using rule 84 (bool -> OR exp empty .)
    COMMA           reduce using rule 84 (bool -> OR exp empty .)
    R_BREAK         reduce using rule 84 (bool -> OR exp empty .)
    TO              reduce using rule 84 (bool -> OR exp empty .)
    DO              reduce using rule 84 (bool -> OR exp empty .)


state 294

    (85) bool -> AND exp empty .

    ID              reduce using rule 85 (bool -> AND exp empty .)
    RETURN          reduce using rule 85 (bool -> AND exp empty .)
    READ            reduce using rule 85 (bool -> AND exp empty .)
    WRITE           reduce using rule 85 (bool -> AND exp empty .)
    IF              reduce using rule 85 (bool -> AND exp empty .)
    VAR             reduce using rule 85 (bool -> AND exp empty .)
    WHILE           reduce using rule 85 (bool -> AND exp empty .)
    FROM            reduce using rule 85 (bool -> AND exp empty .)
    R_CURPAR        reduce using rule 85 (bool -> AND exp empty .)
    SEMICOLON       reduce using rule 85 (bool -> AND exp empty .)
    R_PAR           reduce using rule 85 (bool -> AND exp empty .)
    COMMA           reduce using rule 85 (bool -> AND exp empty .)
    R_BREAK         reduce using rule 85 (bool -> AND exp empty .)
    TO              reduce using rule 85 (bool -> AND exp empty .)
    DO              reduce using rule 85 (bool -> AND exp empty .)


state 295

    (48) void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)


state 296

    (70) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON . R_CURPAR ifF

    R_CURPAR        shift and go to state 299


state 297

    (80) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 300


state 298

    (83) nonconditionalF -> exp TO exp DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 301


state 299

    (70) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR . ifF
    (71) ifF -> . ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
    (72) ifF -> . empty
    (114) empty -> .

    ELSE            shift and go to state 303
    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    ifF                            shift and go to state 302
    empty                          shift and go to state 304

state 300

    (80) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 305

state 301

    (83) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 306


state 302

    (70) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .

    ID              reduce using rule 70 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    RETURN          reduce using rule 70 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    READ            reduce using rule 70 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WRITE           reduce using rule 70 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    IF              reduce using rule 70 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    VAR             reduce using rule 70 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WHILE           reduce using rule 70 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    FROM            reduce using rule 70 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    R_CURPAR        reduce using rule 70 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    SEMICOLON       reduce using rule 70 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)


state 303

    (71) ifF -> ELSE . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 307


state 304

    (72) ifF -> empty .

    ID              reduce using rule 72 (ifF -> empty .)
    RETURN          reduce using rule 72 (ifF -> empty .)
    READ            reduce using rule 72 (ifF -> empty .)
    WRITE           reduce using rule 72 (ifF -> empty .)
    IF              reduce using rule 72 (ifF -> empty .)
    VAR             reduce using rule 72 (ifF -> empty .)
    WHILE           reduce using rule 72 (ifF -> empty .)
    FROM            reduce using rule 72 (ifF -> empty .)
    R_CURPAR        reduce using rule 72 (ifF -> empty .)
    SEMICOLON       reduce using rule 72 (ifF -> empty .)


state 305

    (80) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 80 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 80 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 80 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 80 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 80 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 80 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 80 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 80 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 80 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 80 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 306

    (83) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 308

state 307

    (71) ifF -> ELSE L_CURPAR . statement SEMICOLON R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (73) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (55) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (60) read -> . READ L_PAR readF
    (63) write -> . WRITE L_PAR writeT
    (70) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (68) repeat -> . conditional empty
    (69) repeat -> . nonconditional empty
    (56) var -> . VAR varF
    (57) var -> . ID DOT VAR varF
    (80) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (81) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (82) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 80
    RETURN          shift and go to state 81
    READ            shift and go to state 82
    WRITE           shift and go to state 83
    IF              shift and go to state 84
    VAR             shift and go to state 87
    WHILE           shift and go to state 88
    FROM            shift and go to state 89

    statement                      shift and go to state 309
    assigment                      shift and go to state 72
    void                           shift and go to state 73
    return                         shift and go to state 74
    read                           shift and go to state 75
    write                          shift and go to state 76
    if                             shift and go to state 77
    repeat                         shift and go to state 78
    var                            shift and go to state 79
    conditional                    shift and go to state 85
    nonconditional                 shift and go to state 86

state 308

    (83) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 83 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 83 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 83 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 83 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 83 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 83 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 83 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 83 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 83 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 83 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 309

    (71) ifF -> ELSE L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 310


state 310

    (71) ifF -> ELSE L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 311


state 311

    (71) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR . empty
    (114) empty -> .

    ID              reduce using rule 114 (empty -> .)
    RETURN          reduce using rule 114 (empty -> .)
    READ            reduce using rule 114 (empty -> .)
    WRITE           reduce using rule 114 (empty -> .)
    IF              reduce using rule 114 (empty -> .)
    VAR             reduce using rule 114 (empty -> .)
    WHILE           reduce using rule 114 (empty -> .)
    FROM            reduce using rule 114 (empty -> .)
    R_CURPAR        reduce using rule 114 (empty -> .)
    SEMICOLON       reduce using rule 114 (empty -> .)

    empty                          shift and go to state 312

state 312

    (71) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 71 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 71 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 71 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 71 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 71 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 71 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 71 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 71 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 71 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 71 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 169 resolved as shift
WARNING: shift/reduce conflict for R_PAR in state 169 resolved as shift
