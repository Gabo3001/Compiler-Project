Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM np_startProg ID np_addFunc SEMICOLON programT
Rule 2     programT -> class programT
Rule 3     programT -> vars programF
Rule 4     programT -> programF
Rule 5     programF -> func programF
Rule 6     programF -> main np_endProg empty
Rule 7     class -> CLASS ID classT
Rule 8     classT -> LESS INHERIT ID GREATER classF
Rule 9     classT -> classF
Rule 10    classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty
Rule 11    vars -> VARS dec empty
Rule 12    dec -> VAR arr np_getDecArr decF
Rule 13    dec -> VAR np_getDec decF
Rule 14    decF -> COMMA dec
Rule 15    decF -> COLON type np_getVarType SEMICOLON np_getDec dec
Rule 16    decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty
Rule 17    type -> INT empty
Rule 18    type -> FLOAT empty
Rule 19    type -> CHAR empty
Rule 20    type -> BOOL empty
Rule 21    type -> ID empty
Rule 22    arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
Rule 23    arr -> L_BREAK CTE_INT R_BREAK empty
Rule 24    func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF
Rule 25    funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty
Rule 26    funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty
Rule 27    typeFunc -> INT empty
Rule 28    typeFunc -> FLOAT empty
Rule 29    typeFunc -> CHAR empty
Rule 30    typeFunc -> BOOL empty
Rule 31    typeFunc -> ID empty
Rule 32    typeFunc -> VOID empty
Rule 33    parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec np_addToDic parameterF
Rule 34    parameterF -> parameter
Rule 35    parameterF -> empty
Rule 36    typepar -> INT empty
Rule 37    typepar -> FLOAT empty
Rule 38    typepar -> CHAR empty
Rule 39    typepar -> BOOL empty
Rule 40    typepar -> ID empty
Rule 41    main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
Rule 42    statement -> assigment SEMICOLON statementF
Rule 43    statement -> void SEMICOLON statementF
Rule 44    statement -> return SEMICOLON statementF
Rule 45    statement -> read SEMICOLON statementF
Rule 46    statement -> write SEMICOLON statementF
Rule 47    statement -> if statementF
Rule 48    statement -> repeat statementF
Rule 49    statementF -> statement
Rule 50    statementF -> empty
Rule 51    void -> ID DOT ID L_PAR voidT
Rule 52    void -> ID np_checkVoid L_PAR np_eraQuad voidT
Rule 53    voidT -> exp np_checkParam COMMA voidT
Rule 54    voidT -> exp np_checkParam voidF
Rule 55    voidT -> voidF
Rule 56    voidF -> R_PAR np_endVoid empty
Rule 57    arrfunc -> L_BREAK exp COMMA exp R_BREAK empty
Rule 58    arrfunc -> L_BREAK exp R_BREAK empty
Rule 59    return -> RETURN L_PAR exp np_addReturn R_PAR empty
Rule 60    var -> VAR varF
Rule 61    var -> ID DOT VAR varF
Rule 62    varF -> arrfunc empty
Rule 63    varF -> empty
Rule 64    read -> READ L_PAR readF
Rule 65    readF -> var np_addRead COMMA readF
Rule 66    readF -> var np_addRead R_PAR empty
Rule 67    write -> WRITE L_PAR writeT
Rule 68    writeT -> CTE_STRING np_addConstString writeF
Rule 69    writeT -> exp writeF
Rule 70    writeF -> COMMA np_addWrite writeT
Rule 71    writeF -> R_PAR np_addWrite empty
Rule 72    repeat -> conditional empty
Rule 73    repeat -> nonconditional empty
Rule 74    if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
Rule 75    ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty
Rule 76    ifF -> np_endIf empty
Rule 77    assigment -> var np_addId assigmentF
Rule 78    assigmentF -> EQUAL np_addOp exp np_doAssign empty
Rule 79    assigmentF -> ope np_addOp exp np_doAssign empty
Rule 80    ope -> PLUS_EQ empty
Rule 81    ope -> MIN_EQ empty
Rule 82    ope -> MULT_EQ empty
Rule 83    ope -> DIV_EQ empty
Rule 84    conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
Rule 85    nonconditional -> FROM VAR arrfunc nonconditionalF
Rule 86    nonconditional -> FROM VAR np_addId nonconditionalF
Rule 87    nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
Rule 88    bool -> logical np_addBool boolF
Rule 89    boolF -> OR np_addOp bool
Rule 90    boolF -> AND np_addOp bool
Rule 91    boolF -> empty
Rule 92    logical -> ex np_addLogical logicalF
Rule 93    logicalF -> LESS np_addOp logical
Rule 94    logicalF -> GREATER np_addOp logical
Rule 95    logicalF -> LESS_TH np_addOp logical
Rule 96    logicalF -> GREAT_TH np_addOp logical
Rule 97    logicalF -> SAME np_addOp logical
Rule 98    logicalF -> DIF np_addOp logical
Rule 99    logicalF -> empty
Rule 100   exp -> bool empty
Rule 101   ex -> term np_addEx exF
Rule 102   exF -> PLUS np_addOp ex
Rule 103   exF -> MINUS np_addOp ex
Rule 104   exF -> empty
Rule 105   term -> factor np_addTerm termF
Rule 106   termF -> MULT np_addOp term
Rule 107   termF -> DIV np_addOp term
Rule 108   termF -> empty
Rule 109   factor -> L_PAR np_addPar exp R_PAR np_popPar empty
Rule 110   factor -> varcte empty
Rule 111   factor -> factorF
Rule 112   factorF -> MINUS var np_addId empty
Rule 113   factorF -> var np_addId empty
Rule 114   varcte -> CTE_INT np_addConstInt empty
Rule 115   varcte -> CTE_FLOAT np_addConstFloat empty
Rule 116   varcte -> CTE_CHAR np_addConstChar empty
Rule 117   varcte -> CTE_BOOL np_addConstBool empty
Rule 118   empty -> <empty>
Rule 119   np_startProg -> <empty>
Rule 120   np_getMainFunc -> <empty>
Rule 121   np_addFunc -> <empty>
Rule 122   np_getDec -> <empty>
Rule 123   np_getDecArr -> <empty>
Rule 124   np_getVarType -> <empty>
Rule 125   np_addParam -> <empty>
Rule 126   np_addToDic -> <empty>
Rule 127   np_endFunc -> <empty>
Rule 128   np_addId -> <empty>
Rule 129   np_addConstInt -> <empty>
Rule 130   np_addConstFloat -> <empty>
Rule 131   np_addConstChar -> <empty>
Rule 132   np_addConstBool -> <empty>
Rule 133   np_addConstString -> <empty>
Rule 134   np_addOp -> <empty>
Rule 135   np_addPar -> <empty>
Rule 136   np_popPar -> <empty>
Rule 137   np_addTerm -> <empty>
Rule 138   np_addEx -> <empty>
Rule 139   np_addLogical -> <empty>
Rule 140   np_addBool -> <empty>
Rule 141   np_doAssign -> <empty>
Rule 142   np_addRead -> <empty>
Rule 143   np_addWrite -> <empty>
Rule 144   np_addReturn -> <empty>
Rule 145   np_checkBool -> <empty>
Rule 146   np_endIf -> <empty>
Rule 147   np_else -> <empty>
Rule 148   np_addWhile -> <empty>
Rule 149   np_endWhile -> <empty>
Rule 150   np_assingFor -> <empty>
Rule 151   np_checkExp -> <empty>
Rule 152   np_endFor -> <empty>
Rule 153   np_checkVoid -> <empty>
Rule 154   np_eraQuad -> <empty>
Rule 155   np_checkParam -> <empty>
Rule 156   np_endVoid -> <empty>
Rule 157   np_endProg -> <empty>

Terminals, with rules where they appear

AND                  : 90
ATTRIBUTES           : 10
BOOL                 : 20 30 39
CHAR                 : 19 29 38
CLASS                : 7
COLON                : 15 16 33
COMMA                : 14 22 53 57 65 70
CTE_BOOL             : 117
CTE_CHAR             : 116
CTE_FLOAT            : 115
CTE_INT              : 22 22 23 114
CTE_STRING           : 68
DIF                  : 98
DIV                  : 107
DIV_EQ               : 83
DO                   : 84 87
DOT                  : 51 61
ELSE                 : 75
EQUAL                : 78 87
FLOAT                : 18 28 37
FROM                 : 85 86
FUNCTION             : 24
GREATER              : 8 94
GREAT_TH             : 96
ID                   : 1 7 8 21 24 31 40 51 51 52 61
IF                   : 74
INHERIT              : 8
INT                  : 17 27 36
LESS                 : 8 93
LESS_TH              : 95
L_BREAK              : 22 23 57 58
L_CURPAR             : 10 25 26 41 74 75 84 87
L_PAR                : 24 41 51 52 59 64 67 74 84 109
MAIN                 : 41
METHODS              : 10
MINUS                : 103 112
MIN_EQ               : 81
MULT                 : 106
MULT_EQ              : 82
OR                   : 89
PLUS                 : 102
PLUS_EQ              : 80
PROGRAM              : 1
READ                 : 64
RETURN               : 59
R_BREAK              : 22 23 57 58
R_CURPAR             : 10 25 26 41 74 75 84 87
R_PAR                : 25 26 41 56 59 66 71 74 84 109
SAME                 : 97
SEMICOLON            : 1 10 10 15 16 25 26 33 42 43 44 45 46
THEN                 : 74
TO                   : 87
VAR                  : 12 13 33 60 61 85 86
VARS                 : 11
VOID                 : 32
WHILE                : 84
WRITE                : 67
error                : 

Nonterminals, with rules where they appear

arr                  : 12
arrfunc              : 62 85
assigment            : 42
assigmentF           : 77
bool                 : 89 90 100
boolF                : 88
class                : 2
classF               : 8 9
classT               : 7
conditional          : 72
dec                  : 10 11 14 15 25 26
decF                 : 12 13
empty                : 6 10 11 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 35 36 37 38 39 40 41 50 56 57 58 59 62 63 66 71 72 73 75 76 78 79 80 81 82 83 84 87 91 99 100 104 108 109 110 112 113 114 115 116 117
ex                   : 92 102 103
exF                  : 101
exp                  : 53 54 57 57 58 59 69 74 78 79 84 87 87 109
factor               : 105
factorF              : 111
func                 : 5 10
funcF                : 24
if                   : 47
ifF                  : 74
logical              : 88 93 94 95 96 97 98
logicalF             : 92
main                 : 6
nonconditional       : 73
nonconditionalF      : 85 86
np_addBool           : 88
np_addConstBool      : 117
np_addConstChar      : 116
np_addConstFloat     : 115
np_addConstInt       : 114
np_addConstString    : 68
np_addEx             : 101
np_addFunc           : 1 24
np_addId             : 77 86 112 113
np_addLogical        : 92
np_addOp             : 78 79 87 89 90 93 94 95 96 97 98 102 103 106 107
np_addPar            : 109
np_addParam          : 33
np_addRead           : 65 66
np_addReturn         : 59
np_addTerm           : 105
np_addToDic          : 16 33
np_addWhile          : 84
np_addWrite          : 70 71
np_assingFor         : 87
np_checkBool         : 74 84
np_checkExp          : 87
np_checkParam        : 53 54
np_checkVoid         : 52
np_doAssign          : 78 79
np_else              : 75
np_endFor            : 87
np_endFunc           : 25 26
np_endIf             : 75 76
np_endProg           : 6
np_endVoid           : 56
np_endWhile          : 84
np_eraQuad           : 52
np_getDec            : 13 15 16 33 33
np_getDecArr         : 12
np_getMainFunc       : 41
np_getVarType        : 15 16 33
np_popPar            : 109
np_startProg         : 1
ope                  : 79
parameter            : 25 34
parameterF           : 33
program              : 0
programF             : 3 4 5
programT             : 1 2
read                 : 45
readF                : 64 65
repeat               : 48
return               : 44
statement            : 25 26 41 49 74 75 84 87
statementF           : 42 43 44 45 46 47 48
term                 : 101 106 107
termF                : 105
type                 : 15 16
typeFunc             : 24
typepar              : 33
var                  : 65 66 77 112 113
varF                 : 60 61
varcte               : 110
vars                 : 3
void                 : 43
voidF                : 54 55
voidT                : 51 52 53
write                : 46
writeF               : 68 69
writeT               : 67 70

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM np_startProg ID np_addFunc SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . np_startProg ID np_addFunc SEMICOLON programT
    (119) np_startProg -> .

    ID              reduce using rule 119 (np_startProg -> .)

    np_startProg                   shift and go to state 3

state 3

    (1) program -> PROGRAM np_startProg . ID np_addFunc SEMICOLON programT

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM np_startProg ID . np_addFunc SEMICOLON programT
    (121) np_addFunc -> .

    SEMICOLON       reduce using rule 121 (np_addFunc -> .)

    np_addFunc                     shift and go to state 5

state 5

    (1) program -> PROGRAM np_startProg ID np_addFunc . SEMICOLON programT

    SEMICOLON       shift and go to state 6


state 6

    (1) program -> PROGRAM np_startProg ID np_addFunc SEMICOLON . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main np_endProg empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 12
    VARS            shift and go to state 13
    MAIN            shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21
    ID              shift and go to state 7
    VOID            shift and go to state 22

    programT                       shift and go to state 8
    class                          shift and go to state 9
    vars                           shift and go to state 10
    programF                       shift and go to state 11
    func                           shift and go to state 14
    main                           shift and go to state 15
    typeFunc                       shift and go to state 16

state 7

    (31) typeFunc -> ID . empty
    (118) empty -> .

    FUNCTION        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 23

state 8

    (1) program -> PROGRAM np_startProg ID np_addFunc SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM np_startProg ID np_addFunc SEMICOLON programT .)


state 9

    (2) programT -> class . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main np_endProg empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 12
    VARS            shift and go to state 13
    MAIN            shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21
    ID              shift and go to state 7
    VOID            shift and go to state 22

    class                          shift and go to state 9
    programT                       shift and go to state 24
    vars                           shift and go to state 10
    programF                       shift and go to state 11
    func                           shift and go to state 14
    main                           shift and go to state 15
    typeFunc                       shift and go to state 16

state 10

    (3) programT -> vars . programF
    (5) programF -> . func programF
    (6) programF -> . main np_endProg empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21
    ID              shift and go to state 7
    VOID            shift and go to state 22

    programF                       shift and go to state 25
    func                           shift and go to state 14
    main                           shift and go to state 15
    typeFunc                       shift and go to state 16

state 11

    (4) programT -> programF .

    $end            reduce using rule 4 (programT -> programF .)


state 12

    (7) class -> CLASS . ID classT

    ID              shift and go to state 26


state 13

    (11) vars -> VARS . dec empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 28

    dec                            shift and go to state 27

state 14

    (5) programF -> func . programF
    (5) programF -> . func programF
    (6) programF -> . main np_endProg empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21
    ID              shift and go to state 7
    VOID            shift and go to state 22

    func                           shift and go to state 14
    programF                       shift and go to state 29
    main                           shift and go to state 15
    typeFunc                       shift and go to state 16

state 15

    (6) programF -> main . np_endProg empty
    (157) np_endProg -> .

    $end            reduce using rule 157 (np_endProg -> .)

    np_endProg                     shift and go to state 30

state 16

    (24) func -> typeFunc . FUNCTION ID np_addFunc L_PAR funcF

    FUNCTION        shift and go to state 31


state 17

    (41) main -> MAIN . np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (120) np_getMainFunc -> .

    L_PAR           reduce using rule 120 (np_getMainFunc -> .)

    np_getMainFunc                 shift and go to state 32

state 18

    (27) typeFunc -> INT . empty
    (118) empty -> .

    FUNCTION        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 33

state 19

    (28) typeFunc -> FLOAT . empty
    (118) empty -> .

    FUNCTION        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 34

state 20

    (29) typeFunc -> CHAR . empty
    (118) empty -> .

    FUNCTION        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 35

state 21

    (30) typeFunc -> BOOL . empty
    (118) empty -> .

    FUNCTION        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 36

state 22

    (32) typeFunc -> VOID . empty
    (118) empty -> .

    FUNCTION        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 37

state 23

    (31) typeFunc -> ID empty .

    FUNCTION        reduce using rule 31 (typeFunc -> ID empty .)


state 24

    (2) programT -> class programT .

    $end            reduce using rule 2 (programT -> class programT .)


state 25

    (3) programT -> vars programF .

    $end            reduce using rule 3 (programT -> vars programF .)


state 26

    (7) class -> CLASS ID . classT
    (8) classT -> . LESS INHERIT ID GREATER classF
    (9) classT -> . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    LESS            shift and go to state 39
    SEMICOLON       shift and go to state 41

    classT                         shift and go to state 38
    classF                         shift and go to state 40

state 27

    (11) vars -> VARS dec . empty
    (118) empty -> .

    MAIN            reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    CHAR            reduce using rule 118 (empty -> .)
    BOOL            reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)

    empty                          shift and go to state 42

state 28

    (12) dec -> VAR . arr np_getDecArr decF
    (13) dec -> VAR . np_getDec decF
    (22) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> . L_BREAK CTE_INT R_BREAK empty
    (122) np_getDec -> .

    L_BREAK         shift and go to state 45
    COMMA           reduce using rule 122 (np_getDec -> .)
    COLON           reduce using rule 122 (np_getDec -> .)

    arr                            shift and go to state 43
    np_getDec                      shift and go to state 44

state 29

    (5) programF -> func programF .

    $end            reduce using rule 5 (programF -> func programF .)


state 30

    (6) programF -> main np_endProg . empty
    (118) empty -> .

    $end            reduce using rule 118 (empty -> .)

    empty                          shift and go to state 46

state 31

    (24) func -> typeFunc FUNCTION . ID np_addFunc L_PAR funcF

    ID              shift and go to state 47


state 32

    (41) main -> MAIN np_getMainFunc . L_PAR R_PAR L_CURPAR statement R_CURPAR empty

    L_PAR           shift and go to state 48


state 33

    (27) typeFunc -> INT empty .

    FUNCTION        reduce using rule 27 (typeFunc -> INT empty .)


state 34

    (28) typeFunc -> FLOAT empty .

    FUNCTION        reduce using rule 28 (typeFunc -> FLOAT empty .)


state 35

    (29) typeFunc -> CHAR empty .

    FUNCTION        reduce using rule 29 (typeFunc -> CHAR empty .)


state 36

    (30) typeFunc -> BOOL empty .

    FUNCTION        reduce using rule 30 (typeFunc -> BOOL empty .)


state 37

    (32) typeFunc -> VOID empty .

    FUNCTION        reduce using rule 32 (typeFunc -> VOID empty .)


state 38

    (7) class -> CLASS ID classT .

    CLASS           reduce using rule 7 (class -> CLASS ID classT .)
    VARS            reduce using rule 7 (class -> CLASS ID classT .)
    MAIN            reduce using rule 7 (class -> CLASS ID classT .)
    INT             reduce using rule 7 (class -> CLASS ID classT .)
    FLOAT           reduce using rule 7 (class -> CLASS ID classT .)
    CHAR            reduce using rule 7 (class -> CLASS ID classT .)
    BOOL            reduce using rule 7 (class -> CLASS ID classT .)
    ID              reduce using rule 7 (class -> CLASS ID classT .)
    VOID            reduce using rule 7 (class -> CLASS ID classT .)


state 39

    (8) classT -> LESS . INHERIT ID GREATER classF

    INHERIT         shift and go to state 49


state 40

    (9) classT -> classF .

    CLASS           reduce using rule 9 (classT -> classF .)
    VARS            reduce using rule 9 (classT -> classF .)
    MAIN            reduce using rule 9 (classT -> classF .)
    INT             reduce using rule 9 (classT -> classF .)
    FLOAT           reduce using rule 9 (classT -> classF .)
    CHAR            reduce using rule 9 (classT -> classF .)
    BOOL            reduce using rule 9 (classT -> classF .)
    ID              reduce using rule 9 (classT -> classF .)
    VOID            reduce using rule 9 (classT -> classF .)


state 41

    (10) classF -> SEMICOLON . L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    L_CURPAR        shift and go to state 50


state 42

    (11) vars -> VARS dec empty .

    MAIN            reduce using rule 11 (vars -> VARS dec empty .)
    INT             reduce using rule 11 (vars -> VARS dec empty .)
    FLOAT           reduce using rule 11 (vars -> VARS dec empty .)
    CHAR            reduce using rule 11 (vars -> VARS dec empty .)
    BOOL            reduce using rule 11 (vars -> VARS dec empty .)
    ID              reduce using rule 11 (vars -> VARS dec empty .)
    VOID            reduce using rule 11 (vars -> VARS dec empty .)


state 43

    (12) dec -> VAR arr . np_getDecArr decF
    (123) np_getDecArr -> .

    COMMA           reduce using rule 123 (np_getDecArr -> .)
    COLON           reduce using rule 123 (np_getDecArr -> .)

    np_getDecArr                   shift and go to state 51

state 44

    (13) dec -> VAR np_getDec . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 53
    COLON           shift and go to state 54

    decF                           shift and go to state 52

state 45

    (22) arr -> L_BREAK . CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 55


state 46

    (6) programF -> main np_endProg empty .

    $end            reduce using rule 6 (programF -> main np_endProg empty .)


state 47

    (24) func -> typeFunc FUNCTION ID . np_addFunc L_PAR funcF
    (121) np_addFunc -> .

    L_PAR           reduce using rule 121 (np_addFunc -> .)

    np_addFunc                     shift and go to state 56

state 48

    (41) main -> MAIN np_getMainFunc L_PAR . R_PAR L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 57


state 49

    (8) classT -> LESS INHERIT . ID GREATER classF

    ID              shift and go to state 58


state 50

    (10) classF -> SEMICOLON L_CURPAR . ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    ATTRIBUTES      shift and go to state 59


state 51

    (12) dec -> VAR arr np_getDecArr . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 53
    COLON           shift and go to state 54

    decF                           shift and go to state 60

state 52

    (13) dec -> VAR np_getDec decF .

    MAIN            reduce using rule 13 (dec -> VAR np_getDec decF .)
    INT             reduce using rule 13 (dec -> VAR np_getDec decF .)
    FLOAT           reduce using rule 13 (dec -> VAR np_getDec decF .)
    CHAR            reduce using rule 13 (dec -> VAR np_getDec decF .)
    BOOL            reduce using rule 13 (dec -> VAR np_getDec decF .)
    ID              reduce using rule 13 (dec -> VAR np_getDec decF .)
    VOID            reduce using rule 13 (dec -> VAR np_getDec decF .)
    METHODS         reduce using rule 13 (dec -> VAR np_getDec decF .)
    L_CURPAR        reduce using rule 13 (dec -> VAR np_getDec decF .)


state 53

    (14) decF -> COMMA . dec
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 28

    dec                            shift and go to state 61

state 54

    (15) decF -> COLON . type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON . type np_getVarType SEMICOLON np_getDec np_addToDic empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . BOOL empty
    (21) type -> . ID empty

    INT             shift and go to state 63
    FLOAT           shift and go to state 64
    CHAR            shift and go to state 65
    BOOL            shift and go to state 66
    ID              shift and go to state 67

    type                           shift and go to state 62

state 55

    (22) arr -> L_BREAK CTE_INT . COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK CTE_INT . R_BREAK empty

    COMMA           shift and go to state 68
    R_BREAK         shift and go to state 69


state 56

    (24) func -> typeFunc FUNCTION ID np_addFunc . L_PAR funcF

    L_PAR           shift and go to state 70


state 57

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 71


state 58

    (8) classT -> LESS INHERIT ID . GREATER classF

    GREATER         shift and go to state 72


state 59

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES . dec METHODS func R_CURPAR SEMICOLON empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 28

    dec                            shift and go to state 73

state 60

    (12) dec -> VAR arr np_getDecArr decF .

    MAIN            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    INT             reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    FLOAT           reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    CHAR            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    BOOL            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    ID              reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    VOID            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    METHODS         reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    L_CURPAR        reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)


state 61

    (14) decF -> COMMA dec .

    MAIN            reduce using rule 14 (decF -> COMMA dec .)
    INT             reduce using rule 14 (decF -> COMMA dec .)
    FLOAT           reduce using rule 14 (decF -> COMMA dec .)
    CHAR            reduce using rule 14 (decF -> COMMA dec .)
    BOOL            reduce using rule 14 (decF -> COMMA dec .)
    ID              reduce using rule 14 (decF -> COMMA dec .)
    VOID            reduce using rule 14 (decF -> COMMA dec .)
    METHODS         reduce using rule 14 (decF -> COMMA dec .)
    L_CURPAR        reduce using rule 14 (decF -> COMMA dec .)


state 62

    (15) decF -> COLON type . np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON type . np_getVarType SEMICOLON np_getDec np_addToDic empty
    (124) np_getVarType -> .

    SEMICOLON       reduce using rule 124 (np_getVarType -> .)

    np_getVarType                  shift and go to state 74

state 63

    (17) type -> INT . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 75

state 64

    (18) type -> FLOAT . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 76

state 65

    (19) type -> CHAR . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 77

state 66

    (20) type -> BOOL . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 78

state 67

    (21) type -> ID . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 79

state 68

    (22) arr -> L_BREAK CTE_INT COMMA . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 80


state 69

    (23) arr -> L_BREAK CTE_INT R_BREAK . empty
    (118) empty -> .

    COMMA           reduce using rule 118 (empty -> .)
    COLON           reduce using rule 118 (empty -> .)

    empty                          shift and go to state 81

state 70

    (24) func -> typeFunc FUNCTION ID np_addFunc L_PAR . funcF
    (25) funcF -> . parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty
    (26) funcF -> . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty
    (33) parameter -> . VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec np_addToDic parameterF

    R_PAR           shift and go to state 84
    VAR             shift and go to state 85

    funcF                          shift and go to state 82
    parameter                      shift and go to state 83

state 71

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    statement                      shift and go to state 86
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 72

    (8) classT -> LESS INHERIT ID GREATER . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    SEMICOLON       shift and go to state 41

    classF                         shift and go to state 105

state 73

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec . METHODS func R_CURPAR SEMICOLON empty

    METHODS         shift and go to state 106


state 74

    (15) decF -> COLON type np_getVarType . SEMICOLON np_getDec dec
    (16) decF -> COLON type np_getVarType . SEMICOLON np_getDec np_addToDic empty

    SEMICOLON       shift and go to state 107


state 75

    (17) type -> INT empty .

    SEMICOLON       reduce using rule 17 (type -> INT empty .)


state 76

    (18) type -> FLOAT empty .

    SEMICOLON       reduce using rule 18 (type -> FLOAT empty .)


state 77

    (19) type -> CHAR empty .

    SEMICOLON       reduce using rule 19 (type -> CHAR empty .)


state 78

    (20) type -> BOOL empty .

    SEMICOLON       reduce using rule 20 (type -> BOOL empty .)


state 79

    (21) type -> ID empty .

    SEMICOLON       reduce using rule 21 (type -> ID empty .)


state 80

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT . R_BREAK empty

    R_BREAK         shift and go to state 108


state 81

    (23) arr -> L_BREAK CTE_INT R_BREAK empty .

    COMMA           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    COLON           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)


state 82

    (24) func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .

    MAIN            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    INT             reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    FLOAT           reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    CHAR            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    BOOL            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    ID              reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    VOID            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    R_CURPAR        reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)


state 83

    (25) funcF -> parameter . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty

    R_PAR           shift and go to state 109


state 84

    (26) funcF -> R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty

    SEMICOLON       shift and go to state 110


state 85

    (33) parameter -> VAR . np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec np_addToDic parameterF
    (122) np_getDec -> .

    COLON           reduce using rule 122 (np_getDec -> .)

    np_getDec                      shift and go to state 111

state 86

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 112


state 87

    (42) statement -> assigment . SEMICOLON statementF

    SEMICOLON       shift and go to state 113


state 88

    (43) statement -> void . SEMICOLON statementF

    SEMICOLON       shift and go to state 114


state 89

    (44) statement -> return . SEMICOLON statementF

    SEMICOLON       shift and go to state 115


state 90

    (45) statement -> read . SEMICOLON statementF

    SEMICOLON       shift and go to state 116


state 91

    (46) statement -> write . SEMICOLON statementF

    SEMICOLON       shift and go to state 117


state 92

    (47) statement -> if . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (118) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 118 (empty -> .)
    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    if                             shift and go to state 92
    statementF                     shift and go to state 118
    statement                      shift and go to state 119
    empty                          shift and go to state 120
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 93

    (48) statement -> repeat . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (118) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 118 (empty -> .)
    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    repeat                         shift and go to state 93
    statementF                     shift and go to state 121
    statement                      shift and go to state 119
    empty                          shift and go to state 120
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 94

    (77) assigment -> var . np_addId assigmentF
    (128) np_addId -> .

    EQUAL           reduce using rule 128 (np_addId -> .)
    PLUS_EQ         reduce using rule 128 (np_addId -> .)
    MIN_EQ          reduce using rule 128 (np_addId -> .)
    MULT_EQ         reduce using rule 128 (np_addId -> .)
    DIV_EQ          reduce using rule 128 (np_addId -> .)

    np_addId                       shift and go to state 122

state 95

    (51) void -> ID . DOT ID L_PAR voidT
    (52) void -> ID . np_checkVoid L_PAR np_eraQuad voidT
    (61) var -> ID . DOT VAR varF
    (153) np_checkVoid -> .

    DOT             shift and go to state 123
    L_PAR           reduce using rule 153 (np_checkVoid -> .)

    np_checkVoid                   shift and go to state 124

state 96

    (59) return -> RETURN . L_PAR exp np_addReturn R_PAR empty

    L_PAR           shift and go to state 125


state 97

    (64) read -> READ . L_PAR readF

    L_PAR           shift and go to state 126


state 98

    (67) write -> WRITE . L_PAR writeT

    L_PAR           shift and go to state 127


state 99

    (74) if -> IF . L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF

    L_PAR           shift and go to state 128


state 100

    (72) repeat -> conditional . empty
    (118) empty -> .

    ID              reduce using rule 118 (empty -> .)
    RETURN          reduce using rule 118 (empty -> .)
    READ            reduce using rule 118 (empty -> .)
    WRITE           reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    VAR             reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FROM            reduce using rule 118 (empty -> .)
    R_CURPAR        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 129

state 101

    (73) repeat -> nonconditional . empty
    (118) empty -> .

    ID              reduce using rule 118 (empty -> .)
    RETURN          reduce using rule 118 (empty -> .)
    READ            reduce using rule 118 (empty -> .)
    WRITE           reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    VAR             reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FROM            reduce using rule 118 (empty -> .)
    R_CURPAR        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 130

state 102

    (60) var -> VAR . varF
    (62) varF -> . arrfunc empty
    (63) varF -> . empty
    (57) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (58) arrfunc -> . L_BREAK exp R_BREAK empty
    (118) empty -> .

    L_BREAK         shift and go to state 134
    EQUAL           reduce using rule 118 (empty -> .)
    PLUS_EQ         reduce using rule 118 (empty -> .)
    MIN_EQ          reduce using rule 118 (empty -> .)
    MULT_EQ         reduce using rule 118 (empty -> .)
    DIV_EQ          reduce using rule 118 (empty -> .)
    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    varF                           shift and go to state 131
    arrfunc                        shift and go to state 132
    empty                          shift and go to state 133

state 103

    (84) conditional -> WHILE . np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (148) np_addWhile -> .

    L_PAR           reduce using rule 148 (np_addWhile -> .)

    np_addWhile                    shift and go to state 135

state 104

    (85) nonconditional -> FROM . VAR arrfunc nonconditionalF
    (86) nonconditional -> FROM . VAR np_addId nonconditionalF

    VAR             shift and go to state 136


state 105

    (8) classT -> LESS INHERIT ID GREATER classF .

    CLASS           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VARS            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    MAIN            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    INT             reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    FLOAT           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    CHAR            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    BOOL            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    ID              reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VOID            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)


state 106

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS . func R_CURPAR SEMICOLON empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21
    ID              shift and go to state 7
    VOID            shift and go to state 22

    func                           shift and go to state 137
    typeFunc                       shift and go to state 16

state 107

    (15) decF -> COLON type np_getVarType SEMICOLON . np_getDec dec
    (16) decF -> COLON type np_getVarType SEMICOLON . np_getDec np_addToDic empty
    (122) np_getDec -> .

    VAR             reduce using rule 122 (np_getDec -> .)
    MAIN            reduce using rule 122 (np_getDec -> .)
    INT             reduce using rule 122 (np_getDec -> .)
    FLOAT           reduce using rule 122 (np_getDec -> .)
    CHAR            reduce using rule 122 (np_getDec -> .)
    BOOL            reduce using rule 122 (np_getDec -> .)
    ID              reduce using rule 122 (np_getDec -> .)
    VOID            reduce using rule 122 (np_getDec -> .)
    METHODS         reduce using rule 122 (np_getDec -> .)
    L_CURPAR        reduce using rule 122 (np_getDec -> .)

    np_getDec                      shift and go to state 138

state 108

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK . empty
    (118) empty -> .

    COMMA           reduce using rule 118 (empty -> .)
    COLON           reduce using rule 118 (empty -> .)

    empty                          shift and go to state 139

state 109

    (25) funcF -> parameter R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty

    SEMICOLON       shift and go to state 140


state 110

    (26) funcF -> R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR np_endFunc empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 28

    dec                            shift and go to state 141

state 111

    (33) parameter -> VAR np_getDec . COLON typepar np_getVarType np_addParam SEMICOLON np_getDec np_addToDic parameterF

    COLON           shift and go to state 142


state 112

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR . empty
    (118) empty -> .

    $end            reduce using rule 118 (empty -> .)

    empty                          shift and go to state 143

state 113

    (42) statement -> assigment SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (118) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 118 (empty -> .)
    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    assigment                      shift and go to state 87
    statementF                     shift and go to state 144
    statement                      shift and go to state 119
    empty                          shift and go to state 120
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 114

    (43) statement -> void SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (118) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 118 (empty -> .)
    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    void                           shift and go to state 88
    statementF                     shift and go to state 145
    statement                      shift and go to state 119
    empty                          shift and go to state 120
    assigment                      shift and go to state 87
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 115

    (44) statement -> return SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (118) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 118 (empty -> .)
    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    return                         shift and go to state 89
    statementF                     shift and go to state 146
    statement                      shift and go to state 119
    empty                          shift and go to state 120
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 116

    (45) statement -> read SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (118) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 118 (empty -> .)
    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    read                           shift and go to state 90
    statementF                     shift and go to state 147
    statement                      shift and go to state 119
    empty                          shift and go to state 120
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 117

    (46) statement -> write SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (118) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 118 (empty -> .)
    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    write                          shift and go to state 91
    statementF                     shift and go to state 148
    statement                      shift and go to state 119
    empty                          shift and go to state 120
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 118

    (47) statement -> if statementF .

    R_CURPAR        reduce using rule 47 (statement -> if statementF .)


state 119

    (49) statementF -> statement .

    R_CURPAR        reduce using rule 49 (statementF -> statement .)


state 120

    (50) statementF -> empty .

    R_CURPAR        reduce using rule 50 (statementF -> empty .)


state 121

    (48) statement -> repeat statementF .

    R_CURPAR        reduce using rule 48 (statement -> repeat statementF .)


state 122

    (77) assigment -> var np_addId . assigmentF
    (78) assigmentF -> . EQUAL np_addOp exp np_doAssign empty
    (79) assigmentF -> . ope np_addOp exp np_doAssign empty
    (80) ope -> . PLUS_EQ empty
    (81) ope -> . MIN_EQ empty
    (82) ope -> . MULT_EQ empty
    (83) ope -> . DIV_EQ empty

    EQUAL           shift and go to state 150
    PLUS_EQ         shift and go to state 152
    MIN_EQ          shift and go to state 153
    MULT_EQ         shift and go to state 154
    DIV_EQ          shift and go to state 155

    assigmentF                     shift and go to state 149
    ope                            shift and go to state 151

state 123

    (51) void -> ID DOT . ID L_PAR voidT
    (61) var -> ID DOT . VAR varF

    ID              shift and go to state 156
    VAR             shift and go to state 157


state 124

    (52) void -> ID np_checkVoid . L_PAR np_eraQuad voidT

    L_PAR           shift and go to state 158


state 125

    (59) return -> RETURN L_PAR . exp np_addReturn R_PAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 160
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 126

    (64) read -> READ L_PAR . readF
    (65) readF -> . var np_addRead COMMA readF
    (66) readF -> . var np_addRead R_PAR empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 102
    ID              shift and go to state 174

    readF                          shift and go to state 175
    var                            shift and go to state 176

state 127

    (67) write -> WRITE L_PAR . writeT
    (68) writeT -> . CTE_STRING np_addConstString writeF
    (69) writeT -> . exp writeF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 178
    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    writeT                         shift and go to state 177
    exp                            shift and go to state 179
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 128

    (74) if -> IF L_PAR . exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 180
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 129

    (72) repeat -> conditional empty .

    ID              reduce using rule 72 (repeat -> conditional empty .)
    RETURN          reduce using rule 72 (repeat -> conditional empty .)
    READ            reduce using rule 72 (repeat -> conditional empty .)
    WRITE           reduce using rule 72 (repeat -> conditional empty .)
    IF              reduce using rule 72 (repeat -> conditional empty .)
    VAR             reduce using rule 72 (repeat -> conditional empty .)
    WHILE           reduce using rule 72 (repeat -> conditional empty .)
    FROM            reduce using rule 72 (repeat -> conditional empty .)
    R_CURPAR        reduce using rule 72 (repeat -> conditional empty .)


state 130

    (73) repeat -> nonconditional empty .

    ID              reduce using rule 73 (repeat -> nonconditional empty .)
    RETURN          reduce using rule 73 (repeat -> nonconditional empty .)
    READ            reduce using rule 73 (repeat -> nonconditional empty .)
    WRITE           reduce using rule 73 (repeat -> nonconditional empty .)
    IF              reduce using rule 73 (repeat -> nonconditional empty .)
    VAR             reduce using rule 73 (repeat -> nonconditional empty .)
    WHILE           reduce using rule 73 (repeat -> nonconditional empty .)
    FROM            reduce using rule 73 (repeat -> nonconditional empty .)
    R_CURPAR        reduce using rule 73 (repeat -> nonconditional empty .)


state 131

    (60) var -> VAR varF .

    EQUAL           reduce using rule 60 (var -> VAR varF .)
    PLUS_EQ         reduce using rule 60 (var -> VAR varF .)
    MIN_EQ          reduce using rule 60 (var -> VAR varF .)
    MULT_EQ         reduce using rule 60 (var -> VAR varF .)
    DIV_EQ          reduce using rule 60 (var -> VAR varF .)
    MULT            reduce using rule 60 (var -> VAR varF .)
    DIV             reduce using rule 60 (var -> VAR varF .)
    PLUS            reduce using rule 60 (var -> VAR varF .)
    MINUS           reduce using rule 60 (var -> VAR varF .)
    LESS            reduce using rule 60 (var -> VAR varF .)
    GREATER         reduce using rule 60 (var -> VAR varF .)
    LESS_TH         reduce using rule 60 (var -> VAR varF .)
    GREAT_TH        reduce using rule 60 (var -> VAR varF .)
    SAME            reduce using rule 60 (var -> VAR varF .)
    DIF             reduce using rule 60 (var -> VAR varF .)
    OR              reduce using rule 60 (var -> VAR varF .)
    AND             reduce using rule 60 (var -> VAR varF .)
    R_PAR           reduce using rule 60 (var -> VAR varF .)
    COMMA           reduce using rule 60 (var -> VAR varF .)
    R_BREAK         reduce using rule 60 (var -> VAR varF .)
    SEMICOLON       reduce using rule 60 (var -> VAR varF .)
    TO              reduce using rule 60 (var -> VAR varF .)
    DO              reduce using rule 60 (var -> VAR varF .)


state 132

    (62) varF -> arrfunc . empty
    (118) empty -> .

    EQUAL           reduce using rule 118 (empty -> .)
    PLUS_EQ         reduce using rule 118 (empty -> .)
    MIN_EQ          reduce using rule 118 (empty -> .)
    MULT_EQ         reduce using rule 118 (empty -> .)
    DIV_EQ          reduce using rule 118 (empty -> .)
    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 181

state 133

    (63) varF -> empty .

    EQUAL           reduce using rule 63 (varF -> empty .)
    PLUS_EQ         reduce using rule 63 (varF -> empty .)
    MIN_EQ          reduce using rule 63 (varF -> empty .)
    MULT_EQ         reduce using rule 63 (varF -> empty .)
    DIV_EQ          reduce using rule 63 (varF -> empty .)
    MULT            reduce using rule 63 (varF -> empty .)
    DIV             reduce using rule 63 (varF -> empty .)
    PLUS            reduce using rule 63 (varF -> empty .)
    MINUS           reduce using rule 63 (varF -> empty .)
    LESS            reduce using rule 63 (varF -> empty .)
    GREATER         reduce using rule 63 (varF -> empty .)
    LESS_TH         reduce using rule 63 (varF -> empty .)
    GREAT_TH        reduce using rule 63 (varF -> empty .)
    SAME            reduce using rule 63 (varF -> empty .)
    DIF             reduce using rule 63 (varF -> empty .)
    OR              reduce using rule 63 (varF -> empty .)
    AND             reduce using rule 63 (varF -> empty .)
    R_PAR           reduce using rule 63 (varF -> empty .)
    COMMA           reduce using rule 63 (varF -> empty .)
    R_BREAK         reduce using rule 63 (varF -> empty .)
    SEMICOLON       reduce using rule 63 (varF -> empty .)
    TO              reduce using rule 63 (varF -> empty .)
    DO              reduce using rule 63 (varF -> empty .)


state 134

    (57) arrfunc -> L_BREAK . exp COMMA exp R_BREAK empty
    (58) arrfunc -> L_BREAK . exp R_BREAK empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 182
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 135

    (84) conditional -> WHILE np_addWhile . L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty

    L_PAR           shift and go to state 183


state 136

    (85) nonconditional -> FROM VAR . arrfunc nonconditionalF
    (86) nonconditional -> FROM VAR . np_addId nonconditionalF
    (57) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (58) arrfunc -> . L_BREAK exp R_BREAK empty
    (128) np_addId -> .

    L_BREAK         shift and go to state 134
    EQUAL           reduce using rule 128 (np_addId -> .)

    arrfunc                        shift and go to state 184
    np_addId                       shift and go to state 185

state 137

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func . R_CURPAR SEMICOLON empty

    R_CURPAR        shift and go to state 186


state 138

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec . dec
    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec . np_addToDic empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF
    (126) np_addToDic -> .

    VAR             shift and go to state 28
    MAIN            reduce using rule 126 (np_addToDic -> .)
    INT             reduce using rule 126 (np_addToDic -> .)
    FLOAT           reduce using rule 126 (np_addToDic -> .)
    CHAR            reduce using rule 126 (np_addToDic -> .)
    BOOL            reduce using rule 126 (np_addToDic -> .)
    ID              reduce using rule 126 (np_addToDic -> .)
    VOID            reduce using rule 126 (np_addToDic -> .)
    METHODS         reduce using rule 126 (np_addToDic -> .)
    L_CURPAR        reduce using rule 126 (np_addToDic -> .)

    dec                            shift and go to state 187
    np_addToDic                    shift and go to state 188

state 139

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .

    COMMA           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    COLON           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)


state 140

    (25) funcF -> parameter R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR np_endFunc empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 28

    dec                            shift and go to state 189

state 141

    (26) funcF -> R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR np_endFunc empty

    L_CURPAR        shift and go to state 190


state 142

    (33) parameter -> VAR np_getDec COLON . typepar np_getVarType np_addParam SEMICOLON np_getDec np_addToDic parameterF
    (36) typepar -> . INT empty
    (37) typepar -> . FLOAT empty
    (38) typepar -> . CHAR empty
    (39) typepar -> . BOOL empty
    (40) typepar -> . ID empty

    INT             shift and go to state 192
    FLOAT           shift and go to state 193
    CHAR            shift and go to state 194
    BOOL            shift and go to state 195
    ID              shift and go to state 196

    typepar                        shift and go to state 191

state 143

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty .

    $end            reduce using rule 41 (main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty .)


state 144

    (42) statement -> assigment SEMICOLON statementF .

    R_CURPAR        reduce using rule 42 (statement -> assigment SEMICOLON statementF .)


state 145

    (43) statement -> void SEMICOLON statementF .

    R_CURPAR        reduce using rule 43 (statement -> void SEMICOLON statementF .)


state 146

    (44) statement -> return SEMICOLON statementF .

    R_CURPAR        reduce using rule 44 (statement -> return SEMICOLON statementF .)


state 147

    (45) statement -> read SEMICOLON statementF .

    R_CURPAR        reduce using rule 45 (statement -> read SEMICOLON statementF .)


state 148

    (46) statement -> write SEMICOLON statementF .

    R_CURPAR        reduce using rule 46 (statement -> write SEMICOLON statementF .)


state 149

    (77) assigment -> var np_addId assigmentF .

    SEMICOLON       reduce using rule 77 (assigment -> var np_addId assigmentF .)


state 150

    (78) assigmentF -> EQUAL . np_addOp exp np_doAssign empty
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 197

state 151

    (79) assigmentF -> ope . np_addOp exp np_doAssign empty
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 198

state 152

    (80) ope -> PLUS_EQ . empty
    (118) empty -> .

    L_PAR           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    VAR             reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 199

state 153

    (81) ope -> MIN_EQ . empty
    (118) empty -> .

    L_PAR           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    VAR             reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 200

state 154

    (82) ope -> MULT_EQ . empty
    (118) empty -> .

    L_PAR           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    VAR             reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 201

state 155

    (83) ope -> DIV_EQ . empty
    (118) empty -> .

    L_PAR           reduce using rule 118 (empty -> .)
    CTE_INT         reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    CTE_CHAR        reduce using rule 118 (empty -> .)
    CTE_BOOL        reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    VAR             reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 202

state 156

    (51) void -> ID DOT ID . L_PAR voidT

    L_PAR           shift and go to state 203


state 157

    (61) var -> ID DOT VAR . varF
    (62) varF -> . arrfunc empty
    (63) varF -> . empty
    (57) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (58) arrfunc -> . L_BREAK exp R_BREAK empty
    (118) empty -> .

    L_BREAK         shift and go to state 134
    EQUAL           reduce using rule 118 (empty -> .)
    PLUS_EQ         reduce using rule 118 (empty -> .)
    MIN_EQ          reduce using rule 118 (empty -> .)
    MULT_EQ         reduce using rule 118 (empty -> .)
    DIV_EQ          reduce using rule 118 (empty -> .)
    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    varF                           shift and go to state 204
    arrfunc                        shift and go to state 132
    empty                          shift and go to state 133

state 158

    (52) void -> ID np_checkVoid L_PAR . np_eraQuad voidT
    (154) np_eraQuad -> .

    R_PAR           reduce using rule 154 (np_eraQuad -> .)
    L_PAR           reduce using rule 154 (np_eraQuad -> .)
    CTE_INT         reduce using rule 154 (np_eraQuad -> .)
    CTE_FLOAT       reduce using rule 154 (np_eraQuad -> .)
    CTE_CHAR        reduce using rule 154 (np_eraQuad -> .)
    CTE_BOOL        reduce using rule 154 (np_eraQuad -> .)
    MINUS           reduce using rule 154 (np_eraQuad -> .)
    VAR             reduce using rule 154 (np_eraQuad -> .)
    ID              reduce using rule 154 (np_eraQuad -> .)

    np_eraQuad                     shift and go to state 205

state 159

    (109) factor -> L_PAR . np_addPar exp R_PAR np_popPar empty
    (135) np_addPar -> .

    L_PAR           reduce using rule 135 (np_addPar -> .)
    CTE_INT         reduce using rule 135 (np_addPar -> .)
    CTE_FLOAT       reduce using rule 135 (np_addPar -> .)
    CTE_CHAR        reduce using rule 135 (np_addPar -> .)
    CTE_BOOL        reduce using rule 135 (np_addPar -> .)
    MINUS           reduce using rule 135 (np_addPar -> .)
    VAR             reduce using rule 135 (np_addPar -> .)
    ID              reduce using rule 135 (np_addPar -> .)

    np_addPar                      shift and go to state 206

state 160

    (59) return -> RETURN L_PAR exp . np_addReturn R_PAR empty
    (144) np_addReturn -> .

    R_PAR           reduce using rule 144 (np_addReturn -> .)

    np_addReturn                   shift and go to state 207

state 161

    (100) exp -> bool . empty
    (118) empty -> .

    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 208

state 162

    (88) bool -> logical . np_addBool boolF
    (140) np_addBool -> .

    OR              reduce using rule 140 (np_addBool -> .)
    AND             reduce using rule 140 (np_addBool -> .)
    R_PAR           reduce using rule 140 (np_addBool -> .)
    COMMA           reduce using rule 140 (np_addBool -> .)
    R_BREAK         reduce using rule 140 (np_addBool -> .)
    SEMICOLON       reduce using rule 140 (np_addBool -> .)
    TO              reduce using rule 140 (np_addBool -> .)
    DO              reduce using rule 140 (np_addBool -> .)

    np_addBool                     shift and go to state 209

state 163

    (92) logical -> ex . np_addLogical logicalF
    (139) np_addLogical -> .

    LESS            reduce using rule 139 (np_addLogical -> .)
    GREATER         reduce using rule 139 (np_addLogical -> .)
    LESS_TH         reduce using rule 139 (np_addLogical -> .)
    GREAT_TH        reduce using rule 139 (np_addLogical -> .)
    SAME            reduce using rule 139 (np_addLogical -> .)
    DIF             reduce using rule 139 (np_addLogical -> .)
    OR              reduce using rule 139 (np_addLogical -> .)
    AND             reduce using rule 139 (np_addLogical -> .)
    R_PAR           reduce using rule 139 (np_addLogical -> .)
    COMMA           reduce using rule 139 (np_addLogical -> .)
    R_BREAK         reduce using rule 139 (np_addLogical -> .)
    SEMICOLON       reduce using rule 139 (np_addLogical -> .)
    TO              reduce using rule 139 (np_addLogical -> .)
    DO              reduce using rule 139 (np_addLogical -> .)

    np_addLogical                  shift and go to state 210

state 164

    (101) ex -> term . np_addEx exF
    (138) np_addEx -> .

    PLUS            reduce using rule 138 (np_addEx -> .)
    MINUS           reduce using rule 138 (np_addEx -> .)
    LESS            reduce using rule 138 (np_addEx -> .)
    GREATER         reduce using rule 138 (np_addEx -> .)
    LESS_TH         reduce using rule 138 (np_addEx -> .)
    GREAT_TH        reduce using rule 138 (np_addEx -> .)
    SAME            reduce using rule 138 (np_addEx -> .)
    DIF             reduce using rule 138 (np_addEx -> .)
    OR              reduce using rule 138 (np_addEx -> .)
    AND             reduce using rule 138 (np_addEx -> .)
    R_PAR           reduce using rule 138 (np_addEx -> .)
    COMMA           reduce using rule 138 (np_addEx -> .)
    R_BREAK         reduce using rule 138 (np_addEx -> .)
    SEMICOLON       reduce using rule 138 (np_addEx -> .)
    TO              reduce using rule 138 (np_addEx -> .)
    DO              reduce using rule 138 (np_addEx -> .)

    np_addEx                       shift and go to state 211

state 165

    (105) term -> factor . np_addTerm termF
    (137) np_addTerm -> .

    MULT            reduce using rule 137 (np_addTerm -> .)
    DIV             reduce using rule 137 (np_addTerm -> .)
    PLUS            reduce using rule 137 (np_addTerm -> .)
    MINUS           reduce using rule 137 (np_addTerm -> .)
    LESS            reduce using rule 137 (np_addTerm -> .)
    GREATER         reduce using rule 137 (np_addTerm -> .)
    LESS_TH         reduce using rule 137 (np_addTerm -> .)
    GREAT_TH        reduce using rule 137 (np_addTerm -> .)
    SAME            reduce using rule 137 (np_addTerm -> .)
    DIF             reduce using rule 137 (np_addTerm -> .)
    OR              reduce using rule 137 (np_addTerm -> .)
    AND             reduce using rule 137 (np_addTerm -> .)
    R_PAR           reduce using rule 137 (np_addTerm -> .)
    COMMA           reduce using rule 137 (np_addTerm -> .)
    R_BREAK         reduce using rule 137 (np_addTerm -> .)
    SEMICOLON       reduce using rule 137 (np_addTerm -> .)
    TO              reduce using rule 137 (np_addTerm -> .)
    DO              reduce using rule 137 (np_addTerm -> .)

    np_addTerm                     shift and go to state 212

state 166

    (110) factor -> varcte . empty
    (118) empty -> .

    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 213

state 167

    (111) factor -> factorF .

    MULT            reduce using rule 111 (factor -> factorF .)
    DIV             reduce using rule 111 (factor -> factorF .)
    PLUS            reduce using rule 111 (factor -> factorF .)
    MINUS           reduce using rule 111 (factor -> factorF .)
    LESS            reduce using rule 111 (factor -> factorF .)
    GREATER         reduce using rule 111 (factor -> factorF .)
    LESS_TH         reduce using rule 111 (factor -> factorF .)
    GREAT_TH        reduce using rule 111 (factor -> factorF .)
    SAME            reduce using rule 111 (factor -> factorF .)
    DIF             reduce using rule 111 (factor -> factorF .)
    OR              reduce using rule 111 (factor -> factorF .)
    AND             reduce using rule 111 (factor -> factorF .)
    R_PAR           reduce using rule 111 (factor -> factorF .)
    COMMA           reduce using rule 111 (factor -> factorF .)
    R_BREAK         reduce using rule 111 (factor -> factorF .)
    SEMICOLON       reduce using rule 111 (factor -> factorF .)
    TO              reduce using rule 111 (factor -> factorF .)
    DO              reduce using rule 111 (factor -> factorF .)


state 168

    (114) varcte -> CTE_INT . np_addConstInt empty
    (129) np_addConstInt -> .

    MULT            reduce using rule 129 (np_addConstInt -> .)
    DIV             reduce using rule 129 (np_addConstInt -> .)
    PLUS            reduce using rule 129 (np_addConstInt -> .)
    MINUS           reduce using rule 129 (np_addConstInt -> .)
    LESS            reduce using rule 129 (np_addConstInt -> .)
    GREATER         reduce using rule 129 (np_addConstInt -> .)
    LESS_TH         reduce using rule 129 (np_addConstInt -> .)
    GREAT_TH        reduce using rule 129 (np_addConstInt -> .)
    SAME            reduce using rule 129 (np_addConstInt -> .)
    DIF             reduce using rule 129 (np_addConstInt -> .)
    OR              reduce using rule 129 (np_addConstInt -> .)
    AND             reduce using rule 129 (np_addConstInt -> .)
    R_PAR           reduce using rule 129 (np_addConstInt -> .)
    COMMA           reduce using rule 129 (np_addConstInt -> .)
    R_BREAK         reduce using rule 129 (np_addConstInt -> .)
    SEMICOLON       reduce using rule 129 (np_addConstInt -> .)
    TO              reduce using rule 129 (np_addConstInt -> .)
    DO              reduce using rule 129 (np_addConstInt -> .)

    np_addConstInt                 shift and go to state 214

state 169

    (115) varcte -> CTE_FLOAT . np_addConstFloat empty
    (130) np_addConstFloat -> .

    MULT            reduce using rule 130 (np_addConstFloat -> .)
    DIV             reduce using rule 130 (np_addConstFloat -> .)
    PLUS            reduce using rule 130 (np_addConstFloat -> .)
    MINUS           reduce using rule 130 (np_addConstFloat -> .)
    LESS            reduce using rule 130 (np_addConstFloat -> .)
    GREATER         reduce using rule 130 (np_addConstFloat -> .)
    LESS_TH         reduce using rule 130 (np_addConstFloat -> .)
    GREAT_TH        reduce using rule 130 (np_addConstFloat -> .)
    SAME            reduce using rule 130 (np_addConstFloat -> .)
    DIF             reduce using rule 130 (np_addConstFloat -> .)
    OR              reduce using rule 130 (np_addConstFloat -> .)
    AND             reduce using rule 130 (np_addConstFloat -> .)
    R_PAR           reduce using rule 130 (np_addConstFloat -> .)
    COMMA           reduce using rule 130 (np_addConstFloat -> .)
    R_BREAK         reduce using rule 130 (np_addConstFloat -> .)
    SEMICOLON       reduce using rule 130 (np_addConstFloat -> .)
    TO              reduce using rule 130 (np_addConstFloat -> .)
    DO              reduce using rule 130 (np_addConstFloat -> .)

    np_addConstFloat               shift and go to state 215

state 170

    (116) varcte -> CTE_CHAR . np_addConstChar empty
    (131) np_addConstChar -> .

    MULT            reduce using rule 131 (np_addConstChar -> .)
    DIV             reduce using rule 131 (np_addConstChar -> .)
    PLUS            reduce using rule 131 (np_addConstChar -> .)
    MINUS           reduce using rule 131 (np_addConstChar -> .)
    LESS            reduce using rule 131 (np_addConstChar -> .)
    GREATER         reduce using rule 131 (np_addConstChar -> .)
    LESS_TH         reduce using rule 131 (np_addConstChar -> .)
    GREAT_TH        reduce using rule 131 (np_addConstChar -> .)
    SAME            reduce using rule 131 (np_addConstChar -> .)
    DIF             reduce using rule 131 (np_addConstChar -> .)
    OR              reduce using rule 131 (np_addConstChar -> .)
    AND             reduce using rule 131 (np_addConstChar -> .)
    R_PAR           reduce using rule 131 (np_addConstChar -> .)
    COMMA           reduce using rule 131 (np_addConstChar -> .)
    R_BREAK         reduce using rule 131 (np_addConstChar -> .)
    SEMICOLON       reduce using rule 131 (np_addConstChar -> .)
    TO              reduce using rule 131 (np_addConstChar -> .)
    DO              reduce using rule 131 (np_addConstChar -> .)

    np_addConstChar                shift and go to state 216

state 171

    (117) varcte -> CTE_BOOL . np_addConstBool empty
    (132) np_addConstBool -> .

    MULT            reduce using rule 132 (np_addConstBool -> .)
    DIV             reduce using rule 132 (np_addConstBool -> .)
    PLUS            reduce using rule 132 (np_addConstBool -> .)
    MINUS           reduce using rule 132 (np_addConstBool -> .)
    LESS            reduce using rule 132 (np_addConstBool -> .)
    GREATER         reduce using rule 132 (np_addConstBool -> .)
    LESS_TH         reduce using rule 132 (np_addConstBool -> .)
    GREAT_TH        reduce using rule 132 (np_addConstBool -> .)
    SAME            reduce using rule 132 (np_addConstBool -> .)
    DIF             reduce using rule 132 (np_addConstBool -> .)
    OR              reduce using rule 132 (np_addConstBool -> .)
    AND             reduce using rule 132 (np_addConstBool -> .)
    R_PAR           reduce using rule 132 (np_addConstBool -> .)
    COMMA           reduce using rule 132 (np_addConstBool -> .)
    R_BREAK         reduce using rule 132 (np_addConstBool -> .)
    SEMICOLON       reduce using rule 132 (np_addConstBool -> .)
    TO              reduce using rule 132 (np_addConstBool -> .)
    DO              reduce using rule 132 (np_addConstBool -> .)

    np_addConstBool                shift and go to state 217

state 172

    (112) factorF -> MINUS . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 102
    ID              shift and go to state 174

    var                            shift and go to state 218

state 173

    (113) factorF -> var . np_addId empty
    (128) np_addId -> .

    MULT            reduce using rule 128 (np_addId -> .)
    DIV             reduce using rule 128 (np_addId -> .)
    PLUS            reduce using rule 128 (np_addId -> .)
    MINUS           reduce using rule 128 (np_addId -> .)
    LESS            reduce using rule 128 (np_addId -> .)
    GREATER         reduce using rule 128 (np_addId -> .)
    LESS_TH         reduce using rule 128 (np_addId -> .)
    GREAT_TH        reduce using rule 128 (np_addId -> .)
    SAME            reduce using rule 128 (np_addId -> .)
    DIF             reduce using rule 128 (np_addId -> .)
    OR              reduce using rule 128 (np_addId -> .)
    AND             reduce using rule 128 (np_addId -> .)
    R_PAR           reduce using rule 128 (np_addId -> .)
    COMMA           reduce using rule 128 (np_addId -> .)
    R_BREAK         reduce using rule 128 (np_addId -> .)
    SEMICOLON       reduce using rule 128 (np_addId -> .)
    TO              reduce using rule 128 (np_addId -> .)
    DO              reduce using rule 128 (np_addId -> .)

    np_addId                       shift and go to state 219

state 174

    (61) var -> ID . DOT VAR varF

    DOT             shift and go to state 220


state 175

    (64) read -> READ L_PAR readF .

    SEMICOLON       reduce using rule 64 (read -> READ L_PAR readF .)


state 176

    (65) readF -> var . np_addRead COMMA readF
    (66) readF -> var . np_addRead R_PAR empty
    (142) np_addRead -> .

    COMMA           reduce using rule 142 (np_addRead -> .)
    R_PAR           reduce using rule 142 (np_addRead -> .)

    np_addRead                     shift and go to state 221

state 177

    (67) write -> WRITE L_PAR writeT .

    SEMICOLON       reduce using rule 67 (write -> WRITE L_PAR writeT .)


state 178

    (68) writeT -> CTE_STRING . np_addConstString writeF
    (133) np_addConstString -> .

    COMMA           reduce using rule 133 (np_addConstString -> .)
    R_PAR           reduce using rule 133 (np_addConstString -> .)

    np_addConstString              shift and go to state 222

state 179

    (69) writeT -> exp . writeF
    (70) writeF -> . COMMA np_addWrite writeT
    (71) writeF -> . R_PAR np_addWrite empty

    COMMA           shift and go to state 224
    R_PAR           shift and go to state 225

    writeF                         shift and go to state 223

state 180

    (74) if -> IF L_PAR exp . np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (145) np_checkBool -> .

    R_PAR           reduce using rule 145 (np_checkBool -> .)

    np_checkBool                   shift and go to state 226

state 181

    (62) varF -> arrfunc empty .

    EQUAL           reduce using rule 62 (varF -> arrfunc empty .)
    PLUS_EQ         reduce using rule 62 (varF -> arrfunc empty .)
    MIN_EQ          reduce using rule 62 (varF -> arrfunc empty .)
    MULT_EQ         reduce using rule 62 (varF -> arrfunc empty .)
    DIV_EQ          reduce using rule 62 (varF -> arrfunc empty .)
    MULT            reduce using rule 62 (varF -> arrfunc empty .)
    DIV             reduce using rule 62 (varF -> arrfunc empty .)
    PLUS            reduce using rule 62 (varF -> arrfunc empty .)
    MINUS           reduce using rule 62 (varF -> arrfunc empty .)
    LESS            reduce using rule 62 (varF -> arrfunc empty .)
    GREATER         reduce using rule 62 (varF -> arrfunc empty .)
    LESS_TH         reduce using rule 62 (varF -> arrfunc empty .)
    GREAT_TH        reduce using rule 62 (varF -> arrfunc empty .)
    SAME            reduce using rule 62 (varF -> arrfunc empty .)
    DIF             reduce using rule 62 (varF -> arrfunc empty .)
    OR              reduce using rule 62 (varF -> arrfunc empty .)
    AND             reduce using rule 62 (varF -> arrfunc empty .)
    R_PAR           reduce using rule 62 (varF -> arrfunc empty .)
    COMMA           reduce using rule 62 (varF -> arrfunc empty .)
    R_BREAK         reduce using rule 62 (varF -> arrfunc empty .)
    SEMICOLON       reduce using rule 62 (varF -> arrfunc empty .)
    TO              reduce using rule 62 (varF -> arrfunc empty .)
    DO              reduce using rule 62 (varF -> arrfunc empty .)


state 182

    (57) arrfunc -> L_BREAK exp . COMMA exp R_BREAK empty
    (58) arrfunc -> L_BREAK exp . R_BREAK empty

    COMMA           shift and go to state 227
    R_BREAK         shift and go to state 228


state 183

    (84) conditional -> WHILE np_addWhile L_PAR . exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 229
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 184

    (85) nonconditional -> FROM VAR arrfunc . nonconditionalF
    (87) nonconditionalF -> . EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty

    EQUAL           shift and go to state 231

    nonconditionalF                shift and go to state 230

state 185

    (86) nonconditional -> FROM VAR np_addId . nonconditionalF
    (87) nonconditionalF -> . EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty

    EQUAL           shift and go to state 231

    nonconditionalF                shift and go to state 232

state 186

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR . SEMICOLON empty

    SEMICOLON       shift and go to state 233


state 187

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec dec .

    MAIN            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    INT             reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    FLOAT           reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    CHAR            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    BOOL            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    ID              reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    VOID            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    METHODS         reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    L_CURPAR        reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)


state 188

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic . empty
    (118) empty -> .

    MAIN            reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    CHAR            reduce using rule 118 (empty -> .)
    BOOL            reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    METHODS         reduce using rule 118 (empty -> .)
    L_CURPAR        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 234

state 189

    (25) funcF -> parameter R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR np_endFunc empty

    L_CURPAR        shift and go to state 235


state 190

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR np_endFunc empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    statement                      shift and go to state 236
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 191

    (33) parameter -> VAR np_getDec COLON typepar . np_getVarType np_addParam SEMICOLON np_getDec np_addToDic parameterF
    (124) np_getVarType -> .

    SEMICOLON       reduce using rule 124 (np_getVarType -> .)

    np_getVarType                  shift and go to state 237

state 192

    (36) typepar -> INT . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 238

state 193

    (37) typepar -> FLOAT . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 239

state 194

    (38) typepar -> CHAR . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 240

state 195

    (39) typepar -> BOOL . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 241

state 196

    (40) typepar -> ID . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 242

state 197

    (78) assigmentF -> EQUAL np_addOp . exp np_doAssign empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 243
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 198

    (79) assigmentF -> ope np_addOp . exp np_doAssign empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 244
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 199

    (80) ope -> PLUS_EQ empty .

    L_PAR           reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_INT         reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_FLOAT       reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_CHAR        reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_BOOL        reduce using rule 80 (ope -> PLUS_EQ empty .)
    MINUS           reduce using rule 80 (ope -> PLUS_EQ empty .)
    VAR             reduce using rule 80 (ope -> PLUS_EQ empty .)
    ID              reduce using rule 80 (ope -> PLUS_EQ empty .)


state 200

    (81) ope -> MIN_EQ empty .

    L_PAR           reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_INT         reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_FLOAT       reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_CHAR        reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_BOOL        reduce using rule 81 (ope -> MIN_EQ empty .)
    MINUS           reduce using rule 81 (ope -> MIN_EQ empty .)
    VAR             reduce using rule 81 (ope -> MIN_EQ empty .)
    ID              reduce using rule 81 (ope -> MIN_EQ empty .)


state 201

    (82) ope -> MULT_EQ empty .

    L_PAR           reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_INT         reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_FLOAT       reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_CHAR        reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_BOOL        reduce using rule 82 (ope -> MULT_EQ empty .)
    MINUS           reduce using rule 82 (ope -> MULT_EQ empty .)
    VAR             reduce using rule 82 (ope -> MULT_EQ empty .)
    ID              reduce using rule 82 (ope -> MULT_EQ empty .)


state 202

    (83) ope -> DIV_EQ empty .

    L_PAR           reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_INT         reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_FLOAT       reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_CHAR        reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_BOOL        reduce using rule 83 (ope -> DIV_EQ empty .)
    MINUS           reduce using rule 83 (ope -> DIV_EQ empty .)
    VAR             reduce using rule 83 (ope -> DIV_EQ empty .)
    ID              reduce using rule 83 (ope -> DIV_EQ empty .)


state 203

    (51) void -> ID DOT ID L_PAR . voidT
    (53) voidT -> . exp np_checkParam COMMA voidT
    (54) voidT -> . exp np_checkParam voidF
    (55) voidT -> . voidF
    (100) exp -> . bool empty
    (56) voidF -> . R_PAR np_endVoid empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 248
    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    voidT                          shift and go to state 245
    exp                            shift and go to state 246
    voidF                          shift and go to state 247
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 204

    (61) var -> ID DOT VAR varF .

    EQUAL           reduce using rule 61 (var -> ID DOT VAR varF .)
    PLUS_EQ         reduce using rule 61 (var -> ID DOT VAR varF .)
    MIN_EQ          reduce using rule 61 (var -> ID DOT VAR varF .)
    MULT_EQ         reduce using rule 61 (var -> ID DOT VAR varF .)
    DIV_EQ          reduce using rule 61 (var -> ID DOT VAR varF .)
    MULT            reduce using rule 61 (var -> ID DOT VAR varF .)
    DIV             reduce using rule 61 (var -> ID DOT VAR varF .)
    PLUS            reduce using rule 61 (var -> ID DOT VAR varF .)
    MINUS           reduce using rule 61 (var -> ID DOT VAR varF .)
    LESS            reduce using rule 61 (var -> ID DOT VAR varF .)
    GREATER         reduce using rule 61 (var -> ID DOT VAR varF .)
    LESS_TH         reduce using rule 61 (var -> ID DOT VAR varF .)
    GREAT_TH        reduce using rule 61 (var -> ID DOT VAR varF .)
    SAME            reduce using rule 61 (var -> ID DOT VAR varF .)
    DIF             reduce using rule 61 (var -> ID DOT VAR varF .)
    OR              reduce using rule 61 (var -> ID DOT VAR varF .)
    AND             reduce using rule 61 (var -> ID DOT VAR varF .)
    R_PAR           reduce using rule 61 (var -> ID DOT VAR varF .)
    COMMA           reduce using rule 61 (var -> ID DOT VAR varF .)
    R_BREAK         reduce using rule 61 (var -> ID DOT VAR varF .)
    SEMICOLON       reduce using rule 61 (var -> ID DOT VAR varF .)
    TO              reduce using rule 61 (var -> ID DOT VAR varF .)
    DO              reduce using rule 61 (var -> ID DOT VAR varF .)


state 205

    (52) void -> ID np_checkVoid L_PAR np_eraQuad . voidT
    (53) voidT -> . exp np_checkParam COMMA voidT
    (54) voidT -> . exp np_checkParam voidF
    (55) voidT -> . voidF
    (100) exp -> . bool empty
    (56) voidF -> . R_PAR np_endVoid empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 248
    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    voidT                          shift and go to state 249
    exp                            shift and go to state 246
    voidF                          shift and go to state 247
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 206

    (109) factor -> L_PAR np_addPar . exp R_PAR np_popPar empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 250
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 207

    (59) return -> RETURN L_PAR exp np_addReturn . R_PAR empty

    R_PAR           shift and go to state 251


state 208

    (100) exp -> bool empty .

    R_PAR           reduce using rule 100 (exp -> bool empty .)
    COMMA           reduce using rule 100 (exp -> bool empty .)
    R_BREAK         reduce using rule 100 (exp -> bool empty .)
    SEMICOLON       reduce using rule 100 (exp -> bool empty .)
    TO              reduce using rule 100 (exp -> bool empty .)
    DO              reduce using rule 100 (exp -> bool empty .)


state 209

    (88) bool -> logical np_addBool . boolF
    (89) boolF -> . OR np_addOp bool
    (90) boolF -> . AND np_addOp bool
    (91) boolF -> . empty
    (118) empty -> .

    OR              shift and go to state 253
    AND             shift and go to state 254
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    boolF                          shift and go to state 252
    empty                          shift and go to state 255

state 210

    (92) logical -> ex np_addLogical . logicalF
    (93) logicalF -> . LESS np_addOp logical
    (94) logicalF -> . GREATER np_addOp logical
    (95) logicalF -> . LESS_TH np_addOp logical
    (96) logicalF -> . GREAT_TH np_addOp logical
    (97) logicalF -> . SAME np_addOp logical
    (98) logicalF -> . DIF np_addOp logical
    (99) logicalF -> . empty
    (118) empty -> .

    LESS            shift and go to state 257
    GREATER         shift and go to state 258
    LESS_TH         shift and go to state 259
    GREAT_TH        shift and go to state 260
    SAME            shift and go to state 261
    DIF             shift and go to state 262
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    logicalF                       shift and go to state 256
    empty                          shift and go to state 263

state 211

    (101) ex -> term np_addEx . exF
    (102) exF -> . PLUS np_addOp ex
    (103) exF -> . MINUS np_addOp ex
    (104) exF -> . empty
    (118) empty -> .

    PLUS            shift and go to state 265
    MINUS           shift and go to state 266
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    exF                            shift and go to state 264
    empty                          shift and go to state 267

state 212

    (105) term -> factor np_addTerm . termF
    (106) termF -> . MULT np_addOp term
    (107) termF -> . DIV np_addOp term
    (108) termF -> . empty
    (118) empty -> .

    MULT            shift and go to state 269
    DIV             shift and go to state 270
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    termF                          shift and go to state 268
    empty                          shift and go to state 271

state 213

    (110) factor -> varcte empty .

    MULT            reduce using rule 110 (factor -> varcte empty .)
    DIV             reduce using rule 110 (factor -> varcte empty .)
    PLUS            reduce using rule 110 (factor -> varcte empty .)
    MINUS           reduce using rule 110 (factor -> varcte empty .)
    LESS            reduce using rule 110 (factor -> varcte empty .)
    GREATER         reduce using rule 110 (factor -> varcte empty .)
    LESS_TH         reduce using rule 110 (factor -> varcte empty .)
    GREAT_TH        reduce using rule 110 (factor -> varcte empty .)
    SAME            reduce using rule 110 (factor -> varcte empty .)
    DIF             reduce using rule 110 (factor -> varcte empty .)
    OR              reduce using rule 110 (factor -> varcte empty .)
    AND             reduce using rule 110 (factor -> varcte empty .)
    R_PAR           reduce using rule 110 (factor -> varcte empty .)
    COMMA           reduce using rule 110 (factor -> varcte empty .)
    R_BREAK         reduce using rule 110 (factor -> varcte empty .)
    SEMICOLON       reduce using rule 110 (factor -> varcte empty .)
    TO              reduce using rule 110 (factor -> varcte empty .)
    DO              reduce using rule 110 (factor -> varcte empty .)


state 214

    (114) varcte -> CTE_INT np_addConstInt . empty
    (118) empty -> .

    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 272

state 215

    (115) varcte -> CTE_FLOAT np_addConstFloat . empty
    (118) empty -> .

    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 273

state 216

    (116) varcte -> CTE_CHAR np_addConstChar . empty
    (118) empty -> .

    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 274

state 217

    (117) varcte -> CTE_BOOL np_addConstBool . empty
    (118) empty -> .

    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 275

state 218

    (112) factorF -> MINUS var . np_addId empty
    (128) np_addId -> .

    MULT            reduce using rule 128 (np_addId -> .)
    DIV             reduce using rule 128 (np_addId -> .)
    PLUS            reduce using rule 128 (np_addId -> .)
    MINUS           reduce using rule 128 (np_addId -> .)
    LESS            reduce using rule 128 (np_addId -> .)
    GREATER         reduce using rule 128 (np_addId -> .)
    LESS_TH         reduce using rule 128 (np_addId -> .)
    GREAT_TH        reduce using rule 128 (np_addId -> .)
    SAME            reduce using rule 128 (np_addId -> .)
    DIF             reduce using rule 128 (np_addId -> .)
    OR              reduce using rule 128 (np_addId -> .)
    AND             reduce using rule 128 (np_addId -> .)
    R_PAR           reduce using rule 128 (np_addId -> .)
    COMMA           reduce using rule 128 (np_addId -> .)
    R_BREAK         reduce using rule 128 (np_addId -> .)
    SEMICOLON       reduce using rule 128 (np_addId -> .)
    TO              reduce using rule 128 (np_addId -> .)
    DO              reduce using rule 128 (np_addId -> .)

    np_addId                       shift and go to state 276

state 219

    (113) factorF -> var np_addId . empty
    (118) empty -> .

    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 277

state 220

    (61) var -> ID DOT . VAR varF

    VAR             shift and go to state 157


state 221

    (65) readF -> var np_addRead . COMMA readF
    (66) readF -> var np_addRead . R_PAR empty

    COMMA           shift and go to state 278
    R_PAR           shift and go to state 279


state 222

    (68) writeT -> CTE_STRING np_addConstString . writeF
    (70) writeF -> . COMMA np_addWrite writeT
    (71) writeF -> . R_PAR np_addWrite empty

    COMMA           shift and go to state 224
    R_PAR           shift and go to state 225

    writeF                         shift and go to state 280

state 223

    (69) writeT -> exp writeF .

    SEMICOLON       reduce using rule 69 (writeT -> exp writeF .)


state 224

    (70) writeF -> COMMA . np_addWrite writeT
    (143) np_addWrite -> .

    CTE_STRING      reduce using rule 143 (np_addWrite -> .)
    L_PAR           reduce using rule 143 (np_addWrite -> .)
    CTE_INT         reduce using rule 143 (np_addWrite -> .)
    CTE_FLOAT       reduce using rule 143 (np_addWrite -> .)
    CTE_CHAR        reduce using rule 143 (np_addWrite -> .)
    CTE_BOOL        reduce using rule 143 (np_addWrite -> .)
    MINUS           reduce using rule 143 (np_addWrite -> .)
    VAR             reduce using rule 143 (np_addWrite -> .)
    ID              reduce using rule 143 (np_addWrite -> .)

    np_addWrite                    shift and go to state 281

state 225

    (71) writeF -> R_PAR . np_addWrite empty
    (143) np_addWrite -> .

    SEMICOLON       reduce using rule 143 (np_addWrite -> .)

    np_addWrite                    shift and go to state 282

state 226

    (74) if -> IF L_PAR exp np_checkBool . R_PAR THEN L_CURPAR statement R_CURPAR ifF

    R_PAR           shift and go to state 283


state 227

    (57) arrfunc -> L_BREAK exp COMMA . exp R_BREAK empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 284
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 228

    (58) arrfunc -> L_BREAK exp R_BREAK . empty
    (118) empty -> .

    EQUAL           reduce using rule 118 (empty -> .)
    PLUS_EQ         reduce using rule 118 (empty -> .)
    MIN_EQ          reduce using rule 118 (empty -> .)
    MULT_EQ         reduce using rule 118 (empty -> .)
    DIV_EQ          reduce using rule 118 (empty -> .)
    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 285

state 229

    (84) conditional -> WHILE np_addWhile L_PAR exp . R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty

    R_PAR           shift and go to state 286


state 230

    (85) nonconditional -> FROM VAR arrfunc nonconditionalF .

    ID              reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    RETURN          reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    READ            reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WRITE           reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    IF              reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    VAR             reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WHILE           reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    FROM            reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    R_CURPAR        reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)


state 231

    (87) nonconditionalF -> EQUAL . np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 287

state 232

    (86) nonconditional -> FROM VAR np_addId nonconditionalF .

    ID              reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    RETURN          reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    READ            reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    WRITE           reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    IF              reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    VAR             reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    WHILE           reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    FROM            reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    R_CURPAR        reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)


state 233

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON . empty
    (118) empty -> .

    CLASS           reduce using rule 118 (empty -> .)
    VARS            reduce using rule 118 (empty -> .)
    MAIN            reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    CHAR            reduce using rule 118 (empty -> .)
    BOOL            reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)

    empty                          shift and go to state 288

state 234

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .

    MAIN            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    INT             reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    FLOAT           reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    CHAR            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    BOOL            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    ID              reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    VOID            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    METHODS         reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    L_CURPAR        reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)


state 235

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR np_endFunc empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    statement                      shift and go to state 289
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 236

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR np_endFunc empty

    R_CURPAR        shift and go to state 290


state 237

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType . np_addParam SEMICOLON np_getDec np_addToDic parameterF
    (125) np_addParam -> .

    SEMICOLON       reduce using rule 125 (np_addParam -> .)

    np_addParam                    shift and go to state 291

state 238

    (36) typepar -> INT empty .

    SEMICOLON       reduce using rule 36 (typepar -> INT empty .)


state 239

    (37) typepar -> FLOAT empty .

    SEMICOLON       reduce using rule 37 (typepar -> FLOAT empty .)


state 240

    (38) typepar -> CHAR empty .

    SEMICOLON       reduce using rule 38 (typepar -> CHAR empty .)


state 241

    (39) typepar -> BOOL empty .

    SEMICOLON       reduce using rule 39 (typepar -> BOOL empty .)


state 242

    (40) typepar -> ID empty .

    SEMICOLON       reduce using rule 40 (typepar -> ID empty .)


state 243

    (78) assigmentF -> EQUAL np_addOp exp . np_doAssign empty
    (141) np_doAssign -> .

    SEMICOLON       reduce using rule 141 (np_doAssign -> .)

    np_doAssign                    shift and go to state 292

state 244

    (79) assigmentF -> ope np_addOp exp . np_doAssign empty
    (141) np_doAssign -> .

    SEMICOLON       reduce using rule 141 (np_doAssign -> .)

    np_doAssign                    shift and go to state 293

state 245

    (51) void -> ID DOT ID L_PAR voidT .

    SEMICOLON       reduce using rule 51 (void -> ID DOT ID L_PAR voidT .)


state 246

    (53) voidT -> exp . np_checkParam COMMA voidT
    (54) voidT -> exp . np_checkParam voidF
    (155) np_checkParam -> .

    COMMA           reduce using rule 155 (np_checkParam -> .)
    R_PAR           reduce using rule 155 (np_checkParam -> .)

    np_checkParam                  shift and go to state 294

state 247

    (55) voidT -> voidF .

    SEMICOLON       reduce using rule 55 (voidT -> voidF .)


state 248

    (56) voidF -> R_PAR . np_endVoid empty
    (156) np_endVoid -> .

    SEMICOLON       reduce using rule 156 (np_endVoid -> .)

    np_endVoid                     shift and go to state 295

state 249

    (52) void -> ID np_checkVoid L_PAR np_eraQuad voidT .

    SEMICOLON       reduce using rule 52 (void -> ID np_checkVoid L_PAR np_eraQuad voidT .)


state 250

    (109) factor -> L_PAR np_addPar exp . R_PAR np_popPar empty

    R_PAR           shift and go to state 296


state 251

    (59) return -> RETURN L_PAR exp np_addReturn R_PAR . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 297

state 252

    (88) bool -> logical np_addBool boolF .

    R_PAR           reduce using rule 88 (bool -> logical np_addBool boolF .)
    COMMA           reduce using rule 88 (bool -> logical np_addBool boolF .)
    R_BREAK         reduce using rule 88 (bool -> logical np_addBool boolF .)
    SEMICOLON       reduce using rule 88 (bool -> logical np_addBool boolF .)
    TO              reduce using rule 88 (bool -> logical np_addBool boolF .)
    DO              reduce using rule 88 (bool -> logical np_addBool boolF .)


state 253

    (89) boolF -> OR . np_addOp bool
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 298

state 254

    (90) boolF -> AND . np_addOp bool
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 299

state 255

    (91) boolF -> empty .

    R_PAR           reduce using rule 91 (boolF -> empty .)
    COMMA           reduce using rule 91 (boolF -> empty .)
    R_BREAK         reduce using rule 91 (boolF -> empty .)
    SEMICOLON       reduce using rule 91 (boolF -> empty .)
    TO              reduce using rule 91 (boolF -> empty .)
    DO              reduce using rule 91 (boolF -> empty .)


state 256

    (92) logical -> ex np_addLogical logicalF .

    OR              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    AND             reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_PAR           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    COMMA           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_BREAK         reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    SEMICOLON       reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    TO              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    DO              reduce using rule 92 (logical -> ex np_addLogical logicalF .)


state 257

    (93) logicalF -> LESS . np_addOp logical
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 300

state 258

    (94) logicalF -> GREATER . np_addOp logical
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 301

state 259

    (95) logicalF -> LESS_TH . np_addOp logical
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 302

state 260

    (96) logicalF -> GREAT_TH . np_addOp logical
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 303

state 261

    (97) logicalF -> SAME . np_addOp logical
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 304

state 262

    (98) logicalF -> DIF . np_addOp logical
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 305

state 263

    (99) logicalF -> empty .

    OR              reduce using rule 99 (logicalF -> empty .)
    AND             reduce using rule 99 (logicalF -> empty .)
    R_PAR           reduce using rule 99 (logicalF -> empty .)
    COMMA           reduce using rule 99 (logicalF -> empty .)
    R_BREAK         reduce using rule 99 (logicalF -> empty .)
    SEMICOLON       reduce using rule 99 (logicalF -> empty .)
    TO              reduce using rule 99 (logicalF -> empty .)
    DO              reduce using rule 99 (logicalF -> empty .)


state 264

    (101) ex -> term np_addEx exF .

    LESS            reduce using rule 101 (ex -> term np_addEx exF .)
    GREATER         reduce using rule 101 (ex -> term np_addEx exF .)
    LESS_TH         reduce using rule 101 (ex -> term np_addEx exF .)
    GREAT_TH        reduce using rule 101 (ex -> term np_addEx exF .)
    SAME            reduce using rule 101 (ex -> term np_addEx exF .)
    DIF             reduce using rule 101 (ex -> term np_addEx exF .)
    OR              reduce using rule 101 (ex -> term np_addEx exF .)
    AND             reduce using rule 101 (ex -> term np_addEx exF .)
    R_PAR           reduce using rule 101 (ex -> term np_addEx exF .)
    COMMA           reduce using rule 101 (ex -> term np_addEx exF .)
    R_BREAK         reduce using rule 101 (ex -> term np_addEx exF .)
    SEMICOLON       reduce using rule 101 (ex -> term np_addEx exF .)
    TO              reduce using rule 101 (ex -> term np_addEx exF .)
    DO              reduce using rule 101 (ex -> term np_addEx exF .)


state 265

    (102) exF -> PLUS . np_addOp ex
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 306

state 266

    (103) exF -> MINUS . np_addOp ex
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 307

state 267

    (104) exF -> empty .

    LESS            reduce using rule 104 (exF -> empty .)
    GREATER         reduce using rule 104 (exF -> empty .)
    LESS_TH         reduce using rule 104 (exF -> empty .)
    GREAT_TH        reduce using rule 104 (exF -> empty .)
    SAME            reduce using rule 104 (exF -> empty .)
    DIF             reduce using rule 104 (exF -> empty .)
    OR              reduce using rule 104 (exF -> empty .)
    AND             reduce using rule 104 (exF -> empty .)
    R_PAR           reduce using rule 104 (exF -> empty .)
    COMMA           reduce using rule 104 (exF -> empty .)
    R_BREAK         reduce using rule 104 (exF -> empty .)
    SEMICOLON       reduce using rule 104 (exF -> empty .)
    TO              reduce using rule 104 (exF -> empty .)
    DO              reduce using rule 104 (exF -> empty .)


state 268

    (105) term -> factor np_addTerm termF .

    PLUS            reduce using rule 105 (term -> factor np_addTerm termF .)
    MINUS           reduce using rule 105 (term -> factor np_addTerm termF .)
    LESS            reduce using rule 105 (term -> factor np_addTerm termF .)
    GREATER         reduce using rule 105 (term -> factor np_addTerm termF .)
    LESS_TH         reduce using rule 105 (term -> factor np_addTerm termF .)
    GREAT_TH        reduce using rule 105 (term -> factor np_addTerm termF .)
    SAME            reduce using rule 105 (term -> factor np_addTerm termF .)
    DIF             reduce using rule 105 (term -> factor np_addTerm termF .)
    OR              reduce using rule 105 (term -> factor np_addTerm termF .)
    AND             reduce using rule 105 (term -> factor np_addTerm termF .)
    R_PAR           reduce using rule 105 (term -> factor np_addTerm termF .)
    COMMA           reduce using rule 105 (term -> factor np_addTerm termF .)
    R_BREAK         reduce using rule 105 (term -> factor np_addTerm termF .)
    SEMICOLON       reduce using rule 105 (term -> factor np_addTerm termF .)
    TO              reduce using rule 105 (term -> factor np_addTerm termF .)
    DO              reduce using rule 105 (term -> factor np_addTerm termF .)


state 269

    (106) termF -> MULT . np_addOp term
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 308

state 270

    (107) termF -> DIV . np_addOp term
    (134) np_addOp -> .

    L_PAR           reduce using rule 134 (np_addOp -> .)
    CTE_INT         reduce using rule 134 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 134 (np_addOp -> .)
    CTE_CHAR        reduce using rule 134 (np_addOp -> .)
    CTE_BOOL        reduce using rule 134 (np_addOp -> .)
    MINUS           reduce using rule 134 (np_addOp -> .)
    VAR             reduce using rule 134 (np_addOp -> .)
    ID              reduce using rule 134 (np_addOp -> .)

    np_addOp                       shift and go to state 309

state 271

    (108) termF -> empty .

    PLUS            reduce using rule 108 (termF -> empty .)
    MINUS           reduce using rule 108 (termF -> empty .)
    LESS            reduce using rule 108 (termF -> empty .)
    GREATER         reduce using rule 108 (termF -> empty .)
    LESS_TH         reduce using rule 108 (termF -> empty .)
    GREAT_TH        reduce using rule 108 (termF -> empty .)
    SAME            reduce using rule 108 (termF -> empty .)
    DIF             reduce using rule 108 (termF -> empty .)
    OR              reduce using rule 108 (termF -> empty .)
    AND             reduce using rule 108 (termF -> empty .)
    R_PAR           reduce using rule 108 (termF -> empty .)
    COMMA           reduce using rule 108 (termF -> empty .)
    R_BREAK         reduce using rule 108 (termF -> empty .)
    SEMICOLON       reduce using rule 108 (termF -> empty .)
    TO              reduce using rule 108 (termF -> empty .)
    DO              reduce using rule 108 (termF -> empty .)


state 272

    (114) varcte -> CTE_INT np_addConstInt empty .

    MULT            reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    DIV             reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    PLUS            reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    MINUS           reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    LESS            reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    GREATER         reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    LESS_TH         reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    GREAT_TH        reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    SAME            reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    DIF             reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    OR              reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    AND             reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    R_PAR           reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    COMMA           reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    R_BREAK         reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    SEMICOLON       reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    TO              reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)
    DO              reduce using rule 114 (varcte -> CTE_INT np_addConstInt empty .)


state 273

    (115) varcte -> CTE_FLOAT np_addConstFloat empty .

    MULT            reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    DIV             reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    PLUS            reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    MINUS           reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    LESS            reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    GREATER         reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    LESS_TH         reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    GREAT_TH        reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    SAME            reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    DIF             reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    OR              reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    AND             reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    R_PAR           reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    COMMA           reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    R_BREAK         reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    SEMICOLON       reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    TO              reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    DO              reduce using rule 115 (varcte -> CTE_FLOAT np_addConstFloat empty .)


state 274

    (116) varcte -> CTE_CHAR np_addConstChar empty .

    MULT            reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    DIV             reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    PLUS            reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    MINUS           reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    LESS            reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    GREATER         reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    LESS_TH         reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    GREAT_TH        reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    SAME            reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    DIF             reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    OR              reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    AND             reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    R_PAR           reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    COMMA           reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    R_BREAK         reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    SEMICOLON       reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    TO              reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)
    DO              reduce using rule 116 (varcte -> CTE_CHAR np_addConstChar empty .)


state 275

    (117) varcte -> CTE_BOOL np_addConstBool empty .

    MULT            reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    DIV             reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    PLUS            reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    MINUS           reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    LESS            reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    GREATER         reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    LESS_TH         reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    GREAT_TH        reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    SAME            reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    DIF             reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    OR              reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    AND             reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    R_PAR           reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    COMMA           reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    R_BREAK         reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    SEMICOLON       reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    TO              reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)
    DO              reduce using rule 117 (varcte -> CTE_BOOL np_addConstBool empty .)


state 276

    (112) factorF -> MINUS var np_addId . empty
    (118) empty -> .

    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 310

state 277

    (113) factorF -> var np_addId empty .

    MULT            reduce using rule 113 (factorF -> var np_addId empty .)
    DIV             reduce using rule 113 (factorF -> var np_addId empty .)
    PLUS            reduce using rule 113 (factorF -> var np_addId empty .)
    MINUS           reduce using rule 113 (factorF -> var np_addId empty .)
    LESS            reduce using rule 113 (factorF -> var np_addId empty .)
    GREATER         reduce using rule 113 (factorF -> var np_addId empty .)
    LESS_TH         reduce using rule 113 (factorF -> var np_addId empty .)
    GREAT_TH        reduce using rule 113 (factorF -> var np_addId empty .)
    SAME            reduce using rule 113 (factorF -> var np_addId empty .)
    DIF             reduce using rule 113 (factorF -> var np_addId empty .)
    OR              reduce using rule 113 (factorF -> var np_addId empty .)
    AND             reduce using rule 113 (factorF -> var np_addId empty .)
    R_PAR           reduce using rule 113 (factorF -> var np_addId empty .)
    COMMA           reduce using rule 113 (factorF -> var np_addId empty .)
    R_BREAK         reduce using rule 113 (factorF -> var np_addId empty .)
    SEMICOLON       reduce using rule 113 (factorF -> var np_addId empty .)
    TO              reduce using rule 113 (factorF -> var np_addId empty .)
    DO              reduce using rule 113 (factorF -> var np_addId empty .)


state 278

    (65) readF -> var np_addRead COMMA . readF
    (65) readF -> . var np_addRead COMMA readF
    (66) readF -> . var np_addRead R_PAR empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 102
    ID              shift and go to state 174

    var                            shift and go to state 176
    readF                          shift and go to state 311

state 279

    (66) readF -> var np_addRead R_PAR . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 312

state 280

    (68) writeT -> CTE_STRING np_addConstString writeF .

    SEMICOLON       reduce using rule 68 (writeT -> CTE_STRING np_addConstString writeF .)


state 281

    (70) writeF -> COMMA np_addWrite . writeT
    (68) writeT -> . CTE_STRING np_addConstString writeF
    (69) writeT -> . exp writeF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 178
    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    writeT                         shift and go to state 313
    exp                            shift and go to state 179
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 282

    (71) writeF -> R_PAR np_addWrite . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 314

state 283

    (74) if -> IF L_PAR exp np_checkBool R_PAR . THEN L_CURPAR statement R_CURPAR ifF

    THEN            shift and go to state 315


state 284

    (57) arrfunc -> L_BREAK exp COMMA exp . R_BREAK empty

    R_BREAK         shift and go to state 316


state 285

    (58) arrfunc -> L_BREAK exp R_BREAK empty .

    EQUAL           reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MIN_EQ          reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT_EQ         reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV_EQ          reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT            reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV             reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS            reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MINUS           reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS            reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREATER         reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS_TH         reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREAT_TH        reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SAME            reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIF             reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    OR              reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    AND             reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_PAR           reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    COMMA           reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_BREAK         reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SEMICOLON       reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    TO              reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DO              reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)


state 286

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR . np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (145) np_checkBool -> .

    DO              reduce using rule 145 (np_checkBool -> .)

    np_checkBool                   shift and go to state 317

state 287

    (87) nonconditionalF -> EQUAL np_addOp . exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 318
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 288

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .

    CLASS           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VARS            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    MAIN            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    INT             reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    FLOAT           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    CHAR            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    BOOL            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    ID              reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VOID            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)


state 289

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR np_endFunc empty

    R_CURPAR        shift and go to state 319


state 290

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . np_endFunc empty
    (127) np_endFunc -> .

    MAIN            reduce using rule 127 (np_endFunc -> .)
    INT             reduce using rule 127 (np_endFunc -> .)
    FLOAT           reduce using rule 127 (np_endFunc -> .)
    CHAR            reduce using rule 127 (np_endFunc -> .)
    BOOL            reduce using rule 127 (np_endFunc -> .)
    ID              reduce using rule 127 (np_endFunc -> .)
    VOID            reduce using rule 127 (np_endFunc -> .)
    R_CURPAR        reduce using rule 127 (np_endFunc -> .)

    np_endFunc                     shift and go to state 320

state 291

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam . SEMICOLON np_getDec np_addToDic parameterF

    SEMICOLON       shift and go to state 321


state 292

    (78) assigmentF -> EQUAL np_addOp exp np_doAssign . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 322

state 293

    (79) assigmentF -> ope np_addOp exp np_doAssign . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 323

state 294

    (53) voidT -> exp np_checkParam . COMMA voidT
    (54) voidT -> exp np_checkParam . voidF
    (56) voidF -> . R_PAR np_endVoid empty

    COMMA           shift and go to state 324
    R_PAR           shift and go to state 248

    voidF                          shift and go to state 325

state 295

    (56) voidF -> R_PAR np_endVoid . empty
    (118) empty -> .

    SEMICOLON       reduce using rule 118 (empty -> .)

    empty                          shift and go to state 326

state 296

    (109) factor -> L_PAR np_addPar exp R_PAR . np_popPar empty
    (136) np_popPar -> .

    MULT            reduce using rule 136 (np_popPar -> .)
    DIV             reduce using rule 136 (np_popPar -> .)
    PLUS            reduce using rule 136 (np_popPar -> .)
    MINUS           reduce using rule 136 (np_popPar -> .)
    LESS            reduce using rule 136 (np_popPar -> .)
    GREATER         reduce using rule 136 (np_popPar -> .)
    LESS_TH         reduce using rule 136 (np_popPar -> .)
    GREAT_TH        reduce using rule 136 (np_popPar -> .)
    SAME            reduce using rule 136 (np_popPar -> .)
    DIF             reduce using rule 136 (np_popPar -> .)
    OR              reduce using rule 136 (np_popPar -> .)
    AND             reduce using rule 136 (np_popPar -> .)
    R_PAR           reduce using rule 136 (np_popPar -> .)
    COMMA           reduce using rule 136 (np_popPar -> .)
    R_BREAK         reduce using rule 136 (np_popPar -> .)
    SEMICOLON       reduce using rule 136 (np_popPar -> .)
    TO              reduce using rule 136 (np_popPar -> .)
    DO              reduce using rule 136 (np_popPar -> .)

    np_popPar                      shift and go to state 327

state 297

    (59) return -> RETURN L_PAR exp np_addReturn R_PAR empty .

    SEMICOLON       reduce using rule 59 (return -> RETURN L_PAR exp np_addReturn R_PAR empty .)


state 298

    (89) boolF -> OR np_addOp . bool
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    bool                           shift and go to state 328
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 299

    (90) boolF -> AND np_addOp . bool
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    bool                           shift and go to state 329
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 300

    (93) logicalF -> LESS np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    logical                        shift and go to state 330
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 301

    (94) logicalF -> GREATER np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    logical                        shift and go to state 331
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 302

    (95) logicalF -> LESS_TH np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    logical                        shift and go to state 332
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 303

    (96) logicalF -> GREAT_TH np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    logical                        shift and go to state 333
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 304

    (97) logicalF -> SAME np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    logical                        shift and go to state 334
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 305

    (98) logicalF -> DIF np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    logical                        shift and go to state 335
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 306

    (102) exF -> PLUS np_addOp . ex
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    ex                             shift and go to state 336
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 307

    (103) exF -> MINUS np_addOp . ex
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    ex                             shift and go to state 337
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 308

    (106) termF -> MULT np_addOp . term
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    term                           shift and go to state 338
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 309

    (107) termF -> DIV np_addOp . term
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    term                           shift and go to state 339
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 310

    (112) factorF -> MINUS var np_addId empty .

    MULT            reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    DIV             reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    PLUS            reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    MINUS           reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    LESS            reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    GREATER         reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    LESS_TH         reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    GREAT_TH        reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    SAME            reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    DIF             reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    OR              reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    AND             reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    R_PAR           reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    COMMA           reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    R_BREAK         reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    SEMICOLON       reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    TO              reduce using rule 112 (factorF -> MINUS var np_addId empty .)
    DO              reduce using rule 112 (factorF -> MINUS var np_addId empty .)


state 311

    (65) readF -> var np_addRead COMMA readF .

    SEMICOLON       reduce using rule 65 (readF -> var np_addRead COMMA readF .)


state 312

    (66) readF -> var np_addRead R_PAR empty .

    SEMICOLON       reduce using rule 66 (readF -> var np_addRead R_PAR empty .)


state 313

    (70) writeF -> COMMA np_addWrite writeT .

    SEMICOLON       reduce using rule 70 (writeF -> COMMA np_addWrite writeT .)


state 314

    (71) writeF -> R_PAR np_addWrite empty .

    SEMICOLON       reduce using rule 71 (writeF -> R_PAR np_addWrite empty .)


state 315

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN . L_CURPAR statement R_CURPAR ifF

    L_CURPAR        shift and go to state 340


state 316

    (57) arrfunc -> L_BREAK exp COMMA exp R_BREAK . empty
    (118) empty -> .

    EQUAL           reduce using rule 118 (empty -> .)
    PLUS_EQ         reduce using rule 118 (empty -> .)
    MIN_EQ          reduce using rule 118 (empty -> .)
    MULT_EQ         reduce using rule 118 (empty -> .)
    DIV_EQ          reduce using rule 118 (empty -> .)
    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 341

state 317

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool . DO L_CURPAR statement R_CURPAR np_endWhile empty

    DO              shift and go to state 342


state 318

    (87) nonconditionalF -> EQUAL np_addOp exp . np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
    (150) np_assingFor -> .

    TO              reduce using rule 150 (np_assingFor -> .)

    np_assingFor                   shift and go to state 343

state 319

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . np_endFunc empty
    (127) np_endFunc -> .

    MAIN            reduce using rule 127 (np_endFunc -> .)
    INT             reduce using rule 127 (np_endFunc -> .)
    FLOAT           reduce using rule 127 (np_endFunc -> .)
    CHAR            reduce using rule 127 (np_endFunc -> .)
    BOOL            reduce using rule 127 (np_endFunc -> .)
    ID              reduce using rule 127 (np_endFunc -> .)
    VOID            reduce using rule 127 (np_endFunc -> .)
    R_CURPAR        reduce using rule 127 (np_endFunc -> .)

    np_endFunc                     shift and go to state 344

state 320

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc . empty
    (118) empty -> .

    MAIN            reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    CHAR            reduce using rule 118 (empty -> .)
    BOOL            reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    R_CURPAR        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 345

state 321

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON . np_getDec np_addToDic parameterF
    (122) np_getDec -> .

    VAR             reduce using rule 122 (np_getDec -> .)
    R_PAR           reduce using rule 122 (np_getDec -> .)

    np_getDec                      shift and go to state 346

state 322

    (78) assigmentF -> EQUAL np_addOp exp np_doAssign empty .

    SEMICOLON       reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)


state 323

    (79) assigmentF -> ope np_addOp exp np_doAssign empty .

    SEMICOLON       reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)


state 324

    (53) voidT -> exp np_checkParam COMMA . voidT
    (53) voidT -> . exp np_checkParam COMMA voidT
    (54) voidT -> . exp np_checkParam voidF
    (55) voidT -> . voidF
    (100) exp -> . bool empty
    (56) voidF -> . R_PAR np_endVoid empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 248
    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 246
    voidT                          shift and go to state 347
    voidF                          shift and go to state 247
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 325

    (54) voidT -> exp np_checkParam voidF .

    SEMICOLON       reduce using rule 54 (voidT -> exp np_checkParam voidF .)


state 326

    (56) voidF -> R_PAR np_endVoid empty .

    SEMICOLON       reduce using rule 56 (voidF -> R_PAR np_endVoid empty .)


state 327

    (109) factor -> L_PAR np_addPar exp R_PAR np_popPar . empty
    (118) empty -> .

    MULT            reduce using rule 118 (empty -> .)
    DIV             reduce using rule 118 (empty -> .)
    PLUS            reduce using rule 118 (empty -> .)
    MINUS           reduce using rule 118 (empty -> .)
    LESS            reduce using rule 118 (empty -> .)
    GREATER         reduce using rule 118 (empty -> .)
    LESS_TH         reduce using rule 118 (empty -> .)
    GREAT_TH        reduce using rule 118 (empty -> .)
    SAME            reduce using rule 118 (empty -> .)
    DIF             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    R_PAR           reduce using rule 118 (empty -> .)
    COMMA           reduce using rule 118 (empty -> .)
    R_BREAK         reduce using rule 118 (empty -> .)
    SEMICOLON       reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    DO              reduce using rule 118 (empty -> .)

    empty                          shift and go to state 348

state 328

    (89) boolF -> OR np_addOp bool .

    R_PAR           reduce using rule 89 (boolF -> OR np_addOp bool .)
    COMMA           reduce using rule 89 (boolF -> OR np_addOp bool .)
    R_BREAK         reduce using rule 89 (boolF -> OR np_addOp bool .)
    SEMICOLON       reduce using rule 89 (boolF -> OR np_addOp bool .)
    TO              reduce using rule 89 (boolF -> OR np_addOp bool .)
    DO              reduce using rule 89 (boolF -> OR np_addOp bool .)


state 329

    (90) boolF -> AND np_addOp bool .

    R_PAR           reduce using rule 90 (boolF -> AND np_addOp bool .)
    COMMA           reduce using rule 90 (boolF -> AND np_addOp bool .)
    R_BREAK         reduce using rule 90 (boolF -> AND np_addOp bool .)
    SEMICOLON       reduce using rule 90 (boolF -> AND np_addOp bool .)
    TO              reduce using rule 90 (boolF -> AND np_addOp bool .)
    DO              reduce using rule 90 (boolF -> AND np_addOp bool .)


state 330

    (93) logicalF -> LESS np_addOp logical .

    OR              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    AND             reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_PAR           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    COMMA           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_BREAK         reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    SEMICOLON       reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    TO              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    DO              reduce using rule 93 (logicalF -> LESS np_addOp logical .)


state 331

    (94) logicalF -> GREATER np_addOp logical .

    OR              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    AND             reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_PAR           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    COMMA           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_BREAK         reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    SEMICOLON       reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    TO              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    DO              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)


state 332

    (95) logicalF -> LESS_TH np_addOp logical .

    OR              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    AND             reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_PAR           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    COMMA           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_BREAK         reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    SEMICOLON       reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    TO              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    DO              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)


state 333

    (96) logicalF -> GREAT_TH np_addOp logical .

    OR              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    AND             reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_PAR           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    COMMA           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_BREAK         reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    SEMICOLON       reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    TO              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    DO              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)


state 334

    (97) logicalF -> SAME np_addOp logical .

    OR              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    AND             reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_PAR           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    COMMA           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_BREAK         reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    SEMICOLON       reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    TO              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    DO              reduce using rule 97 (logicalF -> SAME np_addOp logical .)


state 335

    (98) logicalF -> DIF np_addOp logical .

    OR              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    AND             reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_PAR           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    COMMA           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_BREAK         reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    SEMICOLON       reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    TO              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    DO              reduce using rule 98 (logicalF -> DIF np_addOp logical .)


state 336

    (102) exF -> PLUS np_addOp ex .

    LESS            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    GREATER         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    LESS_TH         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    GREAT_TH        reduce using rule 102 (exF -> PLUS np_addOp ex .)
    SAME            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    DIF             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    OR              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    AND             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_PAR           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    COMMA           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_BREAK         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    SEMICOLON       reduce using rule 102 (exF -> PLUS np_addOp ex .)
    TO              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    DO              reduce using rule 102 (exF -> PLUS np_addOp ex .)


state 337

    (103) exF -> MINUS np_addOp ex .

    LESS            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    GREATER         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    LESS_TH         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    GREAT_TH        reduce using rule 103 (exF -> MINUS np_addOp ex .)
    SAME            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    DIF             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    OR              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    AND             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_PAR           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    COMMA           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_BREAK         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    SEMICOLON       reduce using rule 103 (exF -> MINUS np_addOp ex .)
    TO              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    DO              reduce using rule 103 (exF -> MINUS np_addOp ex .)


state 338

    (106) termF -> MULT np_addOp term .

    PLUS            reduce using rule 106 (termF -> MULT np_addOp term .)
    MINUS           reduce using rule 106 (termF -> MULT np_addOp term .)
    LESS            reduce using rule 106 (termF -> MULT np_addOp term .)
    GREATER         reduce using rule 106 (termF -> MULT np_addOp term .)
    LESS_TH         reduce using rule 106 (termF -> MULT np_addOp term .)
    GREAT_TH        reduce using rule 106 (termF -> MULT np_addOp term .)
    SAME            reduce using rule 106 (termF -> MULT np_addOp term .)
    DIF             reduce using rule 106 (termF -> MULT np_addOp term .)
    OR              reduce using rule 106 (termF -> MULT np_addOp term .)
    AND             reduce using rule 106 (termF -> MULT np_addOp term .)
    R_PAR           reduce using rule 106 (termF -> MULT np_addOp term .)
    COMMA           reduce using rule 106 (termF -> MULT np_addOp term .)
    R_BREAK         reduce using rule 106 (termF -> MULT np_addOp term .)
    SEMICOLON       reduce using rule 106 (termF -> MULT np_addOp term .)
    TO              reduce using rule 106 (termF -> MULT np_addOp term .)
    DO              reduce using rule 106 (termF -> MULT np_addOp term .)


state 339

    (107) termF -> DIV np_addOp term .

    PLUS            reduce using rule 107 (termF -> DIV np_addOp term .)
    MINUS           reduce using rule 107 (termF -> DIV np_addOp term .)
    LESS            reduce using rule 107 (termF -> DIV np_addOp term .)
    GREATER         reduce using rule 107 (termF -> DIV np_addOp term .)
    LESS_TH         reduce using rule 107 (termF -> DIV np_addOp term .)
    GREAT_TH        reduce using rule 107 (termF -> DIV np_addOp term .)
    SAME            reduce using rule 107 (termF -> DIV np_addOp term .)
    DIF             reduce using rule 107 (termF -> DIV np_addOp term .)
    OR              reduce using rule 107 (termF -> DIV np_addOp term .)
    AND             reduce using rule 107 (termF -> DIV np_addOp term .)
    R_PAR           reduce using rule 107 (termF -> DIV np_addOp term .)
    COMMA           reduce using rule 107 (termF -> DIV np_addOp term .)
    R_BREAK         reduce using rule 107 (termF -> DIV np_addOp term .)
    SEMICOLON       reduce using rule 107 (termF -> DIV np_addOp term .)
    TO              reduce using rule 107 (termF -> DIV np_addOp term .)
    DO              reduce using rule 107 (termF -> DIV np_addOp term .)


state 340

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR . statement R_CURPAR ifF
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    statement                      shift and go to state 349
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 341

    (57) arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .

    EQUAL           reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MIN_EQ          reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT_EQ         reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV_EQ          reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT            reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV             reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS            reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MINUS           reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS            reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREATER         reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS_TH         reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREAT_TH        reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SAME            reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIF             reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    OR              reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    AND             reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_PAR           reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    COMMA           reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_BREAK         reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SEMICOLON       reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    TO              reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DO              reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)


state 342

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO . L_CURPAR statement R_CURPAR np_endWhile empty

    L_CURPAR        shift and go to state 350


state 343

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor . TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty

    TO              shift and go to state 351


state 344

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc . empty
    (118) empty -> .

    MAIN            reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    CHAR            reduce using rule 118 (empty -> .)
    BOOL            reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    R_CURPAR        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 352

state 345

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .

    MAIN            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    INT             reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    FLOAT           reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    CHAR            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    BOOL            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    ID              reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    VOID            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    R_CURPAR        reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)


state 346

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec . np_addToDic parameterF
    (126) np_addToDic -> .

    VAR             reduce using rule 126 (np_addToDic -> .)
    R_PAR           reduce using rule 126 (np_addToDic -> .)

    np_addToDic                    shift and go to state 353

state 347

    (53) voidT -> exp np_checkParam COMMA voidT .

    SEMICOLON       reduce using rule 53 (voidT -> exp np_checkParam COMMA voidT .)


state 348

    (109) factor -> L_PAR np_addPar exp R_PAR np_popPar empty .

    MULT            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIV             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    PLUS            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    MINUS           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREATER         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS_TH         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREAT_TH        reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SAME            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIF             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    OR              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    AND             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_PAR           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    COMMA           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_BREAK         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SEMICOLON       reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    TO              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DO              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)


state 349

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement . R_CURPAR ifF

    R_CURPAR        shift and go to state 354


state 350

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR . statement R_CURPAR np_endWhile empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    statement                      shift and go to state 355
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 351

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO . exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . varcte empty
    (111) factor -> . factorF
    (114) varcte -> . CTE_INT np_addConstInt empty
    (115) varcte -> . CTE_FLOAT np_addConstFloat empty
    (116) varcte -> . CTE_CHAR np_addConstChar empty
    (117) varcte -> . CTE_BOOL np_addConstBool empty
    (112) factorF -> . MINUS var np_addId empty
    (113) factorF -> . var np_addId empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 159
    CTE_INT         shift and go to state 168
    CTE_FLOAT       shift and go to state 169
    CTE_CHAR        shift and go to state 170
    CTE_BOOL        shift and go to state 171
    MINUS           shift and go to state 172
    VAR             shift and go to state 102
    ID              shift and go to state 174

    exp                            shift and go to state 356
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    varcte                         shift and go to state 166
    factorF                        shift and go to state 167
    var                            shift and go to state 173

state 352

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .

    MAIN            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    INT             reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    FLOAT           reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    CHAR            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    BOOL            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    ID              reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    VOID            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    R_CURPAR        reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)


state 353

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec np_addToDic . parameterF
    (34) parameterF -> . parameter
    (35) parameterF -> . empty
    (33) parameter -> . VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec np_addToDic parameterF
    (118) empty -> .

    VAR             shift and go to state 85
    R_PAR           reduce using rule 118 (empty -> .)

    parameterF                     shift and go to state 357
    parameter                      shift and go to state 358
    empty                          shift and go to state 359

state 354

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR . ifF
    (75) ifF -> . ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty
    (76) ifF -> . np_endIf empty
    (146) np_endIf -> .

    ELSE            shift and go to state 361
    ID              reduce using rule 146 (np_endIf -> .)
    RETURN          reduce using rule 146 (np_endIf -> .)
    READ            reduce using rule 146 (np_endIf -> .)
    WRITE           reduce using rule 146 (np_endIf -> .)
    IF              reduce using rule 146 (np_endIf -> .)
    VAR             reduce using rule 146 (np_endIf -> .)
    WHILE           reduce using rule 146 (np_endIf -> .)
    FROM            reduce using rule 146 (np_endIf -> .)
    R_CURPAR        reduce using rule 146 (np_endIf -> .)

    ifF                            shift and go to state 360
    np_endIf                       shift and go to state 362

state 355

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement . R_CURPAR np_endWhile empty

    R_CURPAR        shift and go to state 363


state 356

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp . np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
    (151) np_checkExp -> .

    DO              reduce using rule 151 (np_checkExp -> .)

    np_checkExp                    shift and go to state 364

state 357

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec np_addToDic parameterF .

    R_PAR           reduce using rule 33 (parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec np_addToDic parameterF .)


state 358

    (34) parameterF -> parameter .

    R_PAR           reduce using rule 34 (parameterF -> parameter .)


state 359

    (35) parameterF -> empty .

    R_PAR           reduce using rule 35 (parameterF -> empty .)


state 360

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .

    ID              reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    RETURN          reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    READ            reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    WRITE           reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    IF              reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    VAR             reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    WHILE           reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    FROM            reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    R_CURPAR        reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)


state 361

    (75) ifF -> ELSE . np_else L_CURPAR statement R_CURPAR np_endIf empty
    (147) np_else -> .

    L_CURPAR        reduce using rule 147 (np_else -> .)

    np_else                        shift and go to state 365

state 362

    (76) ifF -> np_endIf . empty
    (118) empty -> .

    ID              reduce using rule 118 (empty -> .)
    RETURN          reduce using rule 118 (empty -> .)
    READ            reduce using rule 118 (empty -> .)
    WRITE           reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    VAR             reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FROM            reduce using rule 118 (empty -> .)
    R_CURPAR        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 366

state 363

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR . np_endWhile empty
    (149) np_endWhile -> .

    ID              reduce using rule 149 (np_endWhile -> .)
    RETURN          reduce using rule 149 (np_endWhile -> .)
    READ            reduce using rule 149 (np_endWhile -> .)
    WRITE           reduce using rule 149 (np_endWhile -> .)
    IF              reduce using rule 149 (np_endWhile -> .)
    VAR             reduce using rule 149 (np_endWhile -> .)
    WHILE           reduce using rule 149 (np_endWhile -> .)
    FROM            reduce using rule 149 (np_endWhile -> .)
    R_CURPAR        reduce using rule 149 (np_endWhile -> .)

    np_endWhile                    shift and go to state 367

state 364

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp . DO L_CURPAR statement R_CURPAR np_endFor empty

    DO              shift and go to state 368


state 365

    (75) ifF -> ELSE np_else . L_CURPAR statement R_CURPAR np_endIf empty

    L_CURPAR        shift and go to state 369


state 366

    (76) ifF -> np_endIf empty .

    ID              reduce using rule 76 (ifF -> np_endIf empty .)
    RETURN          reduce using rule 76 (ifF -> np_endIf empty .)
    READ            reduce using rule 76 (ifF -> np_endIf empty .)
    WRITE           reduce using rule 76 (ifF -> np_endIf empty .)
    IF              reduce using rule 76 (ifF -> np_endIf empty .)
    VAR             reduce using rule 76 (ifF -> np_endIf empty .)
    WHILE           reduce using rule 76 (ifF -> np_endIf empty .)
    FROM            reduce using rule 76 (ifF -> np_endIf empty .)
    R_CURPAR        reduce using rule 76 (ifF -> np_endIf empty .)


state 367

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile . empty
    (118) empty -> .

    ID              reduce using rule 118 (empty -> .)
    RETURN          reduce using rule 118 (empty -> .)
    READ            reduce using rule 118 (empty -> .)
    WRITE           reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    VAR             reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FROM            reduce using rule 118 (empty -> .)
    R_CURPAR        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 370

state 368

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO . L_CURPAR statement R_CURPAR np_endFor empty

    L_CURPAR        shift and go to state 371


state 369

    (75) ifF -> ELSE np_else L_CURPAR . statement R_CURPAR np_endIf empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    statement                      shift and go to state 372
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 370

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .

    ID              reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    RETURN          reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    READ            reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    WRITE           reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    IF              reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    VAR             reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    WHILE           reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    FROM            reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    R_CURPAR        reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)


state 371

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR . statement R_CURPAR np_endFor empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 95
    RETURN          shift and go to state 96
    READ            shift and go to state 97
    WRITE           shift and go to state 98
    IF              shift and go to state 99
    VAR             shift and go to state 102
    WHILE           shift and go to state 103
    FROM            shift and go to state 104

    statement                      shift and go to state 373
    assigment                      shift and go to state 87
    void                           shift and go to state 88
    return                         shift and go to state 89
    read                           shift and go to state 90
    write                          shift and go to state 91
    if                             shift and go to state 92
    repeat                         shift and go to state 93
    var                            shift and go to state 94
    conditional                    shift and go to state 100
    nonconditional                 shift and go to state 101

state 372

    (75) ifF -> ELSE np_else L_CURPAR statement . R_CURPAR np_endIf empty

    R_CURPAR        shift and go to state 374


state 373

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement . R_CURPAR np_endFor empty

    R_CURPAR        shift and go to state 375


state 374

    (75) ifF -> ELSE np_else L_CURPAR statement R_CURPAR . np_endIf empty
    (146) np_endIf -> .

    ID              reduce using rule 146 (np_endIf -> .)
    RETURN          reduce using rule 146 (np_endIf -> .)
    READ            reduce using rule 146 (np_endIf -> .)
    WRITE           reduce using rule 146 (np_endIf -> .)
    IF              reduce using rule 146 (np_endIf -> .)
    VAR             reduce using rule 146 (np_endIf -> .)
    WHILE           reduce using rule 146 (np_endIf -> .)
    FROM            reduce using rule 146 (np_endIf -> .)
    R_CURPAR        reduce using rule 146 (np_endIf -> .)

    np_endIf                       shift and go to state 376

state 375

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR . np_endFor empty
    (152) np_endFor -> .

    ID              reduce using rule 152 (np_endFor -> .)
    RETURN          reduce using rule 152 (np_endFor -> .)
    READ            reduce using rule 152 (np_endFor -> .)
    WRITE           reduce using rule 152 (np_endFor -> .)
    IF              reduce using rule 152 (np_endFor -> .)
    VAR             reduce using rule 152 (np_endFor -> .)
    WHILE           reduce using rule 152 (np_endFor -> .)
    FROM            reduce using rule 152 (np_endFor -> .)
    R_CURPAR        reduce using rule 152 (np_endFor -> .)

    np_endFor                      shift and go to state 377

state 376

    (75) ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf . empty
    (118) empty -> .

    ID              reduce using rule 118 (empty -> .)
    RETURN          reduce using rule 118 (empty -> .)
    READ            reduce using rule 118 (empty -> .)
    WRITE           reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    VAR             reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FROM            reduce using rule 118 (empty -> .)
    R_CURPAR        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 378

state 377

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor . empty
    (118) empty -> .

    ID              reduce using rule 118 (empty -> .)
    RETURN          reduce using rule 118 (empty -> .)
    READ            reduce using rule 118 (empty -> .)
    WRITE           reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    VAR             reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FROM            reduce using rule 118 (empty -> .)
    R_CURPAR        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 379

state 378

    (75) ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .

    ID              reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    RETURN          reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    READ            reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    WRITE           reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    IF              reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    VAR             reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    WHILE           reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    FROM            reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    R_CURPAR        reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)


state 379

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .

    ID              reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    RETURN          reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    READ            reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    WRITE           reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    IF              reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    VAR             reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    WHILE           reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    FROM            reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    R_CURPAR        reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)

