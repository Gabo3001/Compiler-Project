Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID np_addFunc SEMICOLON programT
Rule 2     programT -> class programT
Rule 3     programT -> vars programF
Rule 4     programT -> programF
Rule 5     programF -> func programF
Rule 6     programF -> main empty
Rule 7     class -> CLASS ID classT
Rule 8     classT -> LESS INHERIT ID GREATER classF
Rule 9     classT -> classF
Rule 10    classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty
Rule 11    vars -> VARS dec empty
Rule 12    dec -> VAR arr np_getDecArr decF
Rule 13    dec -> VAR np_getDec decF
Rule 14    decF -> COMMA dec
Rule 15    decF -> COLON type np_getVarType SEMICOLON np_getDec dec
Rule 16    decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty
Rule 17    type -> INT empty
Rule 18    type -> FLOAT empty
Rule 19    type -> CHAR empty
Rule 20    type -> BOOL empty
Rule 21    type -> ID empty
Rule 22    arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
Rule 23    arr -> L_BREAK CTE_INT R_BREAK empty
Rule 24    func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF
Rule 25    funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 26    funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 27    typeFunc -> INT empty
Rule 28    typeFunc -> FLOAT empty
Rule 29    typeFunc -> CHAR empty
Rule 30    typeFunc -> BOOL empty
Rule 31    typeFunc -> ID empty
Rule 32    typeFunc -> VOID empty
Rule 33    parameter -> VAR COLON typepar SEMICOLON parameterF
Rule 34    parameterF -> parameter
Rule 35    parameterF -> empty
Rule 36    typepar -> INT empty
Rule 37    typepar -> FLOAT empty
Rule 38    typepar -> CHAR empty
Rule 39    typepar -> BOOL empty
Rule 40    typepar -> ID empty
Rule 41    main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
Rule 42    statement -> assigment statementF
Rule 43    statement -> void statementF
Rule 44    statement -> return statementF
Rule 45    statement -> read statementF
Rule 46    statement -> write statementF
Rule 47    statement -> if statementF
Rule 48    statement -> repeat statementF
Rule 49    statementF -> statement
Rule 50    statementF -> empty
Rule 51    void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty
Rule 52    void -> ID L_PAR param R_PAR SEMICOLON empty
Rule 53    void -> ID L_PAR R_PAR SEMICOLON empty
Rule 54    arrfunc -> L_BREAK exp COMMA exp R_BREAK empty
Rule 55    arrfunc -> L_BREAK exp R_BREAK empty
Rule 56    param -> exp paramF
Rule 57    paramF -> COMMA param
Rule 58    paramF -> empty
Rule 59    return -> RETURN L_PAR exp R_PAR SEMICOLON empty
Rule 60    var -> VAR varF
Rule 61    var -> ID DOT VAR varF
Rule 62    varF -> arrfunc empty
Rule 63    varF -> empty
Rule 64    read -> READ L_PAR readF
Rule 65    readF -> var np_addRead COMMA readF
Rule 66    readF -> var np_addRead R_PAR SEMICOLON empty
Rule 67    write -> WRITE L_PAR writeT
Rule 68    writeT -> CTE_STRING writeF
Rule 69    writeT -> exp writeF
Rule 70    writeF -> COMMA writeT
Rule 71    writeF -> R_PAR SEMICOLON empty
Rule 72    repeat -> conditional empty
Rule 73    repeat -> nonconditional empty
Rule 74    if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
Rule 75    ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 76    ifF -> empty
Rule 77    assigment -> var np_addId assigmentF
Rule 78    assigmentF -> EQUAL np_addOp exp np_doAssign empty
Rule 79    assigmentF -> ope np_addOp exp np_doAssign empty
Rule 80    ope -> PLUS_EQ empty
Rule 81    ope -> MIN_EQ empty
Rule 82    ope -> MULT_EQ empty
Rule 83    ope -> DIV_EQ empty
Rule 84    conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 85    nonconditional -> FROM VAR arrfunc nonconditionalF
Rule 86    nonconditional -> FROM VAR nonconditionalF
Rule 87    nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 88    bool -> logical np_addBool boolF
Rule 89    boolF -> OR np_addOp bool
Rule 90    boolF -> AND np_addOp bool
Rule 91    boolF -> empty
Rule 92    logical -> ex np_addLogical logicalF
Rule 93    logicalF -> LESS np_addOp logical
Rule 94    logicalF -> GREATER np_addOp logical
Rule 95    logicalF -> LESS_TH np_addOp logical
Rule 96    logicalF -> GREAT_TH np_addOp logical
Rule 97    logicalF -> SAME np_addOp logical
Rule 98    logicalF -> DIF np_addOp logical
Rule 99    logicalF -> empty
Rule 100   exp -> bool empty
Rule 101   ex -> term np_addEx exF
Rule 102   exF -> PLUS np_addOp ex
Rule 103   exF -> MINUS np_addOp ex
Rule 104   exF -> empty
Rule 105   term -> factor np_addTerm termF
Rule 106   termF -> MULT np_addOp term
Rule 107   termF -> DIV np_addOp term
Rule 108   termF -> empty
Rule 109   factor -> L_PAR np_addPar exp R_PAR np_popPar empty
Rule 110   factor -> factorT
Rule 111   factorT -> PLUS factorF
Rule 112   factorT -> MINUS factorF
Rule 113   factorT -> factorF
Rule 114   factorF -> varcte empty
Rule 115   varcte -> var np_addId empty
Rule 116   varcte -> CTE_INT empty
Rule 117   varcte -> CTE_FLOAT empty
Rule 118   varcte -> CTE_CHAR empty
Rule 119   varcte -> CTE_BOOL empty
Rule 120   empty -> <empty>
Rule 121   np_getMainFunc -> <empty>
Rule 122   np_addFunc -> <empty>
Rule 123   np_getDec -> <empty>
Rule 124   np_getDecArr -> <empty>
Rule 125   np_getVarType -> <empty>
Rule 126   np_addToDic -> <empty>
Rule 127   np_addId -> <empty>
Rule 128   np_addOp -> <empty>
Rule 129   np_addPar -> <empty>
Rule 130   np_popPar -> <empty>
Rule 131   np_addTerm -> <empty>
Rule 132   np_addEx -> <empty>
Rule 133   np_addLogical -> <empty>
Rule 134   np_addBool -> <empty>
Rule 135   np_doAssign -> <empty>
Rule 136   np_addRead -> <empty>

Terminals, with rules where they appear

AND                  : 90
ATTRIBUTES           : 10
BOOL                 : 20 30 39
CHAR                 : 19 29 38
CLASS                : 7
COLON                : 15 16 33
COMMA                : 14 22 54 57 65 70
CTE_BOOL             : 119
CTE_CHAR             : 118
CTE_FLOAT            : 117
CTE_INT              : 22 22 23 116
CTE_STRING           : 68
DIF                  : 98
DIV                  : 107
DIV_EQ               : 83
DO                   : 84 87
DOT                  : 51 61
ELSE                 : 75
EQUAL                : 78
FLOAT                : 18 28 37
FROM                 : 85 86
FUNCTION             : 24
GREATER              : 8 94
GREAT_TH             : 96
ID                   : 1 7 8 21 24 31 40 51 51 52 53 61
IF                   : 74
INHERIT              : 8
INT                  : 17 27 36
LESS                 : 8 93
LESS_TH              : 95
L_BREAK              : 22 23 54 55
L_CURPAR             : 10 25 26 41 74 75 84 87
L_PAR                : 24 41 51 52 53 59 64 67 74 84 109
MAIN                 : 41
METHODS              : 10
MINUS                : 103 112
MIN_EQ               : 81
MULT                 : 106
MULT_EQ              : 82
OR                   : 89
PLUS                 : 102 111
PLUS_EQ              : 80
PROGRAM              : 1
READ                 : 64
RETURN               : 59
R_BREAK              : 22 23 54 55
R_CURPAR             : 10 25 26 41 74 75 84 87
R_PAR                : 25 26 41 51 52 53 59 66 71 74 84 109
SAME                 : 97
SEMICOLON            : 1 10 10 15 16 25 26 33 51 52 53 59 66 71 74 75 84 87
THEN                 : 74
TO                   : 87
VAR                  : 12 13 33 60 61 85 86
VARS                 : 11
VOID                 : 32
WHILE                : 84
WRITE                : 67
error                : 

Nonterminals, with rules where they appear

arr                  : 12
arrfunc              : 62 85
assigment            : 42
assigmentF           : 77
bool                 : 89 90 100
boolF                : 88
class                : 2
classF               : 8 9
classT               : 7
conditional          : 72
dec                  : 10 11 14 15 25 26
decF                 : 12 13
empty                : 6 10 11 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 35 36 37 38 39 40 41 50 51 52 53 54 55 58 59 62 63 66 71 72 73 75 76 78 79 80 81 82 83 84 87 91 99 100 104 108 109 114 115 116 117 118 119
ex                   : 92 102 103
exF                  : 101
exp                  : 54 54 55 56 59 69 74 78 79 84 87 87 109
factor               : 105
factorF              : 111 112 113
factorT              : 110
func                 : 5 10
funcF                : 24
if                   : 47
ifF                  : 74
logical              : 88 93 94 95 96 97 98
logicalF             : 92
main                 : 6
nonconditional       : 73
nonconditionalF      : 85 86
np_addBool           : 88
np_addEx             : 101
np_addFunc           : 1 24
np_addId             : 77 115
np_addLogical        : 92
np_addOp             : 78 79 89 90 93 94 95 96 97 98 102 103 106 107
np_addPar            : 109
np_addRead           : 65 66
np_addTerm           : 105
np_addToDic          : 16
np_doAssign          : 78 79
np_getDec            : 13 15 16
np_getDecArr         : 12
np_getMainFunc       : 41
np_getVarType        : 15 16
np_popPar            : 109
ope                  : 79
param                : 51 52 57
paramF               : 56
parameter            : 25 34
parameterF           : 33
program              : 0
programF             : 3 4 5
programT             : 1 2
read                 : 45
readF                : 64 65
repeat               : 48
return               : 44
statement            : 25 26 41 49 74 75 84 87
statementF           : 42 43 44 45 46 47 48
term                 : 101 106 107
termF                : 105
type                 : 15 16
typeFunc             : 24
typepar              : 33
var                  : 65 66 77 115
varF                 : 60 61
varcte               : 114
vars                 : 3
void                 : 43
write                : 46
writeF               : 68 69
writeT               : 67 70

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID np_addFunc SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID np_addFunc SEMICOLON programT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . np_addFunc SEMICOLON programT
    (122) np_addFunc -> .

    SEMICOLON       reduce using rule 122 (np_addFunc -> .)

    np_addFunc                     shift and go to state 4

state 4

    (1) program -> PROGRAM ID np_addFunc . SEMICOLON programT

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID np_addFunc SEMICOLON . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 11
    VARS            shift and go to state 12
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    programT                       shift and go to state 7
    class                          shift and go to state 8
    vars                           shift and go to state 9
    programF                       shift and go to state 10
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 6

    (31) typeFunc -> ID . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 22

state 7

    (1) program -> PROGRAM ID np_addFunc SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM ID np_addFunc SEMICOLON programT .)


state 8

    (2) programT -> class . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 11
    VARS            shift and go to state 12
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    class                          shift and go to state 8
    programT                       shift and go to state 23
    vars                           shift and go to state 9
    programF                       shift and go to state 10
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 9

    (3) programT -> vars . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    programF                       shift and go to state 24
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 10

    (4) programT -> programF .

    $end            reduce using rule 4 (programT -> programF .)


state 11

    (7) class -> CLASS . ID classT

    ID              shift and go to state 25


state 12

    (11) vars -> VARS . dec empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 26

state 13

    (5) programF -> func . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    func                           shift and go to state 13
    programF                       shift and go to state 28
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 14

    (6) programF -> main . empty
    (120) empty -> .

    $end            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 29

state 15

    (24) func -> typeFunc . FUNCTION ID np_addFunc L_PAR funcF

    FUNCTION        shift and go to state 30


state 16

    (41) main -> MAIN . np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (121) np_getMainFunc -> .

    L_PAR           reduce using rule 121 (np_getMainFunc -> .)

    np_getMainFunc                 shift and go to state 31

state 17

    (27) typeFunc -> INT . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 32

state 18

    (28) typeFunc -> FLOAT . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 33

state 19

    (29) typeFunc -> CHAR . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 34

state 20

    (30) typeFunc -> BOOL . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 35

state 21

    (32) typeFunc -> VOID . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 36

state 22

    (31) typeFunc -> ID empty .

    FUNCTION        reduce using rule 31 (typeFunc -> ID empty .)


state 23

    (2) programT -> class programT .

    $end            reduce using rule 2 (programT -> class programT .)


state 24

    (3) programT -> vars programF .

    $end            reduce using rule 3 (programT -> vars programF .)


state 25

    (7) class -> CLASS ID . classT
    (8) classT -> . LESS INHERIT ID GREATER classF
    (9) classT -> . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    LESS            shift and go to state 38
    SEMICOLON       shift and go to state 40

    classT                         shift and go to state 37
    classF                         shift and go to state 39

state 26

    (11) vars -> VARS dec . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 41

state 27

    (12) dec -> VAR . arr np_getDecArr decF
    (13) dec -> VAR . np_getDec decF
    (22) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> . L_BREAK CTE_INT R_BREAK empty
    (123) np_getDec -> .

    L_BREAK         shift and go to state 44
    COMMA           reduce using rule 123 (np_getDec -> .)
    COLON           reduce using rule 123 (np_getDec -> .)

    arr                            shift and go to state 42
    np_getDec                      shift and go to state 43

state 28

    (5) programF -> func programF .

    $end            reduce using rule 5 (programF -> func programF .)


state 29

    (6) programF -> main empty .

    $end            reduce using rule 6 (programF -> main empty .)


state 30

    (24) func -> typeFunc FUNCTION . ID np_addFunc L_PAR funcF

    ID              shift and go to state 45


state 31

    (41) main -> MAIN np_getMainFunc . L_PAR R_PAR L_CURPAR statement R_CURPAR empty

    L_PAR           shift and go to state 46


state 32

    (27) typeFunc -> INT empty .

    FUNCTION        reduce using rule 27 (typeFunc -> INT empty .)


state 33

    (28) typeFunc -> FLOAT empty .

    FUNCTION        reduce using rule 28 (typeFunc -> FLOAT empty .)


state 34

    (29) typeFunc -> CHAR empty .

    FUNCTION        reduce using rule 29 (typeFunc -> CHAR empty .)


state 35

    (30) typeFunc -> BOOL empty .

    FUNCTION        reduce using rule 30 (typeFunc -> BOOL empty .)


state 36

    (32) typeFunc -> VOID empty .

    FUNCTION        reduce using rule 32 (typeFunc -> VOID empty .)


state 37

    (7) class -> CLASS ID classT .

    CLASS           reduce using rule 7 (class -> CLASS ID classT .)
    VARS            reduce using rule 7 (class -> CLASS ID classT .)
    MAIN            reduce using rule 7 (class -> CLASS ID classT .)
    INT             reduce using rule 7 (class -> CLASS ID classT .)
    FLOAT           reduce using rule 7 (class -> CLASS ID classT .)
    CHAR            reduce using rule 7 (class -> CLASS ID classT .)
    BOOL            reduce using rule 7 (class -> CLASS ID classT .)
    ID              reduce using rule 7 (class -> CLASS ID classT .)
    VOID            reduce using rule 7 (class -> CLASS ID classT .)


state 38

    (8) classT -> LESS . INHERIT ID GREATER classF

    INHERIT         shift and go to state 47


state 39

    (9) classT -> classF .

    CLASS           reduce using rule 9 (classT -> classF .)
    VARS            reduce using rule 9 (classT -> classF .)
    MAIN            reduce using rule 9 (classT -> classF .)
    INT             reduce using rule 9 (classT -> classF .)
    FLOAT           reduce using rule 9 (classT -> classF .)
    CHAR            reduce using rule 9 (classT -> classF .)
    BOOL            reduce using rule 9 (classT -> classF .)
    ID              reduce using rule 9 (classT -> classF .)
    VOID            reduce using rule 9 (classT -> classF .)


state 40

    (10) classF -> SEMICOLON . L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    L_CURPAR        shift and go to state 48


state 41

    (11) vars -> VARS dec empty .

    MAIN            reduce using rule 11 (vars -> VARS dec empty .)
    INT             reduce using rule 11 (vars -> VARS dec empty .)
    FLOAT           reduce using rule 11 (vars -> VARS dec empty .)
    CHAR            reduce using rule 11 (vars -> VARS dec empty .)
    BOOL            reduce using rule 11 (vars -> VARS dec empty .)
    ID              reduce using rule 11 (vars -> VARS dec empty .)
    VOID            reduce using rule 11 (vars -> VARS dec empty .)


state 42

    (12) dec -> VAR arr . np_getDecArr decF
    (124) np_getDecArr -> .

    COMMA           reduce using rule 124 (np_getDecArr -> .)
    COLON           reduce using rule 124 (np_getDecArr -> .)

    np_getDecArr                   shift and go to state 49

state 43

    (13) dec -> VAR np_getDec . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 51
    COLON           shift and go to state 52

    decF                           shift and go to state 50

state 44

    (22) arr -> L_BREAK . CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 53


state 45

    (24) func -> typeFunc FUNCTION ID . np_addFunc L_PAR funcF
    (122) np_addFunc -> .

    L_PAR           reduce using rule 122 (np_addFunc -> .)

    np_addFunc                     shift and go to state 54

state 46

    (41) main -> MAIN np_getMainFunc L_PAR . R_PAR L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 55


state 47

    (8) classT -> LESS INHERIT . ID GREATER classF

    ID              shift and go to state 56


state 48

    (10) classF -> SEMICOLON L_CURPAR . ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    ATTRIBUTES      shift and go to state 57


state 49

    (12) dec -> VAR arr np_getDecArr . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 51
    COLON           shift and go to state 52

    decF                           shift and go to state 58

state 50

    (13) dec -> VAR np_getDec decF .

    MAIN            reduce using rule 13 (dec -> VAR np_getDec decF .)
    INT             reduce using rule 13 (dec -> VAR np_getDec decF .)
    FLOAT           reduce using rule 13 (dec -> VAR np_getDec decF .)
    CHAR            reduce using rule 13 (dec -> VAR np_getDec decF .)
    BOOL            reduce using rule 13 (dec -> VAR np_getDec decF .)
    ID              reduce using rule 13 (dec -> VAR np_getDec decF .)
    VOID            reduce using rule 13 (dec -> VAR np_getDec decF .)
    METHODS         reduce using rule 13 (dec -> VAR np_getDec decF .)
    L_CURPAR        reduce using rule 13 (dec -> VAR np_getDec decF .)


state 51

    (14) decF -> COMMA . dec
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 59

state 52

    (15) decF -> COLON . type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON . type np_getVarType SEMICOLON np_getDec np_addToDic empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . BOOL empty
    (21) type -> . ID empty

    INT             shift and go to state 61
    FLOAT           shift and go to state 62
    CHAR            shift and go to state 63
    BOOL            shift and go to state 64
    ID              shift and go to state 65

    type                           shift and go to state 60

state 53

    (22) arr -> L_BREAK CTE_INT . COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK CTE_INT . R_BREAK empty

    COMMA           shift and go to state 66
    R_BREAK         shift and go to state 67


state 54

    (24) func -> typeFunc FUNCTION ID np_addFunc . L_PAR funcF

    L_PAR           shift and go to state 68


state 55

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 69


state 56

    (8) classT -> LESS INHERIT ID . GREATER classF

    GREATER         shift and go to state 70


state 57

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES . dec METHODS func R_CURPAR SEMICOLON empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 71

state 58

    (12) dec -> VAR arr np_getDecArr decF .

    MAIN            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    INT             reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    FLOAT           reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    CHAR            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    BOOL            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    ID              reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    VOID            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    METHODS         reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    L_CURPAR        reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)


state 59

    (14) decF -> COMMA dec .

    MAIN            reduce using rule 14 (decF -> COMMA dec .)
    INT             reduce using rule 14 (decF -> COMMA dec .)
    FLOAT           reduce using rule 14 (decF -> COMMA dec .)
    CHAR            reduce using rule 14 (decF -> COMMA dec .)
    BOOL            reduce using rule 14 (decF -> COMMA dec .)
    ID              reduce using rule 14 (decF -> COMMA dec .)
    VOID            reduce using rule 14 (decF -> COMMA dec .)
    METHODS         reduce using rule 14 (decF -> COMMA dec .)
    L_CURPAR        reduce using rule 14 (decF -> COMMA dec .)


state 60

    (15) decF -> COLON type . np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON type . np_getVarType SEMICOLON np_getDec np_addToDic empty
    (125) np_getVarType -> .

    SEMICOLON       reduce using rule 125 (np_getVarType -> .)

    np_getVarType                  shift and go to state 72

state 61

    (17) type -> INT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 73

state 62

    (18) type -> FLOAT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 74

state 63

    (19) type -> CHAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 75

state 64

    (20) type -> BOOL . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 76

state 65

    (21) type -> ID . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 77

state 66

    (22) arr -> L_BREAK CTE_INT COMMA . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 78


state 67

    (23) arr -> L_BREAK CTE_INT R_BREAK . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    COLON           reduce using rule 120 (empty -> .)

    empty                          shift and go to state 79

state 68

    (24) func -> typeFunc FUNCTION ID np_addFunc L_PAR . funcF
    (25) funcF -> . parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (26) funcF -> . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (33) parameter -> . VAR COLON typepar SEMICOLON parameterF

    R_PAR           shift and go to state 82
    VAR             shift and go to state 83

    funcF                          shift and go to state 80
    parameter                      shift and go to state 81

state 69

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 84
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 70

    (8) classT -> LESS INHERIT ID GREATER . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    SEMICOLON       shift and go to state 40

    classF                         shift and go to state 103

state 71

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec . METHODS func R_CURPAR SEMICOLON empty

    METHODS         shift and go to state 104


state 72

    (15) decF -> COLON type np_getVarType . SEMICOLON np_getDec dec
    (16) decF -> COLON type np_getVarType . SEMICOLON np_getDec np_addToDic empty

    SEMICOLON       shift and go to state 105


state 73

    (17) type -> INT empty .

    SEMICOLON       reduce using rule 17 (type -> INT empty .)


state 74

    (18) type -> FLOAT empty .

    SEMICOLON       reduce using rule 18 (type -> FLOAT empty .)


state 75

    (19) type -> CHAR empty .

    SEMICOLON       reduce using rule 19 (type -> CHAR empty .)


state 76

    (20) type -> BOOL empty .

    SEMICOLON       reduce using rule 20 (type -> BOOL empty .)


state 77

    (21) type -> ID empty .

    SEMICOLON       reduce using rule 21 (type -> ID empty .)


state 78

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT . R_BREAK empty

    R_BREAK         shift and go to state 106


state 79

    (23) arr -> L_BREAK CTE_INT R_BREAK empty .

    COMMA           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    COLON           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)


state 80

    (24) func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .

    MAIN            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    INT             reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    FLOAT           reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    CHAR            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    BOOL            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    ID              reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    VOID            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    R_CURPAR        reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)


state 81

    (25) funcF -> parameter . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 107


state 82

    (26) funcF -> R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 108


state 83

    (33) parameter -> VAR . COLON typepar SEMICOLON parameterF

    COLON           shift and go to state 109


state 84

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 110


state 85

    (42) statement -> assigment . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    assigment                      shift and go to state 85
    statementF                     shift and go to state 111
    statement                      shift and go to state 112
    empty                          shift and go to state 113
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 86

    (43) statement -> void . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    void                           shift and go to state 86
    statementF                     shift and go to state 114
    statement                      shift and go to state 112
    empty                          shift and go to state 113
    assigment                      shift and go to state 85
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 87

    (44) statement -> return . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    return                         shift and go to state 87
    statementF                     shift and go to state 115
    statement                      shift and go to state 112
    empty                          shift and go to state 113
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 88

    (45) statement -> read . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    read                           shift and go to state 88
    statementF                     shift and go to state 116
    statement                      shift and go to state 112
    empty                          shift and go to state 113
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 89

    (46) statement -> write . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    write                          shift and go to state 89
    statementF                     shift and go to state 117
    statement                      shift and go to state 112
    empty                          shift and go to state 113
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 90

    (47) statement -> if . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    if                             shift and go to state 90
    statementF                     shift and go to state 118
    statement                      shift and go to state 112
    empty                          shift and go to state 113
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 91

    (48) statement -> repeat . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    repeat                         shift and go to state 91
    statementF                     shift and go to state 119
    statement                      shift and go to state 112
    empty                          shift and go to state 113
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 92

    (77) assigment -> var . np_addId assigmentF
    (127) np_addId -> .

    EQUAL           reduce using rule 127 (np_addId -> .)
    PLUS_EQ         reduce using rule 127 (np_addId -> .)
    MIN_EQ          reduce using rule 127 (np_addId -> .)
    MULT_EQ         reduce using rule 127 (np_addId -> .)
    DIV_EQ          reduce using rule 127 (np_addId -> .)

    np_addId                       shift and go to state 120

state 93

    (51) void -> ID . DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> ID . L_PAR param R_PAR SEMICOLON empty
    (53) void -> ID . L_PAR R_PAR SEMICOLON empty
    (61) var -> ID . DOT VAR varF

    DOT             shift and go to state 121
    L_PAR           shift and go to state 122


state 94

    (59) return -> RETURN . L_PAR exp R_PAR SEMICOLON empty

    L_PAR           shift and go to state 123


state 95

    (64) read -> READ . L_PAR readF

    L_PAR           shift and go to state 124


state 96

    (67) write -> WRITE . L_PAR writeT

    L_PAR           shift and go to state 125


state 97

    (74) if -> IF . L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_PAR           shift and go to state 126


state 98

    (72) repeat -> conditional . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 127

state 99

    (73) repeat -> nonconditional . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 128

state 100

    (60) var -> VAR . varF
    (62) varF -> . arrfunc empty
    (63) varF -> . empty
    (54) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (55) arrfunc -> . L_BREAK exp R_BREAK empty
    (120) empty -> .

    L_BREAK         shift and go to state 132
    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    varF                           shift and go to state 129
    arrfunc                        shift and go to state 130
    empty                          shift and go to state 131

state 101

    (84) conditional -> WHILE . L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    L_PAR           shift and go to state 133


state 102

    (85) nonconditional -> FROM . VAR arrfunc nonconditionalF
    (86) nonconditional -> FROM . VAR nonconditionalF

    VAR             shift and go to state 134


state 103

    (8) classT -> LESS INHERIT ID GREATER classF .

    CLASS           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VARS            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    MAIN            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    INT             reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    FLOAT           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    CHAR            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    BOOL            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    ID              reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VOID            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)


state 104

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS . func R_CURPAR SEMICOLON empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    func                           shift and go to state 135
    typeFunc                       shift and go to state 15

state 105

    (15) decF -> COLON type np_getVarType SEMICOLON . np_getDec dec
    (16) decF -> COLON type np_getVarType SEMICOLON . np_getDec np_addToDic empty
    (123) np_getDec -> .

    VAR             reduce using rule 123 (np_getDec -> .)
    MAIN            reduce using rule 123 (np_getDec -> .)
    INT             reduce using rule 123 (np_getDec -> .)
    FLOAT           reduce using rule 123 (np_getDec -> .)
    CHAR            reduce using rule 123 (np_getDec -> .)
    BOOL            reduce using rule 123 (np_getDec -> .)
    ID              reduce using rule 123 (np_getDec -> .)
    VOID            reduce using rule 123 (np_getDec -> .)
    METHODS         reduce using rule 123 (np_getDec -> .)
    L_CURPAR        reduce using rule 123 (np_getDec -> .)

    np_getDec                      shift and go to state 136

state 106

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    COLON           reduce using rule 120 (empty -> .)

    empty                          shift and go to state 137

state 107

    (25) funcF -> parameter R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 138


state 108

    (26) funcF -> R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 139

state 109

    (33) parameter -> VAR COLON . typepar SEMICOLON parameterF
    (36) typepar -> . INT empty
    (37) typepar -> . FLOAT empty
    (38) typepar -> . CHAR empty
    (39) typepar -> . BOOL empty
    (40) typepar -> . ID empty

    INT             shift and go to state 141
    FLOAT           shift and go to state 142
    CHAR            shift and go to state 143
    BOOL            shift and go to state 144
    ID              shift and go to state 145

    typepar                        shift and go to state 140

state 110

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    $end            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 146

state 111

    (42) statement -> assigment statementF .

    R_CURPAR        reduce using rule 42 (statement -> assigment statementF .)
    SEMICOLON       reduce using rule 42 (statement -> assigment statementF .)


state 112

    (49) statementF -> statement .

    R_CURPAR        reduce using rule 49 (statementF -> statement .)
    SEMICOLON       reduce using rule 49 (statementF -> statement .)


state 113

    (50) statementF -> empty .

    R_CURPAR        reduce using rule 50 (statementF -> empty .)
    SEMICOLON       reduce using rule 50 (statementF -> empty .)


state 114

    (43) statement -> void statementF .

    R_CURPAR        reduce using rule 43 (statement -> void statementF .)
    SEMICOLON       reduce using rule 43 (statement -> void statementF .)


state 115

    (44) statement -> return statementF .

    R_CURPAR        reduce using rule 44 (statement -> return statementF .)
    SEMICOLON       reduce using rule 44 (statement -> return statementF .)


state 116

    (45) statement -> read statementF .

    R_CURPAR        reduce using rule 45 (statement -> read statementF .)
    SEMICOLON       reduce using rule 45 (statement -> read statementF .)


state 117

    (46) statement -> write statementF .

    R_CURPAR        reduce using rule 46 (statement -> write statementF .)
    SEMICOLON       reduce using rule 46 (statement -> write statementF .)


state 118

    (47) statement -> if statementF .

    R_CURPAR        reduce using rule 47 (statement -> if statementF .)
    SEMICOLON       reduce using rule 47 (statement -> if statementF .)


state 119

    (48) statement -> repeat statementF .

    R_CURPAR        reduce using rule 48 (statement -> repeat statementF .)
    SEMICOLON       reduce using rule 48 (statement -> repeat statementF .)


state 120

    (77) assigment -> var np_addId . assigmentF
    (78) assigmentF -> . EQUAL np_addOp exp np_doAssign empty
    (79) assigmentF -> . ope np_addOp exp np_doAssign empty
    (80) ope -> . PLUS_EQ empty
    (81) ope -> . MIN_EQ empty
    (82) ope -> . MULT_EQ empty
    (83) ope -> . DIV_EQ empty

    EQUAL           shift and go to state 148
    PLUS_EQ         shift and go to state 150
    MIN_EQ          shift and go to state 151
    MULT_EQ         shift and go to state 152
    DIV_EQ          shift and go to state 153

    assigmentF                     shift and go to state 147
    ope                            shift and go to state 149

state 121

    (51) void -> ID DOT . ID L_PAR param R_PAR SEMICOLON empty
    (61) var -> ID DOT . VAR varF

    ID              shift and go to state 154
    VAR             shift and go to state 155


state 122

    (52) void -> ID L_PAR . param R_PAR SEMICOLON empty
    (53) void -> ID L_PAR . R_PAR SEMICOLON empty
    (56) param -> . exp paramF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 159
    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    param                          shift and go to state 158
    exp                            shift and go to state 160
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 123

    (59) return -> RETURN L_PAR . exp R_PAR SEMICOLON empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    exp                            shift and go to state 176
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 124

    (64) read -> READ L_PAR . readF
    (65) readF -> . var np_addRead COMMA readF
    (66) readF -> . var np_addRead R_PAR SEMICOLON empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 100
    ID              shift and go to state 156

    readF                          shift and go to state 177
    var                            shift and go to state 178

state 125

    (67) write -> WRITE L_PAR . writeT
    (68) writeT -> . CTE_STRING writeF
    (69) writeT -> . exp writeF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 180
    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    writeT                         shift and go to state 179
    exp                            shift and go to state 181
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 126

    (74) if -> IF L_PAR . exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    exp                            shift and go to state 182
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 127

    (72) repeat -> conditional empty .

    ID              reduce using rule 72 (repeat -> conditional empty .)
    RETURN          reduce using rule 72 (repeat -> conditional empty .)
    READ            reduce using rule 72 (repeat -> conditional empty .)
    WRITE           reduce using rule 72 (repeat -> conditional empty .)
    IF              reduce using rule 72 (repeat -> conditional empty .)
    VAR             reduce using rule 72 (repeat -> conditional empty .)
    WHILE           reduce using rule 72 (repeat -> conditional empty .)
    FROM            reduce using rule 72 (repeat -> conditional empty .)
    R_CURPAR        reduce using rule 72 (repeat -> conditional empty .)
    SEMICOLON       reduce using rule 72 (repeat -> conditional empty .)


state 128

    (73) repeat -> nonconditional empty .

    ID              reduce using rule 73 (repeat -> nonconditional empty .)
    RETURN          reduce using rule 73 (repeat -> nonconditional empty .)
    READ            reduce using rule 73 (repeat -> nonconditional empty .)
    WRITE           reduce using rule 73 (repeat -> nonconditional empty .)
    IF              reduce using rule 73 (repeat -> nonconditional empty .)
    VAR             reduce using rule 73 (repeat -> nonconditional empty .)
    WHILE           reduce using rule 73 (repeat -> nonconditional empty .)
    FROM            reduce using rule 73 (repeat -> nonconditional empty .)
    R_CURPAR        reduce using rule 73 (repeat -> nonconditional empty .)
    SEMICOLON       reduce using rule 73 (repeat -> nonconditional empty .)


state 129

    (60) var -> VAR varF .

    EQUAL           reduce using rule 60 (var -> VAR varF .)
    PLUS_EQ         reduce using rule 60 (var -> VAR varF .)
    MIN_EQ          reduce using rule 60 (var -> VAR varF .)
    MULT_EQ         reduce using rule 60 (var -> VAR varF .)
    DIV_EQ          reduce using rule 60 (var -> VAR varF .)
    MULT            reduce using rule 60 (var -> VAR varF .)
    DIV             reduce using rule 60 (var -> VAR varF .)
    PLUS            reduce using rule 60 (var -> VAR varF .)
    MINUS           reduce using rule 60 (var -> VAR varF .)
    LESS            reduce using rule 60 (var -> VAR varF .)
    GREATER         reduce using rule 60 (var -> VAR varF .)
    LESS_TH         reduce using rule 60 (var -> VAR varF .)
    GREAT_TH        reduce using rule 60 (var -> VAR varF .)
    SAME            reduce using rule 60 (var -> VAR varF .)
    DIF             reduce using rule 60 (var -> VAR varF .)
    OR              reduce using rule 60 (var -> VAR varF .)
    AND             reduce using rule 60 (var -> VAR varF .)
    COMMA           reduce using rule 60 (var -> VAR varF .)
    R_PAR           reduce using rule 60 (var -> VAR varF .)
    R_BREAK         reduce using rule 60 (var -> VAR varF .)
    TO              reduce using rule 60 (var -> VAR varF .)
    ID              reduce using rule 60 (var -> VAR varF .)
    RETURN          reduce using rule 60 (var -> VAR varF .)
    READ            reduce using rule 60 (var -> VAR varF .)
    WRITE           reduce using rule 60 (var -> VAR varF .)
    IF              reduce using rule 60 (var -> VAR varF .)
    VAR             reduce using rule 60 (var -> VAR varF .)
    WHILE           reduce using rule 60 (var -> VAR varF .)
    FROM            reduce using rule 60 (var -> VAR varF .)
    R_CURPAR        reduce using rule 60 (var -> VAR varF .)
    SEMICOLON       reduce using rule 60 (var -> VAR varF .)
    DO              reduce using rule 60 (var -> VAR varF .)


state 130

    (62) varF -> arrfunc . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 183

state 131

    (63) varF -> empty .

    EQUAL           reduce using rule 63 (varF -> empty .)
    PLUS_EQ         reduce using rule 63 (varF -> empty .)
    MIN_EQ          reduce using rule 63 (varF -> empty .)
    MULT_EQ         reduce using rule 63 (varF -> empty .)
    DIV_EQ          reduce using rule 63 (varF -> empty .)
    MULT            reduce using rule 63 (varF -> empty .)
    DIV             reduce using rule 63 (varF -> empty .)
    PLUS            reduce using rule 63 (varF -> empty .)
    MINUS           reduce using rule 63 (varF -> empty .)
    LESS            reduce using rule 63 (varF -> empty .)
    GREATER         reduce using rule 63 (varF -> empty .)
    LESS_TH         reduce using rule 63 (varF -> empty .)
    GREAT_TH        reduce using rule 63 (varF -> empty .)
    SAME            reduce using rule 63 (varF -> empty .)
    DIF             reduce using rule 63 (varF -> empty .)
    OR              reduce using rule 63 (varF -> empty .)
    AND             reduce using rule 63 (varF -> empty .)
    COMMA           reduce using rule 63 (varF -> empty .)
    R_PAR           reduce using rule 63 (varF -> empty .)
    R_BREAK         reduce using rule 63 (varF -> empty .)
    TO              reduce using rule 63 (varF -> empty .)
    ID              reduce using rule 63 (varF -> empty .)
    RETURN          reduce using rule 63 (varF -> empty .)
    READ            reduce using rule 63 (varF -> empty .)
    WRITE           reduce using rule 63 (varF -> empty .)
    IF              reduce using rule 63 (varF -> empty .)
    VAR             reduce using rule 63 (varF -> empty .)
    WHILE           reduce using rule 63 (varF -> empty .)
    FROM            reduce using rule 63 (varF -> empty .)
    R_CURPAR        reduce using rule 63 (varF -> empty .)
    SEMICOLON       reduce using rule 63 (varF -> empty .)
    DO              reduce using rule 63 (varF -> empty .)


state 132

    (54) arrfunc -> L_BREAK . exp COMMA exp R_BREAK empty
    (55) arrfunc -> L_BREAK . exp R_BREAK empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    exp                            shift and go to state 184
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 133

    (84) conditional -> WHILE L_PAR . exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    exp                            shift and go to state 185
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 134

    (85) nonconditional -> FROM VAR . arrfunc nonconditionalF
    (86) nonconditional -> FROM VAR . nonconditionalF
    (54) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (55) arrfunc -> . L_BREAK exp R_BREAK empty
    (87) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_BREAK         shift and go to state 132
    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    arrfunc                        shift and go to state 186
    nonconditionalF                shift and go to state 187
    exp                            shift and go to state 188
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 135

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func . R_CURPAR SEMICOLON empty

    R_CURPAR        shift and go to state 189


state 136

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec . dec
    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec . np_addToDic empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF
    (126) np_addToDic -> .

    VAR             shift and go to state 27
    MAIN            reduce using rule 126 (np_addToDic -> .)
    INT             reduce using rule 126 (np_addToDic -> .)
    FLOAT           reduce using rule 126 (np_addToDic -> .)
    CHAR            reduce using rule 126 (np_addToDic -> .)
    BOOL            reduce using rule 126 (np_addToDic -> .)
    ID              reduce using rule 126 (np_addToDic -> .)
    VOID            reduce using rule 126 (np_addToDic -> .)
    METHODS         reduce using rule 126 (np_addToDic -> .)
    L_CURPAR        reduce using rule 126 (np_addToDic -> .)

    dec                            shift and go to state 190
    np_addToDic                    shift and go to state 191

state 137

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .

    COMMA           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    COLON           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)


state 138

    (25) funcF -> parameter R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 192

state 139

    (26) funcF -> R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 193


state 140

    (33) parameter -> VAR COLON typepar . SEMICOLON parameterF

    SEMICOLON       shift and go to state 194


state 141

    (36) typepar -> INT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 195

state 142

    (37) typepar -> FLOAT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 196

state 143

    (38) typepar -> CHAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 197

state 144

    (39) typepar -> BOOL . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 198

state 145

    (40) typepar -> ID . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 199

state 146

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty .

    $end            reduce using rule 41 (main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty .)


state 147

    (77) assigment -> var np_addId assigmentF .

    ID              reduce using rule 77 (assigment -> var np_addId assigmentF .)
    RETURN          reduce using rule 77 (assigment -> var np_addId assigmentF .)
    READ            reduce using rule 77 (assigment -> var np_addId assigmentF .)
    WRITE           reduce using rule 77 (assigment -> var np_addId assigmentF .)
    IF              reduce using rule 77 (assigment -> var np_addId assigmentF .)
    VAR             reduce using rule 77 (assigment -> var np_addId assigmentF .)
    WHILE           reduce using rule 77 (assigment -> var np_addId assigmentF .)
    FROM            reduce using rule 77 (assigment -> var np_addId assigmentF .)
    R_CURPAR        reduce using rule 77 (assigment -> var np_addId assigmentF .)
    SEMICOLON       reduce using rule 77 (assigment -> var np_addId assigmentF .)


state 148

    (78) assigmentF -> EQUAL . np_addOp exp np_doAssign empty
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 200

state 149

    (79) assigmentF -> ope . np_addOp exp np_doAssign empty
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 201

state 150

    (80) ope -> PLUS_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 202

state 151

    (81) ope -> MIN_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 203

state 152

    (82) ope -> MULT_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 204

state 153

    (83) ope -> DIV_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 205

state 154

    (51) void -> ID DOT ID . L_PAR param R_PAR SEMICOLON empty

    L_PAR           shift and go to state 206


state 155

    (61) var -> ID DOT VAR . varF
    (62) varF -> . arrfunc empty
    (63) varF -> . empty
    (54) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (55) arrfunc -> . L_BREAK exp R_BREAK empty
    (120) empty -> .

    L_BREAK         shift and go to state 132
    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    varF                           shift and go to state 207
    arrfunc                        shift and go to state 130
    empty                          shift and go to state 131

state 156

    (61) var -> ID . DOT VAR varF

    DOT             shift and go to state 208


state 157

    (109) factor -> L_PAR . np_addPar exp R_PAR np_popPar empty
    (129) np_addPar -> .

    L_PAR           reduce using rule 129 (np_addPar -> .)
    PLUS            reduce using rule 129 (np_addPar -> .)
    MINUS           reduce using rule 129 (np_addPar -> .)
    CTE_INT         reduce using rule 129 (np_addPar -> .)
    CTE_FLOAT       reduce using rule 129 (np_addPar -> .)
    CTE_CHAR        reduce using rule 129 (np_addPar -> .)
    CTE_BOOL        reduce using rule 129 (np_addPar -> .)
    VAR             reduce using rule 129 (np_addPar -> .)
    ID              reduce using rule 129 (np_addPar -> .)

    np_addPar                      shift and go to state 209

state 158

    (52) void -> ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 210


state 159

    (53) void -> ID L_PAR R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 211


state 160

    (56) param -> exp . paramF
    (57) paramF -> . COMMA param
    (58) paramF -> . empty
    (120) empty -> .

    COMMA           shift and go to state 213
    R_PAR           reduce using rule 120 (empty -> .)

    paramF                         shift and go to state 212
    empty                          shift and go to state 214

state 161

    (100) exp -> bool . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 215

state 162

    (88) bool -> logical . np_addBool boolF
    (134) np_addBool -> .

    OR              reduce using rule 134 (np_addBool -> .)
    AND             reduce using rule 134 (np_addBool -> .)
    COMMA           reduce using rule 134 (np_addBool -> .)
    R_PAR           reduce using rule 134 (np_addBool -> .)
    R_BREAK         reduce using rule 134 (np_addBool -> .)
    TO              reduce using rule 134 (np_addBool -> .)
    ID              reduce using rule 134 (np_addBool -> .)
    RETURN          reduce using rule 134 (np_addBool -> .)
    READ            reduce using rule 134 (np_addBool -> .)
    WRITE           reduce using rule 134 (np_addBool -> .)
    IF              reduce using rule 134 (np_addBool -> .)
    VAR             reduce using rule 134 (np_addBool -> .)
    WHILE           reduce using rule 134 (np_addBool -> .)
    FROM            reduce using rule 134 (np_addBool -> .)
    R_CURPAR        reduce using rule 134 (np_addBool -> .)
    SEMICOLON       reduce using rule 134 (np_addBool -> .)
    DO              reduce using rule 134 (np_addBool -> .)

    np_addBool                     shift and go to state 216

state 163

    (92) logical -> ex . np_addLogical logicalF
    (133) np_addLogical -> .

    LESS            reduce using rule 133 (np_addLogical -> .)
    GREATER         reduce using rule 133 (np_addLogical -> .)
    LESS_TH         reduce using rule 133 (np_addLogical -> .)
    GREAT_TH        reduce using rule 133 (np_addLogical -> .)
    SAME            reduce using rule 133 (np_addLogical -> .)
    DIF             reduce using rule 133 (np_addLogical -> .)
    OR              reduce using rule 133 (np_addLogical -> .)
    AND             reduce using rule 133 (np_addLogical -> .)
    COMMA           reduce using rule 133 (np_addLogical -> .)
    R_PAR           reduce using rule 133 (np_addLogical -> .)
    R_BREAK         reduce using rule 133 (np_addLogical -> .)
    TO              reduce using rule 133 (np_addLogical -> .)
    ID              reduce using rule 133 (np_addLogical -> .)
    RETURN          reduce using rule 133 (np_addLogical -> .)
    READ            reduce using rule 133 (np_addLogical -> .)
    WRITE           reduce using rule 133 (np_addLogical -> .)
    IF              reduce using rule 133 (np_addLogical -> .)
    VAR             reduce using rule 133 (np_addLogical -> .)
    WHILE           reduce using rule 133 (np_addLogical -> .)
    FROM            reduce using rule 133 (np_addLogical -> .)
    R_CURPAR        reduce using rule 133 (np_addLogical -> .)
    SEMICOLON       reduce using rule 133 (np_addLogical -> .)
    DO              reduce using rule 133 (np_addLogical -> .)

    np_addLogical                  shift and go to state 217

state 164

    (101) ex -> term . np_addEx exF
    (132) np_addEx -> .

    PLUS            reduce using rule 132 (np_addEx -> .)
    MINUS           reduce using rule 132 (np_addEx -> .)
    LESS            reduce using rule 132 (np_addEx -> .)
    GREATER         reduce using rule 132 (np_addEx -> .)
    LESS_TH         reduce using rule 132 (np_addEx -> .)
    GREAT_TH        reduce using rule 132 (np_addEx -> .)
    SAME            reduce using rule 132 (np_addEx -> .)
    DIF             reduce using rule 132 (np_addEx -> .)
    OR              reduce using rule 132 (np_addEx -> .)
    AND             reduce using rule 132 (np_addEx -> .)
    COMMA           reduce using rule 132 (np_addEx -> .)
    R_PAR           reduce using rule 132 (np_addEx -> .)
    R_BREAK         reduce using rule 132 (np_addEx -> .)
    TO              reduce using rule 132 (np_addEx -> .)
    ID              reduce using rule 132 (np_addEx -> .)
    RETURN          reduce using rule 132 (np_addEx -> .)
    READ            reduce using rule 132 (np_addEx -> .)
    WRITE           reduce using rule 132 (np_addEx -> .)
    IF              reduce using rule 132 (np_addEx -> .)
    VAR             reduce using rule 132 (np_addEx -> .)
    WHILE           reduce using rule 132 (np_addEx -> .)
    FROM            reduce using rule 132 (np_addEx -> .)
    R_CURPAR        reduce using rule 132 (np_addEx -> .)
    SEMICOLON       reduce using rule 132 (np_addEx -> .)
    DO              reduce using rule 132 (np_addEx -> .)

    np_addEx                       shift and go to state 218

state 165

    (105) term -> factor . np_addTerm termF
    (131) np_addTerm -> .

    MULT            reduce using rule 131 (np_addTerm -> .)
    DIV             reduce using rule 131 (np_addTerm -> .)
    PLUS            reduce using rule 131 (np_addTerm -> .)
    MINUS           reduce using rule 131 (np_addTerm -> .)
    LESS            reduce using rule 131 (np_addTerm -> .)
    GREATER         reduce using rule 131 (np_addTerm -> .)
    LESS_TH         reduce using rule 131 (np_addTerm -> .)
    GREAT_TH        reduce using rule 131 (np_addTerm -> .)
    SAME            reduce using rule 131 (np_addTerm -> .)
    DIF             reduce using rule 131 (np_addTerm -> .)
    OR              reduce using rule 131 (np_addTerm -> .)
    AND             reduce using rule 131 (np_addTerm -> .)
    COMMA           reduce using rule 131 (np_addTerm -> .)
    R_PAR           reduce using rule 131 (np_addTerm -> .)
    R_BREAK         reduce using rule 131 (np_addTerm -> .)
    TO              reduce using rule 131 (np_addTerm -> .)
    ID              reduce using rule 131 (np_addTerm -> .)
    RETURN          reduce using rule 131 (np_addTerm -> .)
    READ            reduce using rule 131 (np_addTerm -> .)
    WRITE           reduce using rule 131 (np_addTerm -> .)
    IF              reduce using rule 131 (np_addTerm -> .)
    VAR             reduce using rule 131 (np_addTerm -> .)
    WHILE           reduce using rule 131 (np_addTerm -> .)
    FROM            reduce using rule 131 (np_addTerm -> .)
    R_CURPAR        reduce using rule 131 (np_addTerm -> .)
    SEMICOLON       reduce using rule 131 (np_addTerm -> .)
    DO              reduce using rule 131 (np_addTerm -> .)

    np_addTerm                     shift and go to state 219

state 166

    (110) factor -> factorT .

    MULT            reduce using rule 110 (factor -> factorT .)
    DIV             reduce using rule 110 (factor -> factorT .)
    PLUS            reduce using rule 110 (factor -> factorT .)
    MINUS           reduce using rule 110 (factor -> factorT .)
    LESS            reduce using rule 110 (factor -> factorT .)
    GREATER         reduce using rule 110 (factor -> factorT .)
    LESS_TH         reduce using rule 110 (factor -> factorT .)
    GREAT_TH        reduce using rule 110 (factor -> factorT .)
    SAME            reduce using rule 110 (factor -> factorT .)
    DIF             reduce using rule 110 (factor -> factorT .)
    OR              reduce using rule 110 (factor -> factorT .)
    AND             reduce using rule 110 (factor -> factorT .)
    COMMA           reduce using rule 110 (factor -> factorT .)
    R_PAR           reduce using rule 110 (factor -> factorT .)
    R_BREAK         reduce using rule 110 (factor -> factorT .)
    TO              reduce using rule 110 (factor -> factorT .)
    ID              reduce using rule 110 (factor -> factorT .)
    RETURN          reduce using rule 110 (factor -> factorT .)
    READ            reduce using rule 110 (factor -> factorT .)
    WRITE           reduce using rule 110 (factor -> factorT .)
    IF              reduce using rule 110 (factor -> factorT .)
    VAR             reduce using rule 110 (factor -> factorT .)
    WHILE           reduce using rule 110 (factor -> factorT .)
    FROM            reduce using rule 110 (factor -> factorT .)
    R_CURPAR        reduce using rule 110 (factor -> factorT .)
    SEMICOLON       reduce using rule 110 (factor -> factorT .)
    DO              reduce using rule 110 (factor -> factorT .)


state 167

    (111) factorT -> PLUS . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    factorF                        shift and go to state 220
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 168

    (113) factorT -> factorF .

    MULT            reduce using rule 113 (factorT -> factorF .)
    DIV             reduce using rule 113 (factorT -> factorF .)
    PLUS            reduce using rule 113 (factorT -> factorF .)
    MINUS           reduce using rule 113 (factorT -> factorF .)
    LESS            reduce using rule 113 (factorT -> factorF .)
    GREATER         reduce using rule 113 (factorT -> factorF .)
    LESS_TH         reduce using rule 113 (factorT -> factorF .)
    GREAT_TH        reduce using rule 113 (factorT -> factorF .)
    SAME            reduce using rule 113 (factorT -> factorF .)
    DIF             reduce using rule 113 (factorT -> factorF .)
    OR              reduce using rule 113 (factorT -> factorF .)
    AND             reduce using rule 113 (factorT -> factorF .)
    COMMA           reduce using rule 113 (factorT -> factorF .)
    R_PAR           reduce using rule 113 (factorT -> factorF .)
    R_BREAK         reduce using rule 113 (factorT -> factorF .)
    TO              reduce using rule 113 (factorT -> factorF .)
    ID              reduce using rule 113 (factorT -> factorF .)
    RETURN          reduce using rule 113 (factorT -> factorF .)
    READ            reduce using rule 113 (factorT -> factorF .)
    WRITE           reduce using rule 113 (factorT -> factorF .)
    IF              reduce using rule 113 (factorT -> factorF .)
    VAR             reduce using rule 113 (factorT -> factorF .)
    WHILE           reduce using rule 113 (factorT -> factorF .)
    FROM            reduce using rule 113 (factorT -> factorF .)
    R_CURPAR        reduce using rule 113 (factorT -> factorF .)
    SEMICOLON       reduce using rule 113 (factorT -> factorF .)
    DO              reduce using rule 113 (factorT -> factorF .)


state 169

    (112) factorT -> MINUS . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    factorF                        shift and go to state 221
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 170

    (114) factorF -> varcte . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 222

state 171

    (115) varcte -> var . np_addId empty
    (127) np_addId -> .

    MULT            reduce using rule 127 (np_addId -> .)
    DIV             reduce using rule 127 (np_addId -> .)
    PLUS            reduce using rule 127 (np_addId -> .)
    MINUS           reduce using rule 127 (np_addId -> .)
    LESS            reduce using rule 127 (np_addId -> .)
    GREATER         reduce using rule 127 (np_addId -> .)
    LESS_TH         reduce using rule 127 (np_addId -> .)
    GREAT_TH        reduce using rule 127 (np_addId -> .)
    SAME            reduce using rule 127 (np_addId -> .)
    DIF             reduce using rule 127 (np_addId -> .)
    OR              reduce using rule 127 (np_addId -> .)
    AND             reduce using rule 127 (np_addId -> .)
    COMMA           reduce using rule 127 (np_addId -> .)
    R_PAR           reduce using rule 127 (np_addId -> .)
    R_BREAK         reduce using rule 127 (np_addId -> .)
    TO              reduce using rule 127 (np_addId -> .)
    ID              reduce using rule 127 (np_addId -> .)
    RETURN          reduce using rule 127 (np_addId -> .)
    READ            reduce using rule 127 (np_addId -> .)
    WRITE           reduce using rule 127 (np_addId -> .)
    IF              reduce using rule 127 (np_addId -> .)
    VAR             reduce using rule 127 (np_addId -> .)
    WHILE           reduce using rule 127 (np_addId -> .)
    FROM            reduce using rule 127 (np_addId -> .)
    R_CURPAR        reduce using rule 127 (np_addId -> .)
    SEMICOLON       reduce using rule 127 (np_addId -> .)
    DO              reduce using rule 127 (np_addId -> .)

    np_addId                       shift and go to state 223

state 172

    (116) varcte -> CTE_INT . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 224

state 173

    (117) varcte -> CTE_FLOAT . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 225

state 174

    (118) varcte -> CTE_CHAR . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 226

state 175

    (119) varcte -> CTE_BOOL . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 227

state 176

    (59) return -> RETURN L_PAR exp . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 228


state 177

    (64) read -> READ L_PAR readF .

    ID              reduce using rule 64 (read -> READ L_PAR readF .)
    RETURN          reduce using rule 64 (read -> READ L_PAR readF .)
    READ            reduce using rule 64 (read -> READ L_PAR readF .)
    WRITE           reduce using rule 64 (read -> READ L_PAR readF .)
    IF              reduce using rule 64 (read -> READ L_PAR readF .)
    VAR             reduce using rule 64 (read -> READ L_PAR readF .)
    WHILE           reduce using rule 64 (read -> READ L_PAR readF .)
    FROM            reduce using rule 64 (read -> READ L_PAR readF .)
    R_CURPAR        reduce using rule 64 (read -> READ L_PAR readF .)
    SEMICOLON       reduce using rule 64 (read -> READ L_PAR readF .)


state 178

    (65) readF -> var . np_addRead COMMA readF
    (66) readF -> var . np_addRead R_PAR SEMICOLON empty
    (136) np_addRead -> .

    COMMA           reduce using rule 136 (np_addRead -> .)
    R_PAR           reduce using rule 136 (np_addRead -> .)

    np_addRead                     shift and go to state 229

state 179

    (67) write -> WRITE L_PAR writeT .

    ID              reduce using rule 67 (write -> WRITE L_PAR writeT .)
    RETURN          reduce using rule 67 (write -> WRITE L_PAR writeT .)
    READ            reduce using rule 67 (write -> WRITE L_PAR writeT .)
    WRITE           reduce using rule 67 (write -> WRITE L_PAR writeT .)
    IF              reduce using rule 67 (write -> WRITE L_PAR writeT .)
    VAR             reduce using rule 67 (write -> WRITE L_PAR writeT .)
    WHILE           reduce using rule 67 (write -> WRITE L_PAR writeT .)
    FROM            reduce using rule 67 (write -> WRITE L_PAR writeT .)
    R_CURPAR        reduce using rule 67 (write -> WRITE L_PAR writeT .)
    SEMICOLON       reduce using rule 67 (write -> WRITE L_PAR writeT .)


state 180

    (68) writeT -> CTE_STRING . writeF
    (70) writeF -> . COMMA writeT
    (71) writeF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 231
    R_PAR           shift and go to state 232

    writeF                         shift and go to state 230

state 181

    (69) writeT -> exp . writeF
    (70) writeF -> . COMMA writeT
    (71) writeF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 231
    R_PAR           shift and go to state 232

    writeF                         shift and go to state 233

state 182

    (74) if -> IF L_PAR exp . R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    R_PAR           shift and go to state 234


state 183

    (62) varF -> arrfunc empty .

    EQUAL           reduce using rule 62 (varF -> arrfunc empty .)
    PLUS_EQ         reduce using rule 62 (varF -> arrfunc empty .)
    MIN_EQ          reduce using rule 62 (varF -> arrfunc empty .)
    MULT_EQ         reduce using rule 62 (varF -> arrfunc empty .)
    DIV_EQ          reduce using rule 62 (varF -> arrfunc empty .)
    MULT            reduce using rule 62 (varF -> arrfunc empty .)
    DIV             reduce using rule 62 (varF -> arrfunc empty .)
    PLUS            reduce using rule 62 (varF -> arrfunc empty .)
    MINUS           reduce using rule 62 (varF -> arrfunc empty .)
    LESS            reduce using rule 62 (varF -> arrfunc empty .)
    GREATER         reduce using rule 62 (varF -> arrfunc empty .)
    LESS_TH         reduce using rule 62 (varF -> arrfunc empty .)
    GREAT_TH        reduce using rule 62 (varF -> arrfunc empty .)
    SAME            reduce using rule 62 (varF -> arrfunc empty .)
    DIF             reduce using rule 62 (varF -> arrfunc empty .)
    OR              reduce using rule 62 (varF -> arrfunc empty .)
    AND             reduce using rule 62 (varF -> arrfunc empty .)
    COMMA           reduce using rule 62 (varF -> arrfunc empty .)
    R_PAR           reduce using rule 62 (varF -> arrfunc empty .)
    R_BREAK         reduce using rule 62 (varF -> arrfunc empty .)
    TO              reduce using rule 62 (varF -> arrfunc empty .)
    ID              reduce using rule 62 (varF -> arrfunc empty .)
    RETURN          reduce using rule 62 (varF -> arrfunc empty .)
    READ            reduce using rule 62 (varF -> arrfunc empty .)
    WRITE           reduce using rule 62 (varF -> arrfunc empty .)
    IF              reduce using rule 62 (varF -> arrfunc empty .)
    VAR             reduce using rule 62 (varF -> arrfunc empty .)
    WHILE           reduce using rule 62 (varF -> arrfunc empty .)
    FROM            reduce using rule 62 (varF -> arrfunc empty .)
    R_CURPAR        reduce using rule 62 (varF -> arrfunc empty .)
    SEMICOLON       reduce using rule 62 (varF -> arrfunc empty .)
    DO              reduce using rule 62 (varF -> arrfunc empty .)


state 184

    (54) arrfunc -> L_BREAK exp . COMMA exp R_BREAK empty
    (55) arrfunc -> L_BREAK exp . R_BREAK empty

    COMMA           shift and go to state 235
    R_BREAK         shift and go to state 236


state 185

    (84) conditional -> WHILE L_PAR exp . R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    R_PAR           shift and go to state 237


state 186

    (85) nonconditional -> FROM VAR arrfunc . nonconditionalF
    (87) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    nonconditionalF                shift and go to state 238
    exp                            shift and go to state 188
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 187

    (86) nonconditional -> FROM VAR nonconditionalF .

    ID              reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    RETURN          reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    READ            reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    WRITE           reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    IF              reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    VAR             reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    WHILE           reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    FROM            reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    R_CURPAR        reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    SEMICOLON       reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)


state 188

    (87) nonconditionalF -> exp . TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty

    TO              shift and go to state 239


state 189

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR . SEMICOLON empty

    SEMICOLON       shift and go to state 240


state 190

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec dec .

    MAIN            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    INT             reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    FLOAT           reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    CHAR            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    BOOL            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    ID              reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    VOID            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    METHODS         reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    L_CURPAR        reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)


state 191

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    METHODS         reduce using rule 120 (empty -> .)
    L_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 241

state 192

    (25) funcF -> parameter R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 242


state 193

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 243
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 194

    (33) parameter -> VAR COLON typepar SEMICOLON . parameterF
    (34) parameterF -> . parameter
    (35) parameterF -> . empty
    (33) parameter -> . VAR COLON typepar SEMICOLON parameterF
    (120) empty -> .

    VAR             shift and go to state 83
    R_PAR           reduce using rule 120 (empty -> .)

    parameterF                     shift and go to state 244
    parameter                      shift and go to state 245
    empty                          shift and go to state 246

state 195

    (36) typepar -> INT empty .

    SEMICOLON       reduce using rule 36 (typepar -> INT empty .)


state 196

    (37) typepar -> FLOAT empty .

    SEMICOLON       reduce using rule 37 (typepar -> FLOAT empty .)


state 197

    (38) typepar -> CHAR empty .

    SEMICOLON       reduce using rule 38 (typepar -> CHAR empty .)


state 198

    (39) typepar -> BOOL empty .

    SEMICOLON       reduce using rule 39 (typepar -> BOOL empty .)


state 199

    (40) typepar -> ID empty .

    SEMICOLON       reduce using rule 40 (typepar -> ID empty .)


state 200

    (78) assigmentF -> EQUAL np_addOp . exp np_doAssign empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    exp                            shift and go to state 247
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 201

    (79) assigmentF -> ope np_addOp . exp np_doAssign empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    exp                            shift and go to state 248
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 202

    (80) ope -> PLUS_EQ empty .

    L_PAR           reduce using rule 80 (ope -> PLUS_EQ empty .)
    PLUS            reduce using rule 80 (ope -> PLUS_EQ empty .)
    MINUS           reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_INT         reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_FLOAT       reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_CHAR        reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_BOOL        reduce using rule 80 (ope -> PLUS_EQ empty .)
    VAR             reduce using rule 80 (ope -> PLUS_EQ empty .)
    ID              reduce using rule 80 (ope -> PLUS_EQ empty .)


state 203

    (81) ope -> MIN_EQ empty .

    L_PAR           reduce using rule 81 (ope -> MIN_EQ empty .)
    PLUS            reduce using rule 81 (ope -> MIN_EQ empty .)
    MINUS           reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_INT         reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_FLOAT       reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_CHAR        reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_BOOL        reduce using rule 81 (ope -> MIN_EQ empty .)
    VAR             reduce using rule 81 (ope -> MIN_EQ empty .)
    ID              reduce using rule 81 (ope -> MIN_EQ empty .)


state 204

    (82) ope -> MULT_EQ empty .

    L_PAR           reduce using rule 82 (ope -> MULT_EQ empty .)
    PLUS            reduce using rule 82 (ope -> MULT_EQ empty .)
    MINUS           reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_INT         reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_FLOAT       reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_CHAR        reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_BOOL        reduce using rule 82 (ope -> MULT_EQ empty .)
    VAR             reduce using rule 82 (ope -> MULT_EQ empty .)
    ID              reduce using rule 82 (ope -> MULT_EQ empty .)


state 205

    (83) ope -> DIV_EQ empty .

    L_PAR           reduce using rule 83 (ope -> DIV_EQ empty .)
    PLUS            reduce using rule 83 (ope -> DIV_EQ empty .)
    MINUS           reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_INT         reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_FLOAT       reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_CHAR        reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_BOOL        reduce using rule 83 (ope -> DIV_EQ empty .)
    VAR             reduce using rule 83 (ope -> DIV_EQ empty .)
    ID              reduce using rule 83 (ope -> DIV_EQ empty .)


state 206

    (51) void -> ID DOT ID L_PAR . param R_PAR SEMICOLON empty
    (56) param -> . exp paramF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    param                          shift and go to state 249
    exp                            shift and go to state 160
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 207

    (61) var -> ID DOT VAR varF .

    EQUAL           reduce using rule 61 (var -> ID DOT VAR varF .)
    PLUS_EQ         reduce using rule 61 (var -> ID DOT VAR varF .)
    MIN_EQ          reduce using rule 61 (var -> ID DOT VAR varF .)
    MULT_EQ         reduce using rule 61 (var -> ID DOT VAR varF .)
    DIV_EQ          reduce using rule 61 (var -> ID DOT VAR varF .)
    MULT            reduce using rule 61 (var -> ID DOT VAR varF .)
    DIV             reduce using rule 61 (var -> ID DOT VAR varF .)
    PLUS            reduce using rule 61 (var -> ID DOT VAR varF .)
    MINUS           reduce using rule 61 (var -> ID DOT VAR varF .)
    LESS            reduce using rule 61 (var -> ID DOT VAR varF .)
    GREATER         reduce using rule 61 (var -> ID DOT VAR varF .)
    LESS_TH         reduce using rule 61 (var -> ID DOT VAR varF .)
    GREAT_TH        reduce using rule 61 (var -> ID DOT VAR varF .)
    SAME            reduce using rule 61 (var -> ID DOT VAR varF .)
    DIF             reduce using rule 61 (var -> ID DOT VAR varF .)
    OR              reduce using rule 61 (var -> ID DOT VAR varF .)
    AND             reduce using rule 61 (var -> ID DOT VAR varF .)
    COMMA           reduce using rule 61 (var -> ID DOT VAR varF .)
    R_PAR           reduce using rule 61 (var -> ID DOT VAR varF .)
    R_BREAK         reduce using rule 61 (var -> ID DOT VAR varF .)
    TO              reduce using rule 61 (var -> ID DOT VAR varF .)
    ID              reduce using rule 61 (var -> ID DOT VAR varF .)
    RETURN          reduce using rule 61 (var -> ID DOT VAR varF .)
    READ            reduce using rule 61 (var -> ID DOT VAR varF .)
    WRITE           reduce using rule 61 (var -> ID DOT VAR varF .)
    IF              reduce using rule 61 (var -> ID DOT VAR varF .)
    VAR             reduce using rule 61 (var -> ID DOT VAR varF .)
    WHILE           reduce using rule 61 (var -> ID DOT VAR varF .)
    FROM            reduce using rule 61 (var -> ID DOT VAR varF .)
    R_CURPAR        reduce using rule 61 (var -> ID DOT VAR varF .)
    SEMICOLON       reduce using rule 61 (var -> ID DOT VAR varF .)
    DO              reduce using rule 61 (var -> ID DOT VAR varF .)


state 208

    (61) var -> ID DOT . VAR varF

    VAR             shift and go to state 155


state 209

    (109) factor -> L_PAR np_addPar . exp R_PAR np_popPar empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    exp                            shift and go to state 250
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 210

    (52) void -> ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 251


state 211

    (53) void -> ID L_PAR R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 252

state 212

    (56) param -> exp paramF .

    R_PAR           reduce using rule 56 (param -> exp paramF .)


state 213

    (57) paramF -> COMMA . param
    (56) param -> . exp paramF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    param                          shift and go to state 253
    exp                            shift and go to state 160
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 214

    (58) paramF -> empty .

    R_PAR           reduce using rule 58 (paramF -> empty .)


state 215

    (100) exp -> bool empty .

    COMMA           reduce using rule 100 (exp -> bool empty .)
    R_PAR           reduce using rule 100 (exp -> bool empty .)
    R_BREAK         reduce using rule 100 (exp -> bool empty .)
    TO              reduce using rule 100 (exp -> bool empty .)
    ID              reduce using rule 100 (exp -> bool empty .)
    RETURN          reduce using rule 100 (exp -> bool empty .)
    READ            reduce using rule 100 (exp -> bool empty .)
    WRITE           reduce using rule 100 (exp -> bool empty .)
    IF              reduce using rule 100 (exp -> bool empty .)
    VAR             reduce using rule 100 (exp -> bool empty .)
    WHILE           reduce using rule 100 (exp -> bool empty .)
    FROM            reduce using rule 100 (exp -> bool empty .)
    R_CURPAR        reduce using rule 100 (exp -> bool empty .)
    SEMICOLON       reduce using rule 100 (exp -> bool empty .)
    DO              reduce using rule 100 (exp -> bool empty .)


state 216

    (88) bool -> logical np_addBool . boolF
    (89) boolF -> . OR np_addOp bool
    (90) boolF -> . AND np_addOp bool
    (91) boolF -> . empty
    (120) empty -> .

    OR              shift and go to state 255
    AND             shift and go to state 256
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    boolF                          shift and go to state 254
    empty                          shift and go to state 257

state 217

    (92) logical -> ex np_addLogical . logicalF
    (93) logicalF -> . LESS np_addOp logical
    (94) logicalF -> . GREATER np_addOp logical
    (95) logicalF -> . LESS_TH np_addOp logical
    (96) logicalF -> . GREAT_TH np_addOp logical
    (97) logicalF -> . SAME np_addOp logical
    (98) logicalF -> . DIF np_addOp logical
    (99) logicalF -> . empty
    (120) empty -> .

    LESS            shift and go to state 259
    GREATER         shift and go to state 260
    LESS_TH         shift and go to state 261
    GREAT_TH        shift and go to state 262
    SAME            shift and go to state 263
    DIF             shift and go to state 264
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    logicalF                       shift and go to state 258
    empty                          shift and go to state 265

state 218

    (101) ex -> term np_addEx . exF
    (102) exF -> . PLUS np_addOp ex
    (103) exF -> . MINUS np_addOp ex
    (104) exF -> . empty
    (120) empty -> .

    PLUS            shift and go to state 267
    MINUS           shift and go to state 268
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    exF                            shift and go to state 266
    empty                          shift and go to state 269

state 219

    (105) term -> factor np_addTerm . termF
    (106) termF -> . MULT np_addOp term
    (107) termF -> . DIV np_addOp term
    (108) termF -> . empty
    (120) empty -> .

    MULT            shift and go to state 271
    DIV             shift and go to state 272
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    termF                          shift and go to state 270
    empty                          shift and go to state 273

state 220

    (111) factorT -> PLUS factorF .

    MULT            reduce using rule 111 (factorT -> PLUS factorF .)
    DIV             reduce using rule 111 (factorT -> PLUS factorF .)
    PLUS            reduce using rule 111 (factorT -> PLUS factorF .)
    MINUS           reduce using rule 111 (factorT -> PLUS factorF .)
    LESS            reduce using rule 111 (factorT -> PLUS factorF .)
    GREATER         reduce using rule 111 (factorT -> PLUS factorF .)
    LESS_TH         reduce using rule 111 (factorT -> PLUS factorF .)
    GREAT_TH        reduce using rule 111 (factorT -> PLUS factorF .)
    SAME            reduce using rule 111 (factorT -> PLUS factorF .)
    DIF             reduce using rule 111 (factorT -> PLUS factorF .)
    OR              reduce using rule 111 (factorT -> PLUS factorF .)
    AND             reduce using rule 111 (factorT -> PLUS factorF .)
    COMMA           reduce using rule 111 (factorT -> PLUS factorF .)
    R_PAR           reduce using rule 111 (factorT -> PLUS factorF .)
    R_BREAK         reduce using rule 111 (factorT -> PLUS factorF .)
    TO              reduce using rule 111 (factorT -> PLUS factorF .)
    ID              reduce using rule 111 (factorT -> PLUS factorF .)
    RETURN          reduce using rule 111 (factorT -> PLUS factorF .)
    READ            reduce using rule 111 (factorT -> PLUS factorF .)
    WRITE           reduce using rule 111 (factorT -> PLUS factorF .)
    IF              reduce using rule 111 (factorT -> PLUS factorF .)
    VAR             reduce using rule 111 (factorT -> PLUS factorF .)
    WHILE           reduce using rule 111 (factorT -> PLUS factorF .)
    FROM            reduce using rule 111 (factorT -> PLUS factorF .)
    R_CURPAR        reduce using rule 111 (factorT -> PLUS factorF .)
    SEMICOLON       reduce using rule 111 (factorT -> PLUS factorF .)
    DO              reduce using rule 111 (factorT -> PLUS factorF .)


state 221

    (112) factorT -> MINUS factorF .

    MULT            reduce using rule 112 (factorT -> MINUS factorF .)
    DIV             reduce using rule 112 (factorT -> MINUS factorF .)
    PLUS            reduce using rule 112 (factorT -> MINUS factorF .)
    MINUS           reduce using rule 112 (factorT -> MINUS factorF .)
    LESS            reduce using rule 112 (factorT -> MINUS factorF .)
    GREATER         reduce using rule 112 (factorT -> MINUS factorF .)
    LESS_TH         reduce using rule 112 (factorT -> MINUS factorF .)
    GREAT_TH        reduce using rule 112 (factorT -> MINUS factorF .)
    SAME            reduce using rule 112 (factorT -> MINUS factorF .)
    DIF             reduce using rule 112 (factorT -> MINUS factorF .)
    OR              reduce using rule 112 (factorT -> MINUS factorF .)
    AND             reduce using rule 112 (factorT -> MINUS factorF .)
    COMMA           reduce using rule 112 (factorT -> MINUS factorF .)
    R_PAR           reduce using rule 112 (factorT -> MINUS factorF .)
    R_BREAK         reduce using rule 112 (factorT -> MINUS factorF .)
    TO              reduce using rule 112 (factorT -> MINUS factorF .)
    ID              reduce using rule 112 (factorT -> MINUS factorF .)
    RETURN          reduce using rule 112 (factorT -> MINUS factorF .)
    READ            reduce using rule 112 (factorT -> MINUS factorF .)
    WRITE           reduce using rule 112 (factorT -> MINUS factorF .)
    IF              reduce using rule 112 (factorT -> MINUS factorF .)
    VAR             reduce using rule 112 (factorT -> MINUS factorF .)
    WHILE           reduce using rule 112 (factorT -> MINUS factorF .)
    FROM            reduce using rule 112 (factorT -> MINUS factorF .)
    R_CURPAR        reduce using rule 112 (factorT -> MINUS factorF .)
    SEMICOLON       reduce using rule 112 (factorT -> MINUS factorF .)
    DO              reduce using rule 112 (factorT -> MINUS factorF .)


state 222

    (114) factorF -> varcte empty .

    MULT            reduce using rule 114 (factorF -> varcte empty .)
    DIV             reduce using rule 114 (factorF -> varcte empty .)
    PLUS            reduce using rule 114 (factorF -> varcte empty .)
    MINUS           reduce using rule 114 (factorF -> varcte empty .)
    LESS            reduce using rule 114 (factorF -> varcte empty .)
    GREATER         reduce using rule 114 (factorF -> varcte empty .)
    LESS_TH         reduce using rule 114 (factorF -> varcte empty .)
    GREAT_TH        reduce using rule 114 (factorF -> varcte empty .)
    SAME            reduce using rule 114 (factorF -> varcte empty .)
    DIF             reduce using rule 114 (factorF -> varcte empty .)
    OR              reduce using rule 114 (factorF -> varcte empty .)
    AND             reduce using rule 114 (factorF -> varcte empty .)
    COMMA           reduce using rule 114 (factorF -> varcte empty .)
    R_PAR           reduce using rule 114 (factorF -> varcte empty .)
    R_BREAK         reduce using rule 114 (factorF -> varcte empty .)
    TO              reduce using rule 114 (factorF -> varcte empty .)
    ID              reduce using rule 114 (factorF -> varcte empty .)
    RETURN          reduce using rule 114 (factorF -> varcte empty .)
    READ            reduce using rule 114 (factorF -> varcte empty .)
    WRITE           reduce using rule 114 (factorF -> varcte empty .)
    IF              reduce using rule 114 (factorF -> varcte empty .)
    VAR             reduce using rule 114 (factorF -> varcte empty .)
    WHILE           reduce using rule 114 (factorF -> varcte empty .)
    FROM            reduce using rule 114 (factorF -> varcte empty .)
    R_CURPAR        reduce using rule 114 (factorF -> varcte empty .)
    SEMICOLON       reduce using rule 114 (factorF -> varcte empty .)
    DO              reduce using rule 114 (factorF -> varcte empty .)


state 223

    (115) varcte -> var np_addId . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 274

state 224

    (116) varcte -> CTE_INT empty .

    MULT            reduce using rule 116 (varcte -> CTE_INT empty .)
    DIV             reduce using rule 116 (varcte -> CTE_INT empty .)
    PLUS            reduce using rule 116 (varcte -> CTE_INT empty .)
    MINUS           reduce using rule 116 (varcte -> CTE_INT empty .)
    LESS            reduce using rule 116 (varcte -> CTE_INT empty .)
    GREATER         reduce using rule 116 (varcte -> CTE_INT empty .)
    LESS_TH         reduce using rule 116 (varcte -> CTE_INT empty .)
    GREAT_TH        reduce using rule 116 (varcte -> CTE_INT empty .)
    SAME            reduce using rule 116 (varcte -> CTE_INT empty .)
    DIF             reduce using rule 116 (varcte -> CTE_INT empty .)
    OR              reduce using rule 116 (varcte -> CTE_INT empty .)
    AND             reduce using rule 116 (varcte -> CTE_INT empty .)
    COMMA           reduce using rule 116 (varcte -> CTE_INT empty .)
    R_PAR           reduce using rule 116 (varcte -> CTE_INT empty .)
    R_BREAK         reduce using rule 116 (varcte -> CTE_INT empty .)
    TO              reduce using rule 116 (varcte -> CTE_INT empty .)
    ID              reduce using rule 116 (varcte -> CTE_INT empty .)
    RETURN          reduce using rule 116 (varcte -> CTE_INT empty .)
    READ            reduce using rule 116 (varcte -> CTE_INT empty .)
    WRITE           reduce using rule 116 (varcte -> CTE_INT empty .)
    IF              reduce using rule 116 (varcte -> CTE_INT empty .)
    VAR             reduce using rule 116 (varcte -> CTE_INT empty .)
    WHILE           reduce using rule 116 (varcte -> CTE_INT empty .)
    FROM            reduce using rule 116 (varcte -> CTE_INT empty .)
    R_CURPAR        reduce using rule 116 (varcte -> CTE_INT empty .)
    SEMICOLON       reduce using rule 116 (varcte -> CTE_INT empty .)
    DO              reduce using rule 116 (varcte -> CTE_INT empty .)


state 225

    (117) varcte -> CTE_FLOAT empty .

    MULT            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    DIV             reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    PLUS            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    MINUS           reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    LESS            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    GREATER         reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    LESS_TH         reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    GREAT_TH        reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    SAME            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    DIF             reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    OR              reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    AND             reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    COMMA           reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    R_PAR           reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    R_BREAK         reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    TO              reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    ID              reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    RETURN          reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    READ            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    WRITE           reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    IF              reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    VAR             reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    WHILE           reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    FROM            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    R_CURPAR        reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    SEMICOLON       reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    DO              reduce using rule 117 (varcte -> CTE_FLOAT empty .)


state 226

    (118) varcte -> CTE_CHAR empty .

    MULT            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    DIV             reduce using rule 118 (varcte -> CTE_CHAR empty .)
    PLUS            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    MINUS           reduce using rule 118 (varcte -> CTE_CHAR empty .)
    LESS            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    GREATER         reduce using rule 118 (varcte -> CTE_CHAR empty .)
    LESS_TH         reduce using rule 118 (varcte -> CTE_CHAR empty .)
    GREAT_TH        reduce using rule 118 (varcte -> CTE_CHAR empty .)
    SAME            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    DIF             reduce using rule 118 (varcte -> CTE_CHAR empty .)
    OR              reduce using rule 118 (varcte -> CTE_CHAR empty .)
    AND             reduce using rule 118 (varcte -> CTE_CHAR empty .)
    COMMA           reduce using rule 118 (varcte -> CTE_CHAR empty .)
    R_PAR           reduce using rule 118 (varcte -> CTE_CHAR empty .)
    R_BREAK         reduce using rule 118 (varcte -> CTE_CHAR empty .)
    TO              reduce using rule 118 (varcte -> CTE_CHAR empty .)
    ID              reduce using rule 118 (varcte -> CTE_CHAR empty .)
    RETURN          reduce using rule 118 (varcte -> CTE_CHAR empty .)
    READ            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    WRITE           reduce using rule 118 (varcte -> CTE_CHAR empty .)
    IF              reduce using rule 118 (varcte -> CTE_CHAR empty .)
    VAR             reduce using rule 118 (varcte -> CTE_CHAR empty .)
    WHILE           reduce using rule 118 (varcte -> CTE_CHAR empty .)
    FROM            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    R_CURPAR        reduce using rule 118 (varcte -> CTE_CHAR empty .)
    SEMICOLON       reduce using rule 118 (varcte -> CTE_CHAR empty .)
    DO              reduce using rule 118 (varcte -> CTE_CHAR empty .)


state 227

    (119) varcte -> CTE_BOOL empty .

    MULT            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    DIV             reduce using rule 119 (varcte -> CTE_BOOL empty .)
    PLUS            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    MINUS           reduce using rule 119 (varcte -> CTE_BOOL empty .)
    LESS            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    GREATER         reduce using rule 119 (varcte -> CTE_BOOL empty .)
    LESS_TH         reduce using rule 119 (varcte -> CTE_BOOL empty .)
    GREAT_TH        reduce using rule 119 (varcte -> CTE_BOOL empty .)
    SAME            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    DIF             reduce using rule 119 (varcte -> CTE_BOOL empty .)
    OR              reduce using rule 119 (varcte -> CTE_BOOL empty .)
    AND             reduce using rule 119 (varcte -> CTE_BOOL empty .)
    COMMA           reduce using rule 119 (varcte -> CTE_BOOL empty .)
    R_PAR           reduce using rule 119 (varcte -> CTE_BOOL empty .)
    R_BREAK         reduce using rule 119 (varcte -> CTE_BOOL empty .)
    TO              reduce using rule 119 (varcte -> CTE_BOOL empty .)
    ID              reduce using rule 119 (varcte -> CTE_BOOL empty .)
    RETURN          reduce using rule 119 (varcte -> CTE_BOOL empty .)
    READ            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    WRITE           reduce using rule 119 (varcte -> CTE_BOOL empty .)
    IF              reduce using rule 119 (varcte -> CTE_BOOL empty .)
    VAR             reduce using rule 119 (varcte -> CTE_BOOL empty .)
    WHILE           reduce using rule 119 (varcte -> CTE_BOOL empty .)
    FROM            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    R_CURPAR        reduce using rule 119 (varcte -> CTE_BOOL empty .)
    SEMICOLON       reduce using rule 119 (varcte -> CTE_BOOL empty .)
    DO              reduce using rule 119 (varcte -> CTE_BOOL empty .)


state 228

    (59) return -> RETURN L_PAR exp R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 275


state 229

    (65) readF -> var np_addRead . COMMA readF
    (66) readF -> var np_addRead . R_PAR SEMICOLON empty

    COMMA           shift and go to state 276
    R_PAR           shift and go to state 277


state 230

    (68) writeT -> CTE_STRING writeF .

    ID              reduce using rule 68 (writeT -> CTE_STRING writeF .)
    RETURN          reduce using rule 68 (writeT -> CTE_STRING writeF .)
    READ            reduce using rule 68 (writeT -> CTE_STRING writeF .)
    WRITE           reduce using rule 68 (writeT -> CTE_STRING writeF .)
    IF              reduce using rule 68 (writeT -> CTE_STRING writeF .)
    VAR             reduce using rule 68 (writeT -> CTE_STRING writeF .)
    WHILE           reduce using rule 68 (writeT -> CTE_STRING writeF .)
    FROM            reduce using rule 68 (writeT -> CTE_STRING writeF .)
    R_CURPAR        reduce using rule 68 (writeT -> CTE_STRING writeF .)
    SEMICOLON       reduce using rule 68 (writeT -> CTE_STRING writeF .)


state 231

    (70) writeF -> COMMA . writeT
    (68) writeT -> . CTE_STRING writeF
    (69) writeT -> . exp writeF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 180
    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    writeT                         shift and go to state 278
    exp                            shift and go to state 181
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 232

    (71) writeF -> R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 279


state 233

    (69) writeT -> exp writeF .

    ID              reduce using rule 69 (writeT -> exp writeF .)
    RETURN          reduce using rule 69 (writeT -> exp writeF .)
    READ            reduce using rule 69 (writeT -> exp writeF .)
    WRITE           reduce using rule 69 (writeT -> exp writeF .)
    IF              reduce using rule 69 (writeT -> exp writeF .)
    VAR             reduce using rule 69 (writeT -> exp writeF .)
    WHILE           reduce using rule 69 (writeT -> exp writeF .)
    FROM            reduce using rule 69 (writeT -> exp writeF .)
    R_CURPAR        reduce using rule 69 (writeT -> exp writeF .)
    SEMICOLON       reduce using rule 69 (writeT -> exp writeF .)


state 234

    (74) if -> IF L_PAR exp R_PAR . THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    THEN            shift and go to state 280


state 235

    (54) arrfunc -> L_BREAK exp COMMA . exp R_BREAK empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    exp                            shift and go to state 281
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 236

    (55) arrfunc -> L_BREAK exp R_BREAK . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)
    L_PAR           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 282

state 237

    (84) conditional -> WHILE L_PAR exp R_PAR . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 283


state 238

    (85) nonconditional -> FROM VAR arrfunc nonconditionalF .

    ID              reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    RETURN          reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    READ            reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WRITE           reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    IF              reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    VAR             reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WHILE           reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    FROM            reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    R_CURPAR        reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    SEMICOLON       reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)


state 239

    (87) nonconditionalF -> exp TO . exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    exp                            shift and go to state 284
    bool                           shift and go to state 161
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 240

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON . empty
    (120) empty -> .

    CLASS           reduce using rule 120 (empty -> .)
    VARS            reduce using rule 120 (empty -> .)
    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 285

state 241

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .

    MAIN            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    INT             reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    FLOAT           reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    CHAR            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    BOOL            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    ID              reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    VOID            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    METHODS         reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    L_CURPAR        reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)


state 242

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 286
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 243

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 287


state 244

    (33) parameter -> VAR COLON typepar SEMICOLON parameterF .

    R_PAR           reduce using rule 33 (parameter -> VAR COLON typepar SEMICOLON parameterF .)


state 245

    (34) parameterF -> parameter .

    R_PAR           reduce using rule 34 (parameterF -> parameter .)


state 246

    (35) parameterF -> empty .

    R_PAR           reduce using rule 35 (parameterF -> empty .)


state 247

    (78) assigmentF -> EQUAL np_addOp exp . np_doAssign empty
    (135) np_doAssign -> .

    ID              reduce using rule 135 (np_doAssign -> .)
    RETURN          reduce using rule 135 (np_doAssign -> .)
    READ            reduce using rule 135 (np_doAssign -> .)
    WRITE           reduce using rule 135 (np_doAssign -> .)
    IF              reduce using rule 135 (np_doAssign -> .)
    VAR             reduce using rule 135 (np_doAssign -> .)
    WHILE           reduce using rule 135 (np_doAssign -> .)
    FROM            reduce using rule 135 (np_doAssign -> .)
    R_CURPAR        reduce using rule 135 (np_doAssign -> .)
    SEMICOLON       reduce using rule 135 (np_doAssign -> .)

    np_doAssign                    shift and go to state 288

state 248

    (79) assigmentF -> ope np_addOp exp . np_doAssign empty
    (135) np_doAssign -> .

    ID              reduce using rule 135 (np_doAssign -> .)
    RETURN          reduce using rule 135 (np_doAssign -> .)
    READ            reduce using rule 135 (np_doAssign -> .)
    WRITE           reduce using rule 135 (np_doAssign -> .)
    IF              reduce using rule 135 (np_doAssign -> .)
    VAR             reduce using rule 135 (np_doAssign -> .)
    WHILE           reduce using rule 135 (np_doAssign -> .)
    FROM            reduce using rule 135 (np_doAssign -> .)
    R_CURPAR        reduce using rule 135 (np_doAssign -> .)
    SEMICOLON       reduce using rule 135 (np_doAssign -> .)

    np_doAssign                    shift and go to state 289

state 249

    (51) void -> ID DOT ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 290


state 250

    (109) factor -> L_PAR np_addPar exp . R_PAR np_popPar empty

    R_PAR           shift and go to state 291


state 251

    (52) void -> ID L_PAR param R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 292

state 252

    (53) void -> ID L_PAR R_PAR SEMICOLON empty .

    ID              reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    READ            reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    IF              reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    VAR             reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    FROM            reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)


state 253

    (57) paramF -> COMMA param .

    R_PAR           reduce using rule 57 (paramF -> COMMA param .)


state 254

    (88) bool -> logical np_addBool boolF .

    COMMA           reduce using rule 88 (bool -> logical np_addBool boolF .)
    R_PAR           reduce using rule 88 (bool -> logical np_addBool boolF .)
    R_BREAK         reduce using rule 88 (bool -> logical np_addBool boolF .)
    TO              reduce using rule 88 (bool -> logical np_addBool boolF .)
    ID              reduce using rule 88 (bool -> logical np_addBool boolF .)
    RETURN          reduce using rule 88 (bool -> logical np_addBool boolF .)
    READ            reduce using rule 88 (bool -> logical np_addBool boolF .)
    WRITE           reduce using rule 88 (bool -> logical np_addBool boolF .)
    IF              reduce using rule 88 (bool -> logical np_addBool boolF .)
    VAR             reduce using rule 88 (bool -> logical np_addBool boolF .)
    WHILE           reduce using rule 88 (bool -> logical np_addBool boolF .)
    FROM            reduce using rule 88 (bool -> logical np_addBool boolF .)
    R_CURPAR        reduce using rule 88 (bool -> logical np_addBool boolF .)
    SEMICOLON       reduce using rule 88 (bool -> logical np_addBool boolF .)
    DO              reduce using rule 88 (bool -> logical np_addBool boolF .)


state 255

    (89) boolF -> OR . np_addOp bool
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 293

state 256

    (90) boolF -> AND . np_addOp bool
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 294

state 257

    (91) boolF -> empty .

    COMMA           reduce using rule 91 (boolF -> empty .)
    R_PAR           reduce using rule 91 (boolF -> empty .)
    R_BREAK         reduce using rule 91 (boolF -> empty .)
    TO              reduce using rule 91 (boolF -> empty .)
    ID              reduce using rule 91 (boolF -> empty .)
    RETURN          reduce using rule 91 (boolF -> empty .)
    READ            reduce using rule 91 (boolF -> empty .)
    WRITE           reduce using rule 91 (boolF -> empty .)
    IF              reduce using rule 91 (boolF -> empty .)
    VAR             reduce using rule 91 (boolF -> empty .)
    WHILE           reduce using rule 91 (boolF -> empty .)
    FROM            reduce using rule 91 (boolF -> empty .)
    R_CURPAR        reduce using rule 91 (boolF -> empty .)
    SEMICOLON       reduce using rule 91 (boolF -> empty .)
    DO              reduce using rule 91 (boolF -> empty .)


state 258

    (92) logical -> ex np_addLogical logicalF .

    OR              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    AND             reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    COMMA           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_PAR           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_BREAK         reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    TO              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    ID              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    RETURN          reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    READ            reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    WRITE           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    IF              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    VAR             reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    WHILE           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    FROM            reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_CURPAR        reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    SEMICOLON       reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    DO              reduce using rule 92 (logical -> ex np_addLogical logicalF .)


state 259

    (93) logicalF -> LESS . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 295

state 260

    (94) logicalF -> GREATER . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 296

state 261

    (95) logicalF -> LESS_TH . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 297

state 262

    (96) logicalF -> GREAT_TH . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 298

state 263

    (97) logicalF -> SAME . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 299

state 264

    (98) logicalF -> DIF . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 300

state 265

    (99) logicalF -> empty .

    OR              reduce using rule 99 (logicalF -> empty .)
    AND             reduce using rule 99 (logicalF -> empty .)
    COMMA           reduce using rule 99 (logicalF -> empty .)
    R_PAR           reduce using rule 99 (logicalF -> empty .)
    R_BREAK         reduce using rule 99 (logicalF -> empty .)
    TO              reduce using rule 99 (logicalF -> empty .)
    ID              reduce using rule 99 (logicalF -> empty .)
    RETURN          reduce using rule 99 (logicalF -> empty .)
    READ            reduce using rule 99 (logicalF -> empty .)
    WRITE           reduce using rule 99 (logicalF -> empty .)
    IF              reduce using rule 99 (logicalF -> empty .)
    VAR             reduce using rule 99 (logicalF -> empty .)
    WHILE           reduce using rule 99 (logicalF -> empty .)
    FROM            reduce using rule 99 (logicalF -> empty .)
    R_CURPAR        reduce using rule 99 (logicalF -> empty .)
    SEMICOLON       reduce using rule 99 (logicalF -> empty .)
    DO              reduce using rule 99 (logicalF -> empty .)


state 266

    (101) ex -> term np_addEx exF .

    LESS            reduce using rule 101 (ex -> term np_addEx exF .)
    GREATER         reduce using rule 101 (ex -> term np_addEx exF .)
    LESS_TH         reduce using rule 101 (ex -> term np_addEx exF .)
    GREAT_TH        reduce using rule 101 (ex -> term np_addEx exF .)
    SAME            reduce using rule 101 (ex -> term np_addEx exF .)
    DIF             reduce using rule 101 (ex -> term np_addEx exF .)
    OR              reduce using rule 101 (ex -> term np_addEx exF .)
    AND             reduce using rule 101 (ex -> term np_addEx exF .)
    COMMA           reduce using rule 101 (ex -> term np_addEx exF .)
    R_PAR           reduce using rule 101 (ex -> term np_addEx exF .)
    R_BREAK         reduce using rule 101 (ex -> term np_addEx exF .)
    TO              reduce using rule 101 (ex -> term np_addEx exF .)
    ID              reduce using rule 101 (ex -> term np_addEx exF .)
    RETURN          reduce using rule 101 (ex -> term np_addEx exF .)
    READ            reduce using rule 101 (ex -> term np_addEx exF .)
    WRITE           reduce using rule 101 (ex -> term np_addEx exF .)
    IF              reduce using rule 101 (ex -> term np_addEx exF .)
    VAR             reduce using rule 101 (ex -> term np_addEx exF .)
    WHILE           reduce using rule 101 (ex -> term np_addEx exF .)
    FROM            reduce using rule 101 (ex -> term np_addEx exF .)
    R_CURPAR        reduce using rule 101 (ex -> term np_addEx exF .)
    SEMICOLON       reduce using rule 101 (ex -> term np_addEx exF .)
    DO              reduce using rule 101 (ex -> term np_addEx exF .)


state 267

    (102) exF -> PLUS . np_addOp ex
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 301

state 268

    (103) exF -> MINUS . np_addOp ex
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 302

state 269

    (104) exF -> empty .

    LESS            reduce using rule 104 (exF -> empty .)
    GREATER         reduce using rule 104 (exF -> empty .)
    LESS_TH         reduce using rule 104 (exF -> empty .)
    GREAT_TH        reduce using rule 104 (exF -> empty .)
    SAME            reduce using rule 104 (exF -> empty .)
    DIF             reduce using rule 104 (exF -> empty .)
    OR              reduce using rule 104 (exF -> empty .)
    AND             reduce using rule 104 (exF -> empty .)
    COMMA           reduce using rule 104 (exF -> empty .)
    R_PAR           reduce using rule 104 (exF -> empty .)
    R_BREAK         reduce using rule 104 (exF -> empty .)
    TO              reduce using rule 104 (exF -> empty .)
    ID              reduce using rule 104 (exF -> empty .)
    RETURN          reduce using rule 104 (exF -> empty .)
    READ            reduce using rule 104 (exF -> empty .)
    WRITE           reduce using rule 104 (exF -> empty .)
    IF              reduce using rule 104 (exF -> empty .)
    VAR             reduce using rule 104 (exF -> empty .)
    WHILE           reduce using rule 104 (exF -> empty .)
    FROM            reduce using rule 104 (exF -> empty .)
    R_CURPAR        reduce using rule 104 (exF -> empty .)
    SEMICOLON       reduce using rule 104 (exF -> empty .)
    DO              reduce using rule 104 (exF -> empty .)


state 270

    (105) term -> factor np_addTerm termF .

    PLUS            reduce using rule 105 (term -> factor np_addTerm termF .)
    MINUS           reduce using rule 105 (term -> factor np_addTerm termF .)
    LESS            reduce using rule 105 (term -> factor np_addTerm termF .)
    GREATER         reduce using rule 105 (term -> factor np_addTerm termF .)
    LESS_TH         reduce using rule 105 (term -> factor np_addTerm termF .)
    GREAT_TH        reduce using rule 105 (term -> factor np_addTerm termF .)
    SAME            reduce using rule 105 (term -> factor np_addTerm termF .)
    DIF             reduce using rule 105 (term -> factor np_addTerm termF .)
    OR              reduce using rule 105 (term -> factor np_addTerm termF .)
    AND             reduce using rule 105 (term -> factor np_addTerm termF .)
    COMMA           reduce using rule 105 (term -> factor np_addTerm termF .)
    R_PAR           reduce using rule 105 (term -> factor np_addTerm termF .)
    R_BREAK         reduce using rule 105 (term -> factor np_addTerm termF .)
    TO              reduce using rule 105 (term -> factor np_addTerm termF .)
    ID              reduce using rule 105 (term -> factor np_addTerm termF .)
    RETURN          reduce using rule 105 (term -> factor np_addTerm termF .)
    READ            reduce using rule 105 (term -> factor np_addTerm termF .)
    WRITE           reduce using rule 105 (term -> factor np_addTerm termF .)
    IF              reduce using rule 105 (term -> factor np_addTerm termF .)
    VAR             reduce using rule 105 (term -> factor np_addTerm termF .)
    WHILE           reduce using rule 105 (term -> factor np_addTerm termF .)
    FROM            reduce using rule 105 (term -> factor np_addTerm termF .)
    R_CURPAR        reduce using rule 105 (term -> factor np_addTerm termF .)
    SEMICOLON       reduce using rule 105 (term -> factor np_addTerm termF .)
    DO              reduce using rule 105 (term -> factor np_addTerm termF .)


state 271

    (106) termF -> MULT . np_addOp term
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 303

state 272

    (107) termF -> DIV . np_addOp term
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 304

state 273

    (108) termF -> empty .

    PLUS            reduce using rule 108 (termF -> empty .)
    MINUS           reduce using rule 108 (termF -> empty .)
    LESS            reduce using rule 108 (termF -> empty .)
    GREATER         reduce using rule 108 (termF -> empty .)
    LESS_TH         reduce using rule 108 (termF -> empty .)
    GREAT_TH        reduce using rule 108 (termF -> empty .)
    SAME            reduce using rule 108 (termF -> empty .)
    DIF             reduce using rule 108 (termF -> empty .)
    OR              reduce using rule 108 (termF -> empty .)
    AND             reduce using rule 108 (termF -> empty .)
    COMMA           reduce using rule 108 (termF -> empty .)
    R_PAR           reduce using rule 108 (termF -> empty .)
    R_BREAK         reduce using rule 108 (termF -> empty .)
    TO              reduce using rule 108 (termF -> empty .)
    ID              reduce using rule 108 (termF -> empty .)
    RETURN          reduce using rule 108 (termF -> empty .)
    READ            reduce using rule 108 (termF -> empty .)
    WRITE           reduce using rule 108 (termF -> empty .)
    IF              reduce using rule 108 (termF -> empty .)
    VAR             reduce using rule 108 (termF -> empty .)
    WHILE           reduce using rule 108 (termF -> empty .)
    FROM            reduce using rule 108 (termF -> empty .)
    R_CURPAR        reduce using rule 108 (termF -> empty .)
    SEMICOLON       reduce using rule 108 (termF -> empty .)
    DO              reduce using rule 108 (termF -> empty .)


state 274

    (115) varcte -> var np_addId empty .

    MULT            reduce using rule 115 (varcte -> var np_addId empty .)
    DIV             reduce using rule 115 (varcte -> var np_addId empty .)
    PLUS            reduce using rule 115 (varcte -> var np_addId empty .)
    MINUS           reduce using rule 115 (varcte -> var np_addId empty .)
    LESS            reduce using rule 115 (varcte -> var np_addId empty .)
    GREATER         reduce using rule 115 (varcte -> var np_addId empty .)
    LESS_TH         reduce using rule 115 (varcte -> var np_addId empty .)
    GREAT_TH        reduce using rule 115 (varcte -> var np_addId empty .)
    SAME            reduce using rule 115 (varcte -> var np_addId empty .)
    DIF             reduce using rule 115 (varcte -> var np_addId empty .)
    OR              reduce using rule 115 (varcte -> var np_addId empty .)
    AND             reduce using rule 115 (varcte -> var np_addId empty .)
    COMMA           reduce using rule 115 (varcte -> var np_addId empty .)
    R_PAR           reduce using rule 115 (varcte -> var np_addId empty .)
    R_BREAK         reduce using rule 115 (varcte -> var np_addId empty .)
    TO              reduce using rule 115 (varcte -> var np_addId empty .)
    ID              reduce using rule 115 (varcte -> var np_addId empty .)
    RETURN          reduce using rule 115 (varcte -> var np_addId empty .)
    READ            reduce using rule 115 (varcte -> var np_addId empty .)
    WRITE           reduce using rule 115 (varcte -> var np_addId empty .)
    IF              reduce using rule 115 (varcte -> var np_addId empty .)
    VAR             reduce using rule 115 (varcte -> var np_addId empty .)
    WHILE           reduce using rule 115 (varcte -> var np_addId empty .)
    FROM            reduce using rule 115 (varcte -> var np_addId empty .)
    R_CURPAR        reduce using rule 115 (varcte -> var np_addId empty .)
    SEMICOLON       reduce using rule 115 (varcte -> var np_addId empty .)
    DO              reduce using rule 115 (varcte -> var np_addId empty .)


state 275

    (59) return -> RETURN L_PAR exp R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 305

state 276

    (65) readF -> var np_addRead COMMA . readF
    (65) readF -> . var np_addRead COMMA readF
    (66) readF -> . var np_addRead R_PAR SEMICOLON empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 100
    ID              shift and go to state 156

    var                            shift and go to state 178
    readF                          shift and go to state 306

state 277

    (66) readF -> var np_addRead R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 307


state 278

    (70) writeF -> COMMA writeT .

    ID              reduce using rule 70 (writeF -> COMMA writeT .)
    RETURN          reduce using rule 70 (writeF -> COMMA writeT .)
    READ            reduce using rule 70 (writeF -> COMMA writeT .)
    WRITE           reduce using rule 70 (writeF -> COMMA writeT .)
    IF              reduce using rule 70 (writeF -> COMMA writeT .)
    VAR             reduce using rule 70 (writeF -> COMMA writeT .)
    WHILE           reduce using rule 70 (writeF -> COMMA writeT .)
    FROM            reduce using rule 70 (writeF -> COMMA writeT .)
    R_CURPAR        reduce using rule 70 (writeF -> COMMA writeT .)
    SEMICOLON       reduce using rule 70 (writeF -> COMMA writeT .)


state 279

    (71) writeF -> R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 308

state 280

    (74) if -> IF L_PAR exp R_PAR THEN . L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_CURPAR        shift and go to state 309


state 281

    (54) arrfunc -> L_BREAK exp COMMA exp . R_BREAK empty

    R_BREAK         shift and go to state 310


state 282

    (55) arrfunc -> L_BREAK exp R_BREAK empty .

    EQUAL           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MIN_EQ          reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT_EQ         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV_EQ          reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MINUS           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREATER         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS_TH         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREAT_TH        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SAME            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIF             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    OR              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    AND             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    COMMA           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_PAR           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_BREAK         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    TO              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    ID              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    RETURN          reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    READ            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WRITE           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    IF              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    VAR             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WHILE           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    FROM            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_CURPAR        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SEMICOLON       reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DO              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    L_PAR           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_INT         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_BOOL        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)


state 283

    (84) conditional -> WHILE L_PAR exp R_PAR DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 311


state 284

    (87) nonconditionalF -> exp TO exp . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 312


state 285

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .

    CLASS           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VARS            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    MAIN            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    INT             reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    FLOAT           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    CHAR            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    BOOL            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    ID              reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VOID            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)


state 286

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 313


state 287

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 314

state 288

    (78) assigmentF -> EQUAL np_addOp exp np_doAssign . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 315

state 289

    (79) assigmentF -> ope np_addOp exp np_doAssign . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 316

state 290

    (51) void -> ID DOT ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 317


state 291

    (109) factor -> L_PAR np_addPar exp R_PAR . np_popPar empty
    (130) np_popPar -> .

    MULT            reduce using rule 130 (np_popPar -> .)
    DIV             reduce using rule 130 (np_popPar -> .)
    PLUS            reduce using rule 130 (np_popPar -> .)
    MINUS           reduce using rule 130 (np_popPar -> .)
    LESS            reduce using rule 130 (np_popPar -> .)
    GREATER         reduce using rule 130 (np_popPar -> .)
    LESS_TH         reduce using rule 130 (np_popPar -> .)
    GREAT_TH        reduce using rule 130 (np_popPar -> .)
    SAME            reduce using rule 130 (np_popPar -> .)
    DIF             reduce using rule 130 (np_popPar -> .)
    OR              reduce using rule 130 (np_popPar -> .)
    AND             reduce using rule 130 (np_popPar -> .)
    COMMA           reduce using rule 130 (np_popPar -> .)
    R_PAR           reduce using rule 130 (np_popPar -> .)
    R_BREAK         reduce using rule 130 (np_popPar -> .)
    TO              reduce using rule 130 (np_popPar -> .)
    ID              reduce using rule 130 (np_popPar -> .)
    RETURN          reduce using rule 130 (np_popPar -> .)
    READ            reduce using rule 130 (np_popPar -> .)
    WRITE           reduce using rule 130 (np_popPar -> .)
    IF              reduce using rule 130 (np_popPar -> .)
    VAR             reduce using rule 130 (np_popPar -> .)
    WHILE           reduce using rule 130 (np_popPar -> .)
    FROM            reduce using rule 130 (np_popPar -> .)
    R_CURPAR        reduce using rule 130 (np_popPar -> .)
    SEMICOLON       reduce using rule 130 (np_popPar -> .)
    DO              reduce using rule 130 (np_popPar -> .)

    np_popPar                      shift and go to state 318

state 292

    (52) void -> ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)


state 293

    (89) boolF -> OR np_addOp . bool
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    bool                           shift and go to state 319
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 294

    (90) boolF -> AND np_addOp . bool
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    bool                           shift and go to state 320
    logical                        shift and go to state 162
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 295

    (93) logicalF -> LESS np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    logical                        shift and go to state 321
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 296

    (94) logicalF -> GREATER np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    logical                        shift and go to state 322
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 297

    (95) logicalF -> LESS_TH np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    logical                        shift and go to state 323
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 298

    (96) logicalF -> GREAT_TH np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    logical                        shift and go to state 324
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 299

    (97) logicalF -> SAME np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    logical                        shift and go to state 325
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 300

    (98) logicalF -> DIF np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    logical                        shift and go to state 326
    ex                             shift and go to state 163
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 301

    (102) exF -> PLUS np_addOp . ex
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    ex                             shift and go to state 327
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 302

    (103) exF -> MINUS np_addOp . ex
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    ex                             shift and go to state 328
    term                           shift and go to state 164
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 303

    (106) termF -> MULT np_addOp . term
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    term                           shift and go to state 329
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 304

    (107) termF -> DIV np_addOp . term
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 157
    PLUS            shift and go to state 167
    MINUS           shift and go to state 169
    CTE_INT         shift and go to state 172
    CTE_FLOAT       shift and go to state 173
    CTE_CHAR        shift and go to state 174
    CTE_BOOL        shift and go to state 175
    VAR             shift and go to state 100
    ID              shift and go to state 156

    term                           shift and go to state 330
    factor                         shift and go to state 165
    factorT                        shift and go to state 166
    factorF                        shift and go to state 168
    varcte                         shift and go to state 170
    var                            shift and go to state 171

state 305

    (59) return -> RETURN L_PAR exp R_PAR SEMICOLON empty .

    ID              reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    READ            reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    IF              reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    VAR             reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    FROM            reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)


state 306

    (65) readF -> var np_addRead COMMA readF .

    ID              reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    RETURN          reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    READ            reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    WRITE           reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    IF              reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    VAR             reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    WHILE           reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    FROM            reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    R_CURPAR        reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    SEMICOLON       reduce using rule 65 (readF -> var np_addRead COMMA readF .)


state 307

    (66) readF -> var np_addRead R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 331

state 308

    (71) writeF -> R_PAR SEMICOLON empty .

    ID              reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    READ            reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    IF              reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    VAR             reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    FROM            reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)


state 309

    (74) if -> IF L_PAR exp R_PAR THEN L_CURPAR . statement SEMICOLON R_CURPAR ifF
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 332
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 310

    (54) arrfunc -> L_BREAK exp COMMA exp R_BREAK . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)
    L_PAR           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 333

state 311

    (84) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 334
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 312

    (87) nonconditionalF -> exp TO exp DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 335


state 313

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 336

state 314

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    BOOL            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 315

    (78) assigmentF -> EQUAL np_addOp exp np_doAssign empty .

    ID              reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    RETURN          reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    READ            reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    WRITE           reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    IF              reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    VAR             reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    WHILE           reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    FROM            reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    R_CURPAR        reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    SEMICOLON       reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)


state 316

    (79) assigmentF -> ope np_addOp exp np_doAssign empty .

    ID              reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    RETURN          reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    READ            reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    WRITE           reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    IF              reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    VAR             reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    WHILE           reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    FROM            reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    R_CURPAR        reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    SEMICOLON       reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)


state 317

    (51) void -> ID DOT ID L_PAR param R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 337

state 318

    (109) factor -> L_PAR np_addPar exp R_PAR np_popPar . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 338

state 319

    (89) boolF -> OR np_addOp bool .

    COMMA           reduce using rule 89 (boolF -> OR np_addOp bool .)
    R_PAR           reduce using rule 89 (boolF -> OR np_addOp bool .)
    R_BREAK         reduce using rule 89 (boolF -> OR np_addOp bool .)
    TO              reduce using rule 89 (boolF -> OR np_addOp bool .)
    ID              reduce using rule 89 (boolF -> OR np_addOp bool .)
    RETURN          reduce using rule 89 (boolF -> OR np_addOp bool .)
    READ            reduce using rule 89 (boolF -> OR np_addOp bool .)
    WRITE           reduce using rule 89 (boolF -> OR np_addOp bool .)
    IF              reduce using rule 89 (boolF -> OR np_addOp bool .)
    VAR             reduce using rule 89 (boolF -> OR np_addOp bool .)
    WHILE           reduce using rule 89 (boolF -> OR np_addOp bool .)
    FROM            reduce using rule 89 (boolF -> OR np_addOp bool .)
    R_CURPAR        reduce using rule 89 (boolF -> OR np_addOp bool .)
    SEMICOLON       reduce using rule 89 (boolF -> OR np_addOp bool .)
    DO              reduce using rule 89 (boolF -> OR np_addOp bool .)


state 320

    (90) boolF -> AND np_addOp bool .

    COMMA           reduce using rule 90 (boolF -> AND np_addOp bool .)
    R_PAR           reduce using rule 90 (boolF -> AND np_addOp bool .)
    R_BREAK         reduce using rule 90 (boolF -> AND np_addOp bool .)
    TO              reduce using rule 90 (boolF -> AND np_addOp bool .)
    ID              reduce using rule 90 (boolF -> AND np_addOp bool .)
    RETURN          reduce using rule 90 (boolF -> AND np_addOp bool .)
    READ            reduce using rule 90 (boolF -> AND np_addOp bool .)
    WRITE           reduce using rule 90 (boolF -> AND np_addOp bool .)
    IF              reduce using rule 90 (boolF -> AND np_addOp bool .)
    VAR             reduce using rule 90 (boolF -> AND np_addOp bool .)
    WHILE           reduce using rule 90 (boolF -> AND np_addOp bool .)
    FROM            reduce using rule 90 (boolF -> AND np_addOp bool .)
    R_CURPAR        reduce using rule 90 (boolF -> AND np_addOp bool .)
    SEMICOLON       reduce using rule 90 (boolF -> AND np_addOp bool .)
    DO              reduce using rule 90 (boolF -> AND np_addOp bool .)


state 321

    (93) logicalF -> LESS np_addOp logical .

    OR              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    AND             reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    COMMA           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_PAR           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_BREAK         reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    TO              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    ID              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    RETURN          reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    READ            reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    WRITE           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    IF              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    VAR             reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    WHILE           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    FROM            reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_CURPAR        reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    SEMICOLON       reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    DO              reduce using rule 93 (logicalF -> LESS np_addOp logical .)


state 322

    (94) logicalF -> GREATER np_addOp logical .

    OR              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    AND             reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    COMMA           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_PAR           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_BREAK         reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    TO              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    ID              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    RETURN          reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    READ            reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    WRITE           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    IF              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    VAR             reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    WHILE           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    FROM            reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_CURPAR        reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    SEMICOLON       reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    DO              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)


state 323

    (95) logicalF -> LESS_TH np_addOp logical .

    OR              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    AND             reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    COMMA           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_PAR           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_BREAK         reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    TO              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    ID              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    RETURN          reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    READ            reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    WRITE           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    IF              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    VAR             reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    WHILE           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    FROM            reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_CURPAR        reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    SEMICOLON       reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    DO              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)


state 324

    (96) logicalF -> GREAT_TH np_addOp logical .

    OR              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    AND             reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    COMMA           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_PAR           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_BREAK         reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    TO              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    ID              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    RETURN          reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    READ            reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    WRITE           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    IF              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    VAR             reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    WHILE           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    FROM            reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_CURPAR        reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    SEMICOLON       reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    DO              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)


state 325

    (97) logicalF -> SAME np_addOp logical .

    OR              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    AND             reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    COMMA           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_PAR           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_BREAK         reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    TO              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    ID              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    RETURN          reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    READ            reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    WRITE           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    IF              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    VAR             reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    WHILE           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    FROM            reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_CURPAR        reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    SEMICOLON       reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    DO              reduce using rule 97 (logicalF -> SAME np_addOp logical .)


state 326

    (98) logicalF -> DIF np_addOp logical .

    OR              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    AND             reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    COMMA           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_PAR           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_BREAK         reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    TO              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    ID              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    RETURN          reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    READ            reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    WRITE           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    IF              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    VAR             reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    WHILE           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    FROM            reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_CURPAR        reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    SEMICOLON       reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    DO              reduce using rule 98 (logicalF -> DIF np_addOp logical .)


state 327

    (102) exF -> PLUS np_addOp ex .

    LESS            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    GREATER         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    LESS_TH         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    GREAT_TH        reduce using rule 102 (exF -> PLUS np_addOp ex .)
    SAME            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    DIF             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    OR              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    AND             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    COMMA           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_PAR           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_BREAK         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    TO              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    ID              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    RETURN          reduce using rule 102 (exF -> PLUS np_addOp ex .)
    READ            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    WRITE           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    IF              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    VAR             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    WHILE           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    FROM            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_CURPAR        reduce using rule 102 (exF -> PLUS np_addOp ex .)
    SEMICOLON       reduce using rule 102 (exF -> PLUS np_addOp ex .)
    DO              reduce using rule 102 (exF -> PLUS np_addOp ex .)


state 328

    (103) exF -> MINUS np_addOp ex .

    LESS            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    GREATER         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    LESS_TH         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    GREAT_TH        reduce using rule 103 (exF -> MINUS np_addOp ex .)
    SAME            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    DIF             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    OR              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    AND             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    COMMA           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_PAR           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_BREAK         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    TO              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    ID              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    RETURN          reduce using rule 103 (exF -> MINUS np_addOp ex .)
    READ            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    WRITE           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    IF              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    VAR             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    WHILE           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    FROM            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_CURPAR        reduce using rule 103 (exF -> MINUS np_addOp ex .)
    SEMICOLON       reduce using rule 103 (exF -> MINUS np_addOp ex .)
    DO              reduce using rule 103 (exF -> MINUS np_addOp ex .)


state 329

    (106) termF -> MULT np_addOp term .

    PLUS            reduce using rule 106 (termF -> MULT np_addOp term .)
    MINUS           reduce using rule 106 (termF -> MULT np_addOp term .)
    LESS            reduce using rule 106 (termF -> MULT np_addOp term .)
    GREATER         reduce using rule 106 (termF -> MULT np_addOp term .)
    LESS_TH         reduce using rule 106 (termF -> MULT np_addOp term .)
    GREAT_TH        reduce using rule 106 (termF -> MULT np_addOp term .)
    SAME            reduce using rule 106 (termF -> MULT np_addOp term .)
    DIF             reduce using rule 106 (termF -> MULT np_addOp term .)
    OR              reduce using rule 106 (termF -> MULT np_addOp term .)
    AND             reduce using rule 106 (termF -> MULT np_addOp term .)
    COMMA           reduce using rule 106 (termF -> MULT np_addOp term .)
    R_PAR           reduce using rule 106 (termF -> MULT np_addOp term .)
    R_BREAK         reduce using rule 106 (termF -> MULT np_addOp term .)
    TO              reduce using rule 106 (termF -> MULT np_addOp term .)
    ID              reduce using rule 106 (termF -> MULT np_addOp term .)
    RETURN          reduce using rule 106 (termF -> MULT np_addOp term .)
    READ            reduce using rule 106 (termF -> MULT np_addOp term .)
    WRITE           reduce using rule 106 (termF -> MULT np_addOp term .)
    IF              reduce using rule 106 (termF -> MULT np_addOp term .)
    VAR             reduce using rule 106 (termF -> MULT np_addOp term .)
    WHILE           reduce using rule 106 (termF -> MULT np_addOp term .)
    FROM            reduce using rule 106 (termF -> MULT np_addOp term .)
    R_CURPAR        reduce using rule 106 (termF -> MULT np_addOp term .)
    SEMICOLON       reduce using rule 106 (termF -> MULT np_addOp term .)
    DO              reduce using rule 106 (termF -> MULT np_addOp term .)


state 330

    (107) termF -> DIV np_addOp term .

    PLUS            reduce using rule 107 (termF -> DIV np_addOp term .)
    MINUS           reduce using rule 107 (termF -> DIV np_addOp term .)
    LESS            reduce using rule 107 (termF -> DIV np_addOp term .)
    GREATER         reduce using rule 107 (termF -> DIV np_addOp term .)
    LESS_TH         reduce using rule 107 (termF -> DIV np_addOp term .)
    GREAT_TH        reduce using rule 107 (termF -> DIV np_addOp term .)
    SAME            reduce using rule 107 (termF -> DIV np_addOp term .)
    DIF             reduce using rule 107 (termF -> DIV np_addOp term .)
    OR              reduce using rule 107 (termF -> DIV np_addOp term .)
    AND             reduce using rule 107 (termF -> DIV np_addOp term .)
    COMMA           reduce using rule 107 (termF -> DIV np_addOp term .)
    R_PAR           reduce using rule 107 (termF -> DIV np_addOp term .)
    R_BREAK         reduce using rule 107 (termF -> DIV np_addOp term .)
    TO              reduce using rule 107 (termF -> DIV np_addOp term .)
    ID              reduce using rule 107 (termF -> DIV np_addOp term .)
    RETURN          reduce using rule 107 (termF -> DIV np_addOp term .)
    READ            reduce using rule 107 (termF -> DIV np_addOp term .)
    WRITE           reduce using rule 107 (termF -> DIV np_addOp term .)
    IF              reduce using rule 107 (termF -> DIV np_addOp term .)
    VAR             reduce using rule 107 (termF -> DIV np_addOp term .)
    WHILE           reduce using rule 107 (termF -> DIV np_addOp term .)
    FROM            reduce using rule 107 (termF -> DIV np_addOp term .)
    R_CURPAR        reduce using rule 107 (termF -> DIV np_addOp term .)
    SEMICOLON       reduce using rule 107 (termF -> DIV np_addOp term .)
    DO              reduce using rule 107 (termF -> DIV np_addOp term .)


state 331

    (66) readF -> var np_addRead R_PAR SEMICOLON empty .

    ID              reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    READ            reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    IF              reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    VAR             reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    FROM            reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)


state 332

    (74) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement . SEMICOLON R_CURPAR ifF

    SEMICOLON       shift and go to state 339


state 333

    (54) arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .

    EQUAL           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MIN_EQ          reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT_EQ         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV_EQ          reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MINUS           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREATER         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS_TH         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREAT_TH        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SAME            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIF             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    OR              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    AND             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    COMMA           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_PAR           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_BREAK         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    TO              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    ID              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    RETURN          reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    READ            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WRITE           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    IF              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    VAR             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WHILE           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    FROM            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_CURPAR        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SEMICOLON       reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DO              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    L_PAR           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_INT         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_BOOL        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)


state 334

    (84) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 340


state 335

    (87) nonconditionalF -> exp TO exp DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 341
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 336

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    BOOL            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 337

    (51) void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)


state 338

    (109) factor -> L_PAR np_addPar exp R_PAR np_popPar empty .

    MULT            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIV             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    PLUS            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    MINUS           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREATER         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS_TH         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREAT_TH        reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SAME            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIF             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    OR              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    AND             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    COMMA           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_PAR           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_BREAK         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    TO              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    ID              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    RETURN          reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    READ            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    WRITE           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    IF              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    VAR             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    WHILE           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    FROM            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_CURPAR        reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SEMICOLON       reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DO              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)


state 339

    (74) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON . R_CURPAR ifF

    R_CURPAR        shift and go to state 342


state 340

    (84) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 343


state 341

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 344


state 342

    (74) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR . ifF
    (75) ifF -> . ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
    (76) ifF -> . empty
    (120) empty -> .

    ELSE            shift and go to state 346
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    ifF                            shift and go to state 345
    empty                          shift and go to state 347

state 343

    (84) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 348

state 344

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 349


state 345

    (74) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .

    ID              reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    RETURN          reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    READ            reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WRITE           reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    IF              reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    VAR             reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WHILE           reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    FROM            reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    R_CURPAR        reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    SEMICOLON       reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)


state 346

    (75) ifF -> ELSE . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 350


state 347

    (76) ifF -> empty .

    ID              reduce using rule 76 (ifF -> empty .)
    RETURN          reduce using rule 76 (ifF -> empty .)
    READ            reduce using rule 76 (ifF -> empty .)
    WRITE           reduce using rule 76 (ifF -> empty .)
    IF              reduce using rule 76 (ifF -> empty .)
    VAR             reduce using rule 76 (ifF -> empty .)
    WHILE           reduce using rule 76 (ifF -> empty .)
    FROM            reduce using rule 76 (ifF -> empty .)
    R_CURPAR        reduce using rule 76 (ifF -> empty .)
    SEMICOLON       reduce using rule 76 (ifF -> empty .)


state 348

    (84) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 349

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 351

state 350

    (75) ifF -> ELSE L_CURPAR . statement SEMICOLON R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 352
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 351

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 352

    (75) ifF -> ELSE L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 353


state 353

    (75) ifF -> ELSE L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 354


state 354

    (75) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 355

state 355

    (75) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)

