Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM np_startProg ID np_addFunc SEMICOLON programT
Rule 2     programT -> class programT
Rule 3     programT -> vars programF
Rule 4     programT -> programF
Rule 5     programF -> func programF
Rule 6     programF -> main empty
Rule 7     class -> CLASS ID classT
Rule 8     classT -> LESS INHERIT ID GREATER classF
Rule 9     classT -> classF
Rule 10    classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty
Rule 11    vars -> VARS dec empty
Rule 12    dec -> VAR arr np_getDecArr decF
Rule 13    dec -> VAR np_getDec decF
Rule 14    decF -> COMMA dec
Rule 15    decF -> COLON type np_getVarType SEMICOLON np_getDec dec
Rule 16    decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty
Rule 17    type -> INT empty
Rule 18    type -> FLOAT empty
Rule 19    type -> CHAR empty
Rule 20    type -> BOOL empty
Rule 21    type -> ID empty
Rule 22    arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
Rule 23    arr -> L_BREAK CTE_INT R_BREAK empty
Rule 24    func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF
Rule 25    funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty
Rule 26    funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty
Rule 27    typeFunc -> INT empty
Rule 28    typeFunc -> FLOAT empty
Rule 29    typeFunc -> CHAR empty
Rule 30    typeFunc -> BOOL empty
Rule 31    typeFunc -> ID empty
Rule 32    typeFunc -> VOID empty
Rule 33    parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec parameterF
Rule 34    parameterF -> parameter
Rule 35    parameterF -> empty
Rule 36    typepar -> INT empty
Rule 37    typepar -> FLOAT empty
Rule 38    typepar -> CHAR empty
Rule 39    typepar -> BOOL empty
Rule 40    typepar -> ID empty
Rule 41    main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
Rule 42    statement -> assigment SEMICOLON statementF
Rule 43    statement -> void SEMICOLON statementF
Rule 44    statement -> return SEMICOLON statementF
Rule 45    statement -> read SEMICOLON statementF
Rule 46    statement -> write SEMICOLON statementF
Rule 47    statement -> if statementF
Rule 48    statement -> repeat statementF
Rule 49    statementF -> statement
Rule 50    statementF -> empty
Rule 51    void -> ID DOT ID L_PAR voidT
Rule 52    void -> ID np_checkVoid L_PAR np_eraQuad voidT
Rule 53    voidT -> exp np_checkParam COMMA voidT
Rule 54    voidT -> exp np_checkParam voidF
Rule 55    voidT -> voidF
Rule 56    voidF -> R_PAR np_endVoid empty
Rule 57    arrfunc -> L_BREAK exp COMMA exp R_BREAK empty
Rule 58    arrfunc -> L_BREAK exp R_BREAK empty
Rule 59    return -> RETURN L_PAR exp np_addReturn R_PAR empty
Rule 60    var -> VAR varF
Rule 61    var -> ID DOT VAR varF
Rule 62    varF -> arrfunc empty
Rule 63    varF -> empty
Rule 64    read -> READ L_PAR readF
Rule 65    readF -> var np_addRead COMMA readF
Rule 66    readF -> var np_addRead R_PAR empty
Rule 67    write -> WRITE L_PAR writeT
Rule 68    writeT -> CTE_STRING np_addConstString writeF
Rule 69    writeT -> exp writeF
Rule 70    writeF -> COMMA np_addWrite writeT
Rule 71    writeF -> R_PAR np_addWrite empty
Rule 72    repeat -> conditional empty
Rule 73    repeat -> nonconditional empty
Rule 74    if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
Rule 75    ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty
Rule 76    ifF -> np_endIf empty
Rule 77    assigment -> var np_addId assigmentF
Rule 78    assigmentF -> EQUAL np_addOp exp np_doAssign empty
Rule 79    assigmentF -> ope np_addOp exp np_doAssign empty
Rule 80    ope -> PLUS_EQ empty
Rule 81    ope -> MIN_EQ empty
Rule 82    ope -> MULT_EQ empty
Rule 83    ope -> DIV_EQ empty
Rule 84    conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
Rule 85    nonconditional -> FROM VAR arrfunc nonconditionalF
Rule 86    nonconditional -> FROM VAR np_addId nonconditionalF
Rule 87    nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
Rule 88    bool -> logical np_addBool boolF
Rule 89    boolF -> OR np_addOp bool
Rule 90    boolF -> AND np_addOp bool
Rule 91    boolF -> empty
Rule 92    logical -> ex np_addLogical logicalF
Rule 93    logicalF -> LESS np_addOp logical
Rule 94    logicalF -> GREATER np_addOp logical
Rule 95    logicalF -> LESS_TH np_addOp logical
Rule 96    logicalF -> GREAT_TH np_addOp logical
Rule 97    logicalF -> SAME np_addOp logical
Rule 98    logicalF -> DIF np_addOp logical
Rule 99    logicalF -> empty
Rule 100   exp -> bool empty
Rule 101   ex -> term np_addEx exF
Rule 102   exF -> PLUS np_addOp ex
Rule 103   exF -> MINUS np_addOp ex
Rule 104   exF -> empty
Rule 105   term -> factor np_addTerm termF
Rule 106   termF -> MULT np_addOp term
Rule 107   termF -> DIV np_addOp term
Rule 108   termF -> empty
Rule 109   factor -> L_PAR np_addPar exp R_PAR np_popPar empty
Rule 110   factor -> factorT
Rule 111   factorT -> PLUS factorF
Rule 112   factorT -> MINUS factorF
Rule 113   factorT -> factorF
Rule 114   factorF -> varcte empty
Rule 115   varcte -> var np_addId empty
Rule 116   varcte -> CTE_INT np_addConstInt empty
Rule 117   varcte -> CTE_FLOAT np_addConstFloat empty
Rule 118   varcte -> CTE_CHAR np_addConstChar empty
Rule 119   varcte -> CTE_BOOL np_addConstBool empty
Rule 120   empty -> <empty>
Rule 121   np_startProg -> <empty>
Rule 122   np_getMainFunc -> <empty>
Rule 123   np_addFunc -> <empty>
Rule 124   np_getDec -> <empty>
Rule 125   np_getDecArr -> <empty>
Rule 126   np_getVarType -> <empty>
Rule 127   np_addParam -> <empty>
Rule 128   np_addToDic -> <empty>
Rule 129   np_endFunc -> <empty>
Rule 130   np_addId -> <empty>
Rule 131   np_addConstInt -> <empty>
Rule 132   np_addConstFloat -> <empty>
Rule 133   np_addConstChar -> <empty>
Rule 134   np_addConstBool -> <empty>
Rule 135   np_addConstString -> <empty>
Rule 136   np_addOp -> <empty>
Rule 137   np_addPar -> <empty>
Rule 138   np_popPar -> <empty>
Rule 139   np_addTerm -> <empty>
Rule 140   np_addEx -> <empty>
Rule 141   np_addLogical -> <empty>
Rule 142   np_addBool -> <empty>
Rule 143   np_doAssign -> <empty>
Rule 144   np_addRead -> <empty>
Rule 145   np_addWrite -> <empty>
Rule 146   np_addReturn -> <empty>
Rule 147   np_checkBool -> <empty>
Rule 148   np_endIf -> <empty>
Rule 149   np_else -> <empty>
Rule 150   np_addWhile -> <empty>
Rule 151   np_endWhile -> <empty>
Rule 152   np_assingFor -> <empty>
Rule 153   np_checkExp -> <empty>
Rule 154   np_endFor -> <empty>
Rule 155   np_checkVoid -> <empty>
Rule 156   np_eraQuad -> <empty>
Rule 157   np_checkParam -> <empty>
Rule 158   np_endVoid -> <empty>

Terminals, with rules where they appear

AND                  : 90
ATTRIBUTES           : 10
BOOL                 : 20 30 39
CHAR                 : 19 29 38
CLASS                : 7
COLON                : 15 16 33
COMMA                : 14 22 53 57 65 70
CTE_BOOL             : 119
CTE_CHAR             : 118
CTE_FLOAT            : 117
CTE_INT              : 22 22 23 116
CTE_STRING           : 68
DIF                  : 98
DIV                  : 107
DIV_EQ               : 83
DO                   : 84 87
DOT                  : 51 61
ELSE                 : 75
EQUAL                : 78 87
FLOAT                : 18 28 37
FROM                 : 85 86
FUNCTION             : 24
GREATER              : 8 94
GREAT_TH             : 96
ID                   : 1 7 8 21 24 31 40 51 51 52 61
IF                   : 74
INHERIT              : 8
INT                  : 17 27 36
LESS                 : 8 93
LESS_TH              : 95
L_BREAK              : 22 23 57 58
L_CURPAR             : 10 25 26 41 74 75 84 87
L_PAR                : 24 41 51 52 59 64 67 74 84 109
MAIN                 : 41
METHODS              : 10
MINUS                : 103 112
MIN_EQ               : 81
MULT                 : 106
MULT_EQ              : 82
OR                   : 89
PLUS                 : 102 111
PLUS_EQ              : 80
PROGRAM              : 1
READ                 : 64
RETURN               : 59
R_BREAK              : 22 23 57 58
R_CURPAR             : 10 25 26 41 74 75 84 87
R_PAR                : 25 26 41 56 59 66 71 74 84 109
SAME                 : 97
SEMICOLON            : 1 10 10 15 16 25 26 33 42 43 44 45 46
THEN                 : 74
TO                   : 87
VAR                  : 12 13 33 60 61 85 86
VARS                 : 11
VOID                 : 32
WHILE                : 84
WRITE                : 67
error                : 

Nonterminals, with rules where they appear

arr                  : 12
arrfunc              : 62 85
assigment            : 42
assigmentF           : 77
bool                 : 89 90 100
boolF                : 88
class                : 2
classF               : 8 9
classT               : 7
conditional          : 72
dec                  : 10 11 14 15 25 26
decF                 : 12 13
empty                : 6 10 11 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 35 36 37 38 39 40 41 50 56 57 58 59 62 63 66 71 72 73 75 76 78 79 80 81 82 83 84 87 91 99 100 104 108 109 114 115 116 117 118 119
ex                   : 92 102 103
exF                  : 101
exp                  : 53 54 57 57 58 59 69 74 78 79 84 87 87 109
factor               : 105
factorF              : 111 112 113
factorT              : 110
func                 : 5 10
funcF                : 24
if                   : 47
ifF                  : 74
logical              : 88 93 94 95 96 97 98
logicalF             : 92
main                 : 6
nonconditional       : 73
nonconditionalF      : 85 86
np_addBool           : 88
np_addConstBool      : 119
np_addConstChar      : 118
np_addConstFloat     : 117
np_addConstInt       : 116
np_addConstString    : 68
np_addEx             : 101
np_addFunc           : 1 24
np_addId             : 77 86 115
np_addLogical        : 92
np_addOp             : 78 79 87 89 90 93 94 95 96 97 98 102 103 106 107
np_addPar            : 109
np_addParam          : 33
np_addRead           : 65 66
np_addReturn         : 59
np_addTerm           : 105
np_addToDic          : 16
np_addWhile          : 84
np_addWrite          : 70 71
np_assingFor         : 87
np_checkBool         : 74 84
np_checkExp          : 87
np_checkParam        : 53 54
np_checkVoid         : 52
np_doAssign          : 78 79
np_else              : 75
np_endFor            : 87
np_endFunc           : 25 26
np_endIf             : 75 76
np_endVoid           : 56
np_endWhile          : 84
np_eraQuad           : 52
np_getDec            : 13 15 16 33 33
np_getDecArr         : 12
np_getMainFunc       : 41
np_getVarType        : 15 16 33
np_popPar            : 109
np_startProg         : 1
ope                  : 79
parameter            : 25 34
parameterF           : 33
program              : 0
programF             : 3 4 5
programT             : 1 2
read                 : 45
readF                : 64 65
repeat               : 48
return               : 44
statement            : 25 26 41 49 74 75 84 87
statementF           : 42 43 44 45 46 47 48
term                 : 101 106 107
termF                : 105
type                 : 15 16
typeFunc             : 24
typepar              : 33
var                  : 65 66 77 115
varF                 : 60 61
varcte               : 114
vars                 : 3
void                 : 43
voidF                : 54 55
voidT                : 51 52 53
write                : 46
writeF               : 68 69
writeT               : 67 70

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM np_startProg ID np_addFunc SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . np_startProg ID np_addFunc SEMICOLON programT
    (121) np_startProg -> .

    ID              reduce using rule 121 (np_startProg -> .)

    np_startProg                   shift and go to state 3

state 3

    (1) program -> PROGRAM np_startProg . ID np_addFunc SEMICOLON programT

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM np_startProg ID . np_addFunc SEMICOLON programT
    (123) np_addFunc -> .

    SEMICOLON       reduce using rule 123 (np_addFunc -> .)

    np_addFunc                     shift and go to state 5

state 5

    (1) program -> PROGRAM np_startProg ID np_addFunc . SEMICOLON programT

    SEMICOLON       shift and go to state 6


state 6

    (1) program -> PROGRAM np_startProg ID np_addFunc SEMICOLON . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 12
    VARS            shift and go to state 13
    MAIN            shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21
    ID              shift and go to state 7
    VOID            shift and go to state 22

    programT                       shift and go to state 8
    class                          shift and go to state 9
    vars                           shift and go to state 10
    programF                       shift and go to state 11
    func                           shift and go to state 14
    main                           shift and go to state 15
    typeFunc                       shift and go to state 16

state 7

    (31) typeFunc -> ID . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 23

state 8

    (1) program -> PROGRAM np_startProg ID np_addFunc SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM np_startProg ID np_addFunc SEMICOLON programT .)


state 9

    (2) programT -> class . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 12
    VARS            shift and go to state 13
    MAIN            shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21
    ID              shift and go to state 7
    VOID            shift and go to state 22

    class                          shift and go to state 9
    programT                       shift and go to state 24
    vars                           shift and go to state 10
    programF                       shift and go to state 11
    func                           shift and go to state 14
    main                           shift and go to state 15
    typeFunc                       shift and go to state 16

state 10

    (3) programT -> vars . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21
    ID              shift and go to state 7
    VOID            shift and go to state 22

    programF                       shift and go to state 25
    func                           shift and go to state 14
    main                           shift and go to state 15
    typeFunc                       shift and go to state 16

state 11

    (4) programT -> programF .

    $end            reduce using rule 4 (programT -> programF .)


state 12

    (7) class -> CLASS . ID classT

    ID              shift and go to state 26


state 13

    (11) vars -> VARS . dec empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 28

    dec                            shift and go to state 27

state 14

    (5) programF -> func . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21
    ID              shift and go to state 7
    VOID            shift and go to state 22

    func                           shift and go to state 14
    programF                       shift and go to state 29
    main                           shift and go to state 15
    typeFunc                       shift and go to state 16

state 15

    (6) programF -> main . empty
    (120) empty -> .

    $end            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 30

state 16

    (24) func -> typeFunc . FUNCTION ID np_addFunc L_PAR funcF

    FUNCTION        shift and go to state 31


state 17

    (41) main -> MAIN . np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (122) np_getMainFunc -> .

    L_PAR           reduce using rule 122 (np_getMainFunc -> .)

    np_getMainFunc                 shift and go to state 32

state 18

    (27) typeFunc -> INT . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 33

state 19

    (28) typeFunc -> FLOAT . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 34

state 20

    (29) typeFunc -> CHAR . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 35

state 21

    (30) typeFunc -> BOOL . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 36

state 22

    (32) typeFunc -> VOID . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 37

state 23

    (31) typeFunc -> ID empty .

    FUNCTION        reduce using rule 31 (typeFunc -> ID empty .)


state 24

    (2) programT -> class programT .

    $end            reduce using rule 2 (programT -> class programT .)


state 25

    (3) programT -> vars programF .

    $end            reduce using rule 3 (programT -> vars programF .)


state 26

    (7) class -> CLASS ID . classT
    (8) classT -> . LESS INHERIT ID GREATER classF
    (9) classT -> . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    LESS            shift and go to state 39
    SEMICOLON       shift and go to state 41

    classT                         shift and go to state 38
    classF                         shift and go to state 40

state 27

    (11) vars -> VARS dec . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 42

state 28

    (12) dec -> VAR . arr np_getDecArr decF
    (13) dec -> VAR . np_getDec decF
    (22) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> . L_BREAK CTE_INT R_BREAK empty
    (124) np_getDec -> .

    L_BREAK         shift and go to state 45
    COMMA           reduce using rule 124 (np_getDec -> .)
    COLON           reduce using rule 124 (np_getDec -> .)

    arr                            shift and go to state 43
    np_getDec                      shift and go to state 44

state 29

    (5) programF -> func programF .

    $end            reduce using rule 5 (programF -> func programF .)


state 30

    (6) programF -> main empty .

    $end            reduce using rule 6 (programF -> main empty .)


state 31

    (24) func -> typeFunc FUNCTION . ID np_addFunc L_PAR funcF

    ID              shift and go to state 46


state 32

    (41) main -> MAIN np_getMainFunc . L_PAR R_PAR L_CURPAR statement R_CURPAR empty

    L_PAR           shift and go to state 47


state 33

    (27) typeFunc -> INT empty .

    FUNCTION        reduce using rule 27 (typeFunc -> INT empty .)


state 34

    (28) typeFunc -> FLOAT empty .

    FUNCTION        reduce using rule 28 (typeFunc -> FLOAT empty .)


state 35

    (29) typeFunc -> CHAR empty .

    FUNCTION        reduce using rule 29 (typeFunc -> CHAR empty .)


state 36

    (30) typeFunc -> BOOL empty .

    FUNCTION        reduce using rule 30 (typeFunc -> BOOL empty .)


state 37

    (32) typeFunc -> VOID empty .

    FUNCTION        reduce using rule 32 (typeFunc -> VOID empty .)


state 38

    (7) class -> CLASS ID classT .

    CLASS           reduce using rule 7 (class -> CLASS ID classT .)
    VARS            reduce using rule 7 (class -> CLASS ID classT .)
    MAIN            reduce using rule 7 (class -> CLASS ID classT .)
    INT             reduce using rule 7 (class -> CLASS ID classT .)
    FLOAT           reduce using rule 7 (class -> CLASS ID classT .)
    CHAR            reduce using rule 7 (class -> CLASS ID classT .)
    BOOL            reduce using rule 7 (class -> CLASS ID classT .)
    ID              reduce using rule 7 (class -> CLASS ID classT .)
    VOID            reduce using rule 7 (class -> CLASS ID classT .)


state 39

    (8) classT -> LESS . INHERIT ID GREATER classF

    INHERIT         shift and go to state 48


state 40

    (9) classT -> classF .

    CLASS           reduce using rule 9 (classT -> classF .)
    VARS            reduce using rule 9 (classT -> classF .)
    MAIN            reduce using rule 9 (classT -> classF .)
    INT             reduce using rule 9 (classT -> classF .)
    FLOAT           reduce using rule 9 (classT -> classF .)
    CHAR            reduce using rule 9 (classT -> classF .)
    BOOL            reduce using rule 9 (classT -> classF .)
    ID              reduce using rule 9 (classT -> classF .)
    VOID            reduce using rule 9 (classT -> classF .)


state 41

    (10) classF -> SEMICOLON . L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    L_CURPAR        shift and go to state 49


state 42

    (11) vars -> VARS dec empty .

    MAIN            reduce using rule 11 (vars -> VARS dec empty .)
    INT             reduce using rule 11 (vars -> VARS dec empty .)
    FLOAT           reduce using rule 11 (vars -> VARS dec empty .)
    CHAR            reduce using rule 11 (vars -> VARS dec empty .)
    BOOL            reduce using rule 11 (vars -> VARS dec empty .)
    ID              reduce using rule 11 (vars -> VARS dec empty .)
    VOID            reduce using rule 11 (vars -> VARS dec empty .)


state 43

    (12) dec -> VAR arr . np_getDecArr decF
    (125) np_getDecArr -> .

    COMMA           reduce using rule 125 (np_getDecArr -> .)
    COLON           reduce using rule 125 (np_getDecArr -> .)

    np_getDecArr                   shift and go to state 50

state 44

    (13) dec -> VAR np_getDec . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 52
    COLON           shift and go to state 53

    decF                           shift and go to state 51

state 45

    (22) arr -> L_BREAK . CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 54


state 46

    (24) func -> typeFunc FUNCTION ID . np_addFunc L_PAR funcF
    (123) np_addFunc -> .

    L_PAR           reduce using rule 123 (np_addFunc -> .)

    np_addFunc                     shift and go to state 55

state 47

    (41) main -> MAIN np_getMainFunc L_PAR . R_PAR L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 56


state 48

    (8) classT -> LESS INHERIT . ID GREATER classF

    ID              shift and go to state 57


state 49

    (10) classF -> SEMICOLON L_CURPAR . ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    ATTRIBUTES      shift and go to state 58


state 50

    (12) dec -> VAR arr np_getDecArr . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 52
    COLON           shift and go to state 53

    decF                           shift and go to state 59

state 51

    (13) dec -> VAR np_getDec decF .

    MAIN            reduce using rule 13 (dec -> VAR np_getDec decF .)
    INT             reduce using rule 13 (dec -> VAR np_getDec decF .)
    FLOAT           reduce using rule 13 (dec -> VAR np_getDec decF .)
    CHAR            reduce using rule 13 (dec -> VAR np_getDec decF .)
    BOOL            reduce using rule 13 (dec -> VAR np_getDec decF .)
    ID              reduce using rule 13 (dec -> VAR np_getDec decF .)
    VOID            reduce using rule 13 (dec -> VAR np_getDec decF .)
    METHODS         reduce using rule 13 (dec -> VAR np_getDec decF .)
    L_CURPAR        reduce using rule 13 (dec -> VAR np_getDec decF .)


state 52

    (14) decF -> COMMA . dec
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 28

    dec                            shift and go to state 60

state 53

    (15) decF -> COLON . type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON . type np_getVarType SEMICOLON np_getDec np_addToDic empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . BOOL empty
    (21) type -> . ID empty

    INT             shift and go to state 62
    FLOAT           shift and go to state 63
    CHAR            shift and go to state 64
    BOOL            shift and go to state 65
    ID              shift and go to state 66

    type                           shift and go to state 61

state 54

    (22) arr -> L_BREAK CTE_INT . COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK CTE_INT . R_BREAK empty

    COMMA           shift and go to state 67
    R_BREAK         shift and go to state 68


state 55

    (24) func -> typeFunc FUNCTION ID np_addFunc . L_PAR funcF

    L_PAR           shift and go to state 69


state 56

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 70


state 57

    (8) classT -> LESS INHERIT ID . GREATER classF

    GREATER         shift and go to state 71


state 58

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES . dec METHODS func R_CURPAR SEMICOLON empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 28

    dec                            shift and go to state 72

state 59

    (12) dec -> VAR arr np_getDecArr decF .

    MAIN            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    INT             reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    FLOAT           reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    CHAR            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    BOOL            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    ID              reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    VOID            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    METHODS         reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    L_CURPAR        reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)


state 60

    (14) decF -> COMMA dec .

    MAIN            reduce using rule 14 (decF -> COMMA dec .)
    INT             reduce using rule 14 (decF -> COMMA dec .)
    FLOAT           reduce using rule 14 (decF -> COMMA dec .)
    CHAR            reduce using rule 14 (decF -> COMMA dec .)
    BOOL            reduce using rule 14 (decF -> COMMA dec .)
    ID              reduce using rule 14 (decF -> COMMA dec .)
    VOID            reduce using rule 14 (decF -> COMMA dec .)
    METHODS         reduce using rule 14 (decF -> COMMA dec .)
    L_CURPAR        reduce using rule 14 (decF -> COMMA dec .)


state 61

    (15) decF -> COLON type . np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON type . np_getVarType SEMICOLON np_getDec np_addToDic empty
    (126) np_getVarType -> .

    SEMICOLON       reduce using rule 126 (np_getVarType -> .)

    np_getVarType                  shift and go to state 73

state 62

    (17) type -> INT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 74

state 63

    (18) type -> FLOAT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 75

state 64

    (19) type -> CHAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 76

state 65

    (20) type -> BOOL . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 77

state 66

    (21) type -> ID . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 78

state 67

    (22) arr -> L_BREAK CTE_INT COMMA . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 79


state 68

    (23) arr -> L_BREAK CTE_INT R_BREAK . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    COLON           reduce using rule 120 (empty -> .)

    empty                          shift and go to state 80

state 69

    (24) func -> typeFunc FUNCTION ID np_addFunc L_PAR . funcF
    (25) funcF -> . parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty
    (26) funcF -> . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty
    (33) parameter -> . VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec parameterF

    R_PAR           shift and go to state 83
    VAR             shift and go to state 84

    funcF                          shift and go to state 81
    parameter                      shift and go to state 82

state 70

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    statement                      shift and go to state 85
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 71

    (8) classT -> LESS INHERIT ID GREATER . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    SEMICOLON       shift and go to state 41

    classF                         shift and go to state 104

state 72

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec . METHODS func R_CURPAR SEMICOLON empty

    METHODS         shift and go to state 105


state 73

    (15) decF -> COLON type np_getVarType . SEMICOLON np_getDec dec
    (16) decF -> COLON type np_getVarType . SEMICOLON np_getDec np_addToDic empty

    SEMICOLON       shift and go to state 106


state 74

    (17) type -> INT empty .

    SEMICOLON       reduce using rule 17 (type -> INT empty .)


state 75

    (18) type -> FLOAT empty .

    SEMICOLON       reduce using rule 18 (type -> FLOAT empty .)


state 76

    (19) type -> CHAR empty .

    SEMICOLON       reduce using rule 19 (type -> CHAR empty .)


state 77

    (20) type -> BOOL empty .

    SEMICOLON       reduce using rule 20 (type -> BOOL empty .)


state 78

    (21) type -> ID empty .

    SEMICOLON       reduce using rule 21 (type -> ID empty .)


state 79

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT . R_BREAK empty

    R_BREAK         shift and go to state 107


state 80

    (23) arr -> L_BREAK CTE_INT R_BREAK empty .

    COMMA           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    COLON           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)


state 81

    (24) func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .

    MAIN            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    INT             reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    FLOAT           reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    CHAR            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    BOOL            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    ID              reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    VOID            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    R_CURPAR        reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)


state 82

    (25) funcF -> parameter . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty

    R_PAR           shift and go to state 108


state 83

    (26) funcF -> R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty

    SEMICOLON       shift and go to state 109


state 84

    (33) parameter -> VAR . np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec parameterF
    (124) np_getDec -> .

    COLON           reduce using rule 124 (np_getDec -> .)

    np_getDec                      shift and go to state 110

state 85

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 111


state 86

    (42) statement -> assigment . SEMICOLON statementF

    SEMICOLON       shift and go to state 112


state 87

    (43) statement -> void . SEMICOLON statementF

    SEMICOLON       shift and go to state 113


state 88

    (44) statement -> return . SEMICOLON statementF

    SEMICOLON       shift and go to state 114


state 89

    (45) statement -> read . SEMICOLON statementF

    SEMICOLON       shift and go to state 115


state 90

    (46) statement -> write . SEMICOLON statementF

    SEMICOLON       shift and go to state 116


state 91

    (47) statement -> if . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    if                             shift and go to state 91
    statementF                     shift and go to state 117
    statement                      shift and go to state 118
    empty                          shift and go to state 119
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 92

    (48) statement -> repeat . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    repeat                         shift and go to state 92
    statementF                     shift and go to state 120
    statement                      shift and go to state 118
    empty                          shift and go to state 119
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 93

    (77) assigment -> var . np_addId assigmentF
    (130) np_addId -> .

    EQUAL           reduce using rule 130 (np_addId -> .)
    PLUS_EQ         reduce using rule 130 (np_addId -> .)
    MIN_EQ          reduce using rule 130 (np_addId -> .)
    MULT_EQ         reduce using rule 130 (np_addId -> .)
    DIV_EQ          reduce using rule 130 (np_addId -> .)

    np_addId                       shift and go to state 121

state 94

    (51) void -> ID . DOT ID L_PAR voidT
    (52) void -> ID . np_checkVoid L_PAR np_eraQuad voidT
    (61) var -> ID . DOT VAR varF
    (155) np_checkVoid -> .

    DOT             shift and go to state 122
    L_PAR           reduce using rule 155 (np_checkVoid -> .)

    np_checkVoid                   shift and go to state 123

state 95

    (59) return -> RETURN . L_PAR exp np_addReturn R_PAR empty

    L_PAR           shift and go to state 124


state 96

    (64) read -> READ . L_PAR readF

    L_PAR           shift and go to state 125


state 97

    (67) write -> WRITE . L_PAR writeT

    L_PAR           shift and go to state 126


state 98

    (74) if -> IF . L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF

    L_PAR           shift and go to state 127


state 99

    (72) repeat -> conditional . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 128

state 100

    (73) repeat -> nonconditional . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 129

state 101

    (60) var -> VAR . varF
    (62) varF -> . arrfunc empty
    (63) varF -> . empty
    (57) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (58) arrfunc -> . L_BREAK exp R_BREAK empty
    (120) empty -> .

    L_BREAK         shift and go to state 133
    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    varF                           shift and go to state 130
    arrfunc                        shift and go to state 131
    empty                          shift and go to state 132

state 102

    (84) conditional -> WHILE . np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (150) np_addWhile -> .

    L_PAR           reduce using rule 150 (np_addWhile -> .)

    np_addWhile                    shift and go to state 134

state 103

    (85) nonconditional -> FROM . VAR arrfunc nonconditionalF
    (86) nonconditional -> FROM . VAR np_addId nonconditionalF

    VAR             shift and go to state 135


state 104

    (8) classT -> LESS INHERIT ID GREATER classF .

    CLASS           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VARS            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    MAIN            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    INT             reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    FLOAT           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    CHAR            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    BOOL            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    ID              reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VOID            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)


state 105

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS . func R_CURPAR SEMICOLON empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOL            shift and go to state 21
    ID              shift and go to state 7
    VOID            shift and go to state 22

    func                           shift and go to state 136
    typeFunc                       shift and go to state 16

state 106

    (15) decF -> COLON type np_getVarType SEMICOLON . np_getDec dec
    (16) decF -> COLON type np_getVarType SEMICOLON . np_getDec np_addToDic empty
    (124) np_getDec -> .

    VAR             reduce using rule 124 (np_getDec -> .)
    MAIN            reduce using rule 124 (np_getDec -> .)
    INT             reduce using rule 124 (np_getDec -> .)
    FLOAT           reduce using rule 124 (np_getDec -> .)
    CHAR            reduce using rule 124 (np_getDec -> .)
    BOOL            reduce using rule 124 (np_getDec -> .)
    ID              reduce using rule 124 (np_getDec -> .)
    VOID            reduce using rule 124 (np_getDec -> .)
    METHODS         reduce using rule 124 (np_getDec -> .)
    L_CURPAR        reduce using rule 124 (np_getDec -> .)

    np_getDec                      shift and go to state 137

state 107

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    COLON           reduce using rule 120 (empty -> .)

    empty                          shift and go to state 138

state 108

    (25) funcF -> parameter R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty

    SEMICOLON       shift and go to state 139


state 109

    (26) funcF -> R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR np_endFunc empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 28

    dec                            shift and go to state 140

state 110

    (33) parameter -> VAR np_getDec . COLON typepar np_getVarType np_addParam SEMICOLON np_getDec parameterF

    COLON           shift and go to state 141


state 111

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    $end            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 142

state 112

    (42) statement -> assigment SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    assigment                      shift and go to state 86
    statementF                     shift and go to state 143
    statement                      shift and go to state 118
    empty                          shift and go to state 119
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 113

    (43) statement -> void SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    void                           shift and go to state 87
    statementF                     shift and go to state 144
    statement                      shift and go to state 118
    empty                          shift and go to state 119
    assigment                      shift and go to state 86
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 114

    (44) statement -> return SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    return                         shift and go to state 88
    statementF                     shift and go to state 145
    statement                      shift and go to state 118
    empty                          shift and go to state 119
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 115

    (45) statement -> read SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    read                           shift and go to state 89
    statementF                     shift and go to state 146
    statement                      shift and go to state 118
    empty                          shift and go to state 119
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 116

    (46) statement -> write SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    write                          shift and go to state 90
    statementF                     shift and go to state 147
    statement                      shift and go to state 118
    empty                          shift and go to state 119
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 117

    (47) statement -> if statementF .

    R_CURPAR        reduce using rule 47 (statement -> if statementF .)


state 118

    (49) statementF -> statement .

    R_CURPAR        reduce using rule 49 (statementF -> statement .)


state 119

    (50) statementF -> empty .

    R_CURPAR        reduce using rule 50 (statementF -> empty .)


state 120

    (48) statement -> repeat statementF .

    R_CURPAR        reduce using rule 48 (statement -> repeat statementF .)


state 121

    (77) assigment -> var np_addId . assigmentF
    (78) assigmentF -> . EQUAL np_addOp exp np_doAssign empty
    (79) assigmentF -> . ope np_addOp exp np_doAssign empty
    (80) ope -> . PLUS_EQ empty
    (81) ope -> . MIN_EQ empty
    (82) ope -> . MULT_EQ empty
    (83) ope -> . DIV_EQ empty

    EQUAL           shift and go to state 149
    PLUS_EQ         shift and go to state 151
    MIN_EQ          shift and go to state 152
    MULT_EQ         shift and go to state 153
    DIV_EQ          shift and go to state 154

    assigmentF                     shift and go to state 148
    ope                            shift and go to state 150

state 122

    (51) void -> ID DOT . ID L_PAR voidT
    (61) var -> ID DOT . VAR varF

    ID              shift and go to state 155
    VAR             shift and go to state 156


state 123

    (52) void -> ID np_checkVoid . L_PAR np_eraQuad voidT

    L_PAR           shift and go to state 157


state 124

    (59) return -> RETURN L_PAR . exp np_addReturn R_PAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 159
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 125

    (64) read -> READ L_PAR . readF
    (65) readF -> . var np_addRead COMMA readF
    (66) readF -> . var np_addRead R_PAR empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 101
    ID              shift and go to state 175

    readF                          shift and go to state 176
    var                            shift and go to state 177

state 126

    (67) write -> WRITE L_PAR . writeT
    (68) writeT -> . CTE_STRING np_addConstString writeF
    (69) writeT -> . exp writeF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 179
    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    writeT                         shift and go to state 178
    exp                            shift and go to state 180
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 127

    (74) if -> IF L_PAR . exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 181
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 128

    (72) repeat -> conditional empty .

    ID              reduce using rule 72 (repeat -> conditional empty .)
    RETURN          reduce using rule 72 (repeat -> conditional empty .)
    READ            reduce using rule 72 (repeat -> conditional empty .)
    WRITE           reduce using rule 72 (repeat -> conditional empty .)
    IF              reduce using rule 72 (repeat -> conditional empty .)
    VAR             reduce using rule 72 (repeat -> conditional empty .)
    WHILE           reduce using rule 72 (repeat -> conditional empty .)
    FROM            reduce using rule 72 (repeat -> conditional empty .)
    R_CURPAR        reduce using rule 72 (repeat -> conditional empty .)


state 129

    (73) repeat -> nonconditional empty .

    ID              reduce using rule 73 (repeat -> nonconditional empty .)
    RETURN          reduce using rule 73 (repeat -> nonconditional empty .)
    READ            reduce using rule 73 (repeat -> nonconditional empty .)
    WRITE           reduce using rule 73 (repeat -> nonconditional empty .)
    IF              reduce using rule 73 (repeat -> nonconditional empty .)
    VAR             reduce using rule 73 (repeat -> nonconditional empty .)
    WHILE           reduce using rule 73 (repeat -> nonconditional empty .)
    FROM            reduce using rule 73 (repeat -> nonconditional empty .)
    R_CURPAR        reduce using rule 73 (repeat -> nonconditional empty .)


state 130

    (60) var -> VAR varF .

    EQUAL           reduce using rule 60 (var -> VAR varF .)
    PLUS_EQ         reduce using rule 60 (var -> VAR varF .)
    MIN_EQ          reduce using rule 60 (var -> VAR varF .)
    MULT_EQ         reduce using rule 60 (var -> VAR varF .)
    DIV_EQ          reduce using rule 60 (var -> VAR varF .)
    MULT            reduce using rule 60 (var -> VAR varF .)
    DIV             reduce using rule 60 (var -> VAR varF .)
    PLUS            reduce using rule 60 (var -> VAR varF .)
    MINUS           reduce using rule 60 (var -> VAR varF .)
    LESS            reduce using rule 60 (var -> VAR varF .)
    GREATER         reduce using rule 60 (var -> VAR varF .)
    LESS_TH         reduce using rule 60 (var -> VAR varF .)
    GREAT_TH        reduce using rule 60 (var -> VAR varF .)
    SAME            reduce using rule 60 (var -> VAR varF .)
    DIF             reduce using rule 60 (var -> VAR varF .)
    OR              reduce using rule 60 (var -> VAR varF .)
    AND             reduce using rule 60 (var -> VAR varF .)
    R_PAR           reduce using rule 60 (var -> VAR varF .)
    COMMA           reduce using rule 60 (var -> VAR varF .)
    R_BREAK         reduce using rule 60 (var -> VAR varF .)
    SEMICOLON       reduce using rule 60 (var -> VAR varF .)
    TO              reduce using rule 60 (var -> VAR varF .)
    DO              reduce using rule 60 (var -> VAR varF .)


state 131

    (62) varF -> arrfunc . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 182

state 132

    (63) varF -> empty .

    EQUAL           reduce using rule 63 (varF -> empty .)
    PLUS_EQ         reduce using rule 63 (varF -> empty .)
    MIN_EQ          reduce using rule 63 (varF -> empty .)
    MULT_EQ         reduce using rule 63 (varF -> empty .)
    DIV_EQ          reduce using rule 63 (varF -> empty .)
    MULT            reduce using rule 63 (varF -> empty .)
    DIV             reduce using rule 63 (varF -> empty .)
    PLUS            reduce using rule 63 (varF -> empty .)
    MINUS           reduce using rule 63 (varF -> empty .)
    LESS            reduce using rule 63 (varF -> empty .)
    GREATER         reduce using rule 63 (varF -> empty .)
    LESS_TH         reduce using rule 63 (varF -> empty .)
    GREAT_TH        reduce using rule 63 (varF -> empty .)
    SAME            reduce using rule 63 (varF -> empty .)
    DIF             reduce using rule 63 (varF -> empty .)
    OR              reduce using rule 63 (varF -> empty .)
    AND             reduce using rule 63 (varF -> empty .)
    R_PAR           reduce using rule 63 (varF -> empty .)
    COMMA           reduce using rule 63 (varF -> empty .)
    R_BREAK         reduce using rule 63 (varF -> empty .)
    SEMICOLON       reduce using rule 63 (varF -> empty .)
    TO              reduce using rule 63 (varF -> empty .)
    DO              reduce using rule 63 (varF -> empty .)


state 133

    (57) arrfunc -> L_BREAK . exp COMMA exp R_BREAK empty
    (58) arrfunc -> L_BREAK . exp R_BREAK empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 183
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 134

    (84) conditional -> WHILE np_addWhile . L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty

    L_PAR           shift and go to state 184


state 135

    (85) nonconditional -> FROM VAR . arrfunc nonconditionalF
    (86) nonconditional -> FROM VAR . np_addId nonconditionalF
    (57) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (58) arrfunc -> . L_BREAK exp R_BREAK empty
    (130) np_addId -> .

    L_BREAK         shift and go to state 133
    EQUAL           reduce using rule 130 (np_addId -> .)

    arrfunc                        shift and go to state 185
    np_addId                       shift and go to state 186

state 136

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func . R_CURPAR SEMICOLON empty

    R_CURPAR        shift and go to state 187


state 137

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec . dec
    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec . np_addToDic empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF
    (128) np_addToDic -> .

    VAR             shift and go to state 28
    MAIN            reduce using rule 128 (np_addToDic -> .)
    INT             reduce using rule 128 (np_addToDic -> .)
    FLOAT           reduce using rule 128 (np_addToDic -> .)
    CHAR            reduce using rule 128 (np_addToDic -> .)
    BOOL            reduce using rule 128 (np_addToDic -> .)
    ID              reduce using rule 128 (np_addToDic -> .)
    VOID            reduce using rule 128 (np_addToDic -> .)
    METHODS         reduce using rule 128 (np_addToDic -> .)
    L_CURPAR        reduce using rule 128 (np_addToDic -> .)

    dec                            shift and go to state 188
    np_addToDic                    shift and go to state 189

state 138

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .

    COMMA           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    COLON           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)


state 139

    (25) funcF -> parameter R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR np_endFunc empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 28

    dec                            shift and go to state 190

state 140

    (26) funcF -> R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR np_endFunc empty

    L_CURPAR        shift and go to state 191


state 141

    (33) parameter -> VAR np_getDec COLON . typepar np_getVarType np_addParam SEMICOLON np_getDec parameterF
    (36) typepar -> . INT empty
    (37) typepar -> . FLOAT empty
    (38) typepar -> . CHAR empty
    (39) typepar -> . BOOL empty
    (40) typepar -> . ID empty

    INT             shift and go to state 193
    FLOAT           shift and go to state 194
    CHAR            shift and go to state 195
    BOOL            shift and go to state 196
    ID              shift and go to state 197

    typepar                        shift and go to state 192

state 142

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty .

    $end            reduce using rule 41 (main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty .)


state 143

    (42) statement -> assigment SEMICOLON statementF .

    R_CURPAR        reduce using rule 42 (statement -> assigment SEMICOLON statementF .)


state 144

    (43) statement -> void SEMICOLON statementF .

    R_CURPAR        reduce using rule 43 (statement -> void SEMICOLON statementF .)


state 145

    (44) statement -> return SEMICOLON statementF .

    R_CURPAR        reduce using rule 44 (statement -> return SEMICOLON statementF .)


state 146

    (45) statement -> read SEMICOLON statementF .

    R_CURPAR        reduce using rule 45 (statement -> read SEMICOLON statementF .)


state 147

    (46) statement -> write SEMICOLON statementF .

    R_CURPAR        reduce using rule 46 (statement -> write SEMICOLON statementF .)


state 148

    (77) assigment -> var np_addId assigmentF .

    SEMICOLON       reduce using rule 77 (assigment -> var np_addId assigmentF .)


state 149

    (78) assigmentF -> EQUAL . np_addOp exp np_doAssign empty
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 198

state 150

    (79) assigmentF -> ope . np_addOp exp np_doAssign empty
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 199

state 151

    (80) ope -> PLUS_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 200

state 152

    (81) ope -> MIN_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 201

state 153

    (82) ope -> MULT_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 202

state 154

    (83) ope -> DIV_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 203

state 155

    (51) void -> ID DOT ID . L_PAR voidT

    L_PAR           shift and go to state 204


state 156

    (61) var -> ID DOT VAR . varF
    (62) varF -> . arrfunc empty
    (63) varF -> . empty
    (57) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (58) arrfunc -> . L_BREAK exp R_BREAK empty
    (120) empty -> .

    L_BREAK         shift and go to state 133
    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    varF                           shift and go to state 205
    arrfunc                        shift and go to state 131
    empty                          shift and go to state 132

state 157

    (52) void -> ID np_checkVoid L_PAR . np_eraQuad voidT
    (156) np_eraQuad -> .

    R_PAR           reduce using rule 156 (np_eraQuad -> .)
    L_PAR           reduce using rule 156 (np_eraQuad -> .)
    PLUS            reduce using rule 156 (np_eraQuad -> .)
    MINUS           reduce using rule 156 (np_eraQuad -> .)
    CTE_INT         reduce using rule 156 (np_eraQuad -> .)
    CTE_FLOAT       reduce using rule 156 (np_eraQuad -> .)
    CTE_CHAR        reduce using rule 156 (np_eraQuad -> .)
    CTE_BOOL        reduce using rule 156 (np_eraQuad -> .)
    VAR             reduce using rule 156 (np_eraQuad -> .)
    ID              reduce using rule 156 (np_eraQuad -> .)

    np_eraQuad                     shift and go to state 206

state 158

    (109) factor -> L_PAR . np_addPar exp R_PAR np_popPar empty
    (137) np_addPar -> .

    L_PAR           reduce using rule 137 (np_addPar -> .)
    PLUS            reduce using rule 137 (np_addPar -> .)
    MINUS           reduce using rule 137 (np_addPar -> .)
    CTE_INT         reduce using rule 137 (np_addPar -> .)
    CTE_FLOAT       reduce using rule 137 (np_addPar -> .)
    CTE_CHAR        reduce using rule 137 (np_addPar -> .)
    CTE_BOOL        reduce using rule 137 (np_addPar -> .)
    VAR             reduce using rule 137 (np_addPar -> .)
    ID              reduce using rule 137 (np_addPar -> .)

    np_addPar                      shift and go to state 207

state 159

    (59) return -> RETURN L_PAR exp . np_addReturn R_PAR empty
    (146) np_addReturn -> .

    R_PAR           reduce using rule 146 (np_addReturn -> .)

    np_addReturn                   shift and go to state 208

state 160

    (100) exp -> bool . empty
    (120) empty -> .

    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 209

state 161

    (88) bool -> logical . np_addBool boolF
    (142) np_addBool -> .

    OR              reduce using rule 142 (np_addBool -> .)
    AND             reduce using rule 142 (np_addBool -> .)
    R_PAR           reduce using rule 142 (np_addBool -> .)
    COMMA           reduce using rule 142 (np_addBool -> .)
    R_BREAK         reduce using rule 142 (np_addBool -> .)
    SEMICOLON       reduce using rule 142 (np_addBool -> .)
    TO              reduce using rule 142 (np_addBool -> .)
    DO              reduce using rule 142 (np_addBool -> .)

    np_addBool                     shift and go to state 210

state 162

    (92) logical -> ex . np_addLogical logicalF
    (141) np_addLogical -> .

    LESS            reduce using rule 141 (np_addLogical -> .)
    GREATER         reduce using rule 141 (np_addLogical -> .)
    LESS_TH         reduce using rule 141 (np_addLogical -> .)
    GREAT_TH        reduce using rule 141 (np_addLogical -> .)
    SAME            reduce using rule 141 (np_addLogical -> .)
    DIF             reduce using rule 141 (np_addLogical -> .)
    OR              reduce using rule 141 (np_addLogical -> .)
    AND             reduce using rule 141 (np_addLogical -> .)
    R_PAR           reduce using rule 141 (np_addLogical -> .)
    COMMA           reduce using rule 141 (np_addLogical -> .)
    R_BREAK         reduce using rule 141 (np_addLogical -> .)
    SEMICOLON       reduce using rule 141 (np_addLogical -> .)
    TO              reduce using rule 141 (np_addLogical -> .)
    DO              reduce using rule 141 (np_addLogical -> .)

    np_addLogical                  shift and go to state 211

state 163

    (101) ex -> term . np_addEx exF
    (140) np_addEx -> .

    PLUS            reduce using rule 140 (np_addEx -> .)
    MINUS           reduce using rule 140 (np_addEx -> .)
    LESS            reduce using rule 140 (np_addEx -> .)
    GREATER         reduce using rule 140 (np_addEx -> .)
    LESS_TH         reduce using rule 140 (np_addEx -> .)
    GREAT_TH        reduce using rule 140 (np_addEx -> .)
    SAME            reduce using rule 140 (np_addEx -> .)
    DIF             reduce using rule 140 (np_addEx -> .)
    OR              reduce using rule 140 (np_addEx -> .)
    AND             reduce using rule 140 (np_addEx -> .)
    R_PAR           reduce using rule 140 (np_addEx -> .)
    COMMA           reduce using rule 140 (np_addEx -> .)
    R_BREAK         reduce using rule 140 (np_addEx -> .)
    SEMICOLON       reduce using rule 140 (np_addEx -> .)
    TO              reduce using rule 140 (np_addEx -> .)
    DO              reduce using rule 140 (np_addEx -> .)

    np_addEx                       shift and go to state 212

state 164

    (105) term -> factor . np_addTerm termF
    (139) np_addTerm -> .

    MULT            reduce using rule 139 (np_addTerm -> .)
    DIV             reduce using rule 139 (np_addTerm -> .)
    PLUS            reduce using rule 139 (np_addTerm -> .)
    MINUS           reduce using rule 139 (np_addTerm -> .)
    LESS            reduce using rule 139 (np_addTerm -> .)
    GREATER         reduce using rule 139 (np_addTerm -> .)
    LESS_TH         reduce using rule 139 (np_addTerm -> .)
    GREAT_TH        reduce using rule 139 (np_addTerm -> .)
    SAME            reduce using rule 139 (np_addTerm -> .)
    DIF             reduce using rule 139 (np_addTerm -> .)
    OR              reduce using rule 139 (np_addTerm -> .)
    AND             reduce using rule 139 (np_addTerm -> .)
    R_PAR           reduce using rule 139 (np_addTerm -> .)
    COMMA           reduce using rule 139 (np_addTerm -> .)
    R_BREAK         reduce using rule 139 (np_addTerm -> .)
    SEMICOLON       reduce using rule 139 (np_addTerm -> .)
    TO              reduce using rule 139 (np_addTerm -> .)
    DO              reduce using rule 139 (np_addTerm -> .)

    np_addTerm                     shift and go to state 213

state 165

    (110) factor -> factorT .

    MULT            reduce using rule 110 (factor -> factorT .)
    DIV             reduce using rule 110 (factor -> factorT .)
    PLUS            reduce using rule 110 (factor -> factorT .)
    MINUS           reduce using rule 110 (factor -> factorT .)
    LESS            reduce using rule 110 (factor -> factorT .)
    GREATER         reduce using rule 110 (factor -> factorT .)
    LESS_TH         reduce using rule 110 (factor -> factorT .)
    GREAT_TH        reduce using rule 110 (factor -> factorT .)
    SAME            reduce using rule 110 (factor -> factorT .)
    DIF             reduce using rule 110 (factor -> factorT .)
    OR              reduce using rule 110 (factor -> factorT .)
    AND             reduce using rule 110 (factor -> factorT .)
    R_PAR           reduce using rule 110 (factor -> factorT .)
    COMMA           reduce using rule 110 (factor -> factorT .)
    R_BREAK         reduce using rule 110 (factor -> factorT .)
    SEMICOLON       reduce using rule 110 (factor -> factorT .)
    TO              reduce using rule 110 (factor -> factorT .)
    DO              reduce using rule 110 (factor -> factorT .)


state 166

    (111) factorT -> PLUS . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    factorF                        shift and go to state 214
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 167

    (113) factorT -> factorF .

    MULT            reduce using rule 113 (factorT -> factorF .)
    DIV             reduce using rule 113 (factorT -> factorF .)
    PLUS            reduce using rule 113 (factorT -> factorF .)
    MINUS           reduce using rule 113 (factorT -> factorF .)
    LESS            reduce using rule 113 (factorT -> factorF .)
    GREATER         reduce using rule 113 (factorT -> factorF .)
    LESS_TH         reduce using rule 113 (factorT -> factorF .)
    GREAT_TH        reduce using rule 113 (factorT -> factorF .)
    SAME            reduce using rule 113 (factorT -> factorF .)
    DIF             reduce using rule 113 (factorT -> factorF .)
    OR              reduce using rule 113 (factorT -> factorF .)
    AND             reduce using rule 113 (factorT -> factorF .)
    R_PAR           reduce using rule 113 (factorT -> factorF .)
    COMMA           reduce using rule 113 (factorT -> factorF .)
    R_BREAK         reduce using rule 113 (factorT -> factorF .)
    SEMICOLON       reduce using rule 113 (factorT -> factorF .)
    TO              reduce using rule 113 (factorT -> factorF .)
    DO              reduce using rule 113 (factorT -> factorF .)


state 168

    (112) factorT -> MINUS . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    factorF                        shift and go to state 215
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 169

    (114) factorF -> varcte . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 216

state 170

    (115) varcte -> var . np_addId empty
    (130) np_addId -> .

    MULT            reduce using rule 130 (np_addId -> .)
    DIV             reduce using rule 130 (np_addId -> .)
    PLUS            reduce using rule 130 (np_addId -> .)
    MINUS           reduce using rule 130 (np_addId -> .)
    LESS            reduce using rule 130 (np_addId -> .)
    GREATER         reduce using rule 130 (np_addId -> .)
    LESS_TH         reduce using rule 130 (np_addId -> .)
    GREAT_TH        reduce using rule 130 (np_addId -> .)
    SAME            reduce using rule 130 (np_addId -> .)
    DIF             reduce using rule 130 (np_addId -> .)
    OR              reduce using rule 130 (np_addId -> .)
    AND             reduce using rule 130 (np_addId -> .)
    R_PAR           reduce using rule 130 (np_addId -> .)
    COMMA           reduce using rule 130 (np_addId -> .)
    R_BREAK         reduce using rule 130 (np_addId -> .)
    SEMICOLON       reduce using rule 130 (np_addId -> .)
    TO              reduce using rule 130 (np_addId -> .)
    DO              reduce using rule 130 (np_addId -> .)

    np_addId                       shift and go to state 217

state 171

    (116) varcte -> CTE_INT . np_addConstInt empty
    (131) np_addConstInt -> .

    MULT            reduce using rule 131 (np_addConstInt -> .)
    DIV             reduce using rule 131 (np_addConstInt -> .)
    PLUS            reduce using rule 131 (np_addConstInt -> .)
    MINUS           reduce using rule 131 (np_addConstInt -> .)
    LESS            reduce using rule 131 (np_addConstInt -> .)
    GREATER         reduce using rule 131 (np_addConstInt -> .)
    LESS_TH         reduce using rule 131 (np_addConstInt -> .)
    GREAT_TH        reduce using rule 131 (np_addConstInt -> .)
    SAME            reduce using rule 131 (np_addConstInt -> .)
    DIF             reduce using rule 131 (np_addConstInt -> .)
    OR              reduce using rule 131 (np_addConstInt -> .)
    AND             reduce using rule 131 (np_addConstInt -> .)
    R_PAR           reduce using rule 131 (np_addConstInt -> .)
    COMMA           reduce using rule 131 (np_addConstInt -> .)
    R_BREAK         reduce using rule 131 (np_addConstInt -> .)
    SEMICOLON       reduce using rule 131 (np_addConstInt -> .)
    TO              reduce using rule 131 (np_addConstInt -> .)
    DO              reduce using rule 131 (np_addConstInt -> .)

    np_addConstInt                 shift and go to state 218

state 172

    (117) varcte -> CTE_FLOAT . np_addConstFloat empty
    (132) np_addConstFloat -> .

    MULT            reduce using rule 132 (np_addConstFloat -> .)
    DIV             reduce using rule 132 (np_addConstFloat -> .)
    PLUS            reduce using rule 132 (np_addConstFloat -> .)
    MINUS           reduce using rule 132 (np_addConstFloat -> .)
    LESS            reduce using rule 132 (np_addConstFloat -> .)
    GREATER         reduce using rule 132 (np_addConstFloat -> .)
    LESS_TH         reduce using rule 132 (np_addConstFloat -> .)
    GREAT_TH        reduce using rule 132 (np_addConstFloat -> .)
    SAME            reduce using rule 132 (np_addConstFloat -> .)
    DIF             reduce using rule 132 (np_addConstFloat -> .)
    OR              reduce using rule 132 (np_addConstFloat -> .)
    AND             reduce using rule 132 (np_addConstFloat -> .)
    R_PAR           reduce using rule 132 (np_addConstFloat -> .)
    COMMA           reduce using rule 132 (np_addConstFloat -> .)
    R_BREAK         reduce using rule 132 (np_addConstFloat -> .)
    SEMICOLON       reduce using rule 132 (np_addConstFloat -> .)
    TO              reduce using rule 132 (np_addConstFloat -> .)
    DO              reduce using rule 132 (np_addConstFloat -> .)

    np_addConstFloat               shift and go to state 219

state 173

    (118) varcte -> CTE_CHAR . np_addConstChar empty
    (133) np_addConstChar -> .

    MULT            reduce using rule 133 (np_addConstChar -> .)
    DIV             reduce using rule 133 (np_addConstChar -> .)
    PLUS            reduce using rule 133 (np_addConstChar -> .)
    MINUS           reduce using rule 133 (np_addConstChar -> .)
    LESS            reduce using rule 133 (np_addConstChar -> .)
    GREATER         reduce using rule 133 (np_addConstChar -> .)
    LESS_TH         reduce using rule 133 (np_addConstChar -> .)
    GREAT_TH        reduce using rule 133 (np_addConstChar -> .)
    SAME            reduce using rule 133 (np_addConstChar -> .)
    DIF             reduce using rule 133 (np_addConstChar -> .)
    OR              reduce using rule 133 (np_addConstChar -> .)
    AND             reduce using rule 133 (np_addConstChar -> .)
    R_PAR           reduce using rule 133 (np_addConstChar -> .)
    COMMA           reduce using rule 133 (np_addConstChar -> .)
    R_BREAK         reduce using rule 133 (np_addConstChar -> .)
    SEMICOLON       reduce using rule 133 (np_addConstChar -> .)
    TO              reduce using rule 133 (np_addConstChar -> .)
    DO              reduce using rule 133 (np_addConstChar -> .)

    np_addConstChar                shift and go to state 220

state 174

    (119) varcte -> CTE_BOOL . np_addConstBool empty
    (134) np_addConstBool -> .

    MULT            reduce using rule 134 (np_addConstBool -> .)
    DIV             reduce using rule 134 (np_addConstBool -> .)
    PLUS            reduce using rule 134 (np_addConstBool -> .)
    MINUS           reduce using rule 134 (np_addConstBool -> .)
    LESS            reduce using rule 134 (np_addConstBool -> .)
    GREATER         reduce using rule 134 (np_addConstBool -> .)
    LESS_TH         reduce using rule 134 (np_addConstBool -> .)
    GREAT_TH        reduce using rule 134 (np_addConstBool -> .)
    SAME            reduce using rule 134 (np_addConstBool -> .)
    DIF             reduce using rule 134 (np_addConstBool -> .)
    OR              reduce using rule 134 (np_addConstBool -> .)
    AND             reduce using rule 134 (np_addConstBool -> .)
    R_PAR           reduce using rule 134 (np_addConstBool -> .)
    COMMA           reduce using rule 134 (np_addConstBool -> .)
    R_BREAK         reduce using rule 134 (np_addConstBool -> .)
    SEMICOLON       reduce using rule 134 (np_addConstBool -> .)
    TO              reduce using rule 134 (np_addConstBool -> .)
    DO              reduce using rule 134 (np_addConstBool -> .)

    np_addConstBool                shift and go to state 221

state 175

    (61) var -> ID . DOT VAR varF

    DOT             shift and go to state 222


state 176

    (64) read -> READ L_PAR readF .

    SEMICOLON       reduce using rule 64 (read -> READ L_PAR readF .)


state 177

    (65) readF -> var . np_addRead COMMA readF
    (66) readF -> var . np_addRead R_PAR empty
    (144) np_addRead -> .

    COMMA           reduce using rule 144 (np_addRead -> .)
    R_PAR           reduce using rule 144 (np_addRead -> .)

    np_addRead                     shift and go to state 223

state 178

    (67) write -> WRITE L_PAR writeT .

    SEMICOLON       reduce using rule 67 (write -> WRITE L_PAR writeT .)


state 179

    (68) writeT -> CTE_STRING . np_addConstString writeF
    (135) np_addConstString -> .

    COMMA           reduce using rule 135 (np_addConstString -> .)
    R_PAR           reduce using rule 135 (np_addConstString -> .)

    np_addConstString              shift and go to state 224

state 180

    (69) writeT -> exp . writeF
    (70) writeF -> . COMMA np_addWrite writeT
    (71) writeF -> . R_PAR np_addWrite empty

    COMMA           shift and go to state 226
    R_PAR           shift and go to state 227

    writeF                         shift and go to state 225

state 181

    (74) if -> IF L_PAR exp . np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (147) np_checkBool -> .

    R_PAR           reduce using rule 147 (np_checkBool -> .)

    np_checkBool                   shift and go to state 228

state 182

    (62) varF -> arrfunc empty .

    EQUAL           reduce using rule 62 (varF -> arrfunc empty .)
    PLUS_EQ         reduce using rule 62 (varF -> arrfunc empty .)
    MIN_EQ          reduce using rule 62 (varF -> arrfunc empty .)
    MULT_EQ         reduce using rule 62 (varF -> arrfunc empty .)
    DIV_EQ          reduce using rule 62 (varF -> arrfunc empty .)
    MULT            reduce using rule 62 (varF -> arrfunc empty .)
    DIV             reduce using rule 62 (varF -> arrfunc empty .)
    PLUS            reduce using rule 62 (varF -> arrfunc empty .)
    MINUS           reduce using rule 62 (varF -> arrfunc empty .)
    LESS            reduce using rule 62 (varF -> arrfunc empty .)
    GREATER         reduce using rule 62 (varF -> arrfunc empty .)
    LESS_TH         reduce using rule 62 (varF -> arrfunc empty .)
    GREAT_TH        reduce using rule 62 (varF -> arrfunc empty .)
    SAME            reduce using rule 62 (varF -> arrfunc empty .)
    DIF             reduce using rule 62 (varF -> arrfunc empty .)
    OR              reduce using rule 62 (varF -> arrfunc empty .)
    AND             reduce using rule 62 (varF -> arrfunc empty .)
    R_PAR           reduce using rule 62 (varF -> arrfunc empty .)
    COMMA           reduce using rule 62 (varF -> arrfunc empty .)
    R_BREAK         reduce using rule 62 (varF -> arrfunc empty .)
    SEMICOLON       reduce using rule 62 (varF -> arrfunc empty .)
    TO              reduce using rule 62 (varF -> arrfunc empty .)
    DO              reduce using rule 62 (varF -> arrfunc empty .)


state 183

    (57) arrfunc -> L_BREAK exp . COMMA exp R_BREAK empty
    (58) arrfunc -> L_BREAK exp . R_BREAK empty

    COMMA           shift and go to state 229
    R_BREAK         shift and go to state 230


state 184

    (84) conditional -> WHILE np_addWhile L_PAR . exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 231
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 185

    (85) nonconditional -> FROM VAR arrfunc . nonconditionalF
    (87) nonconditionalF -> . EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty

    EQUAL           shift and go to state 233

    nonconditionalF                shift and go to state 232

state 186

    (86) nonconditional -> FROM VAR np_addId . nonconditionalF
    (87) nonconditionalF -> . EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty

    EQUAL           shift and go to state 233

    nonconditionalF                shift and go to state 234

state 187

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR . SEMICOLON empty

    SEMICOLON       shift and go to state 235


state 188

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec dec .

    MAIN            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    INT             reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    FLOAT           reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    CHAR            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    BOOL            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    ID              reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    VOID            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    METHODS         reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    L_CURPAR        reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)


state 189

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    METHODS         reduce using rule 120 (empty -> .)
    L_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 236

state 190

    (25) funcF -> parameter R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR np_endFunc empty

    L_CURPAR        shift and go to state 237


state 191

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR np_endFunc empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    statement                      shift and go to state 238
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 192

    (33) parameter -> VAR np_getDec COLON typepar . np_getVarType np_addParam SEMICOLON np_getDec parameterF
    (126) np_getVarType -> .

    SEMICOLON       reduce using rule 126 (np_getVarType -> .)

    np_getVarType                  shift and go to state 239

state 193

    (36) typepar -> INT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 240

state 194

    (37) typepar -> FLOAT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 241

state 195

    (38) typepar -> CHAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 242

state 196

    (39) typepar -> BOOL . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 243

state 197

    (40) typepar -> ID . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 244

state 198

    (78) assigmentF -> EQUAL np_addOp . exp np_doAssign empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 245
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 199

    (79) assigmentF -> ope np_addOp . exp np_doAssign empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 246
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 200

    (80) ope -> PLUS_EQ empty .

    L_PAR           reduce using rule 80 (ope -> PLUS_EQ empty .)
    PLUS            reduce using rule 80 (ope -> PLUS_EQ empty .)
    MINUS           reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_INT         reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_FLOAT       reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_CHAR        reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_BOOL        reduce using rule 80 (ope -> PLUS_EQ empty .)
    VAR             reduce using rule 80 (ope -> PLUS_EQ empty .)
    ID              reduce using rule 80 (ope -> PLUS_EQ empty .)


state 201

    (81) ope -> MIN_EQ empty .

    L_PAR           reduce using rule 81 (ope -> MIN_EQ empty .)
    PLUS            reduce using rule 81 (ope -> MIN_EQ empty .)
    MINUS           reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_INT         reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_FLOAT       reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_CHAR        reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_BOOL        reduce using rule 81 (ope -> MIN_EQ empty .)
    VAR             reduce using rule 81 (ope -> MIN_EQ empty .)
    ID              reduce using rule 81 (ope -> MIN_EQ empty .)


state 202

    (82) ope -> MULT_EQ empty .

    L_PAR           reduce using rule 82 (ope -> MULT_EQ empty .)
    PLUS            reduce using rule 82 (ope -> MULT_EQ empty .)
    MINUS           reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_INT         reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_FLOAT       reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_CHAR        reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_BOOL        reduce using rule 82 (ope -> MULT_EQ empty .)
    VAR             reduce using rule 82 (ope -> MULT_EQ empty .)
    ID              reduce using rule 82 (ope -> MULT_EQ empty .)


state 203

    (83) ope -> DIV_EQ empty .

    L_PAR           reduce using rule 83 (ope -> DIV_EQ empty .)
    PLUS            reduce using rule 83 (ope -> DIV_EQ empty .)
    MINUS           reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_INT         reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_FLOAT       reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_CHAR        reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_BOOL        reduce using rule 83 (ope -> DIV_EQ empty .)
    VAR             reduce using rule 83 (ope -> DIV_EQ empty .)
    ID              reduce using rule 83 (ope -> DIV_EQ empty .)


state 204

    (51) void -> ID DOT ID L_PAR . voidT
    (53) voidT -> . exp np_checkParam COMMA voidT
    (54) voidT -> . exp np_checkParam voidF
    (55) voidT -> . voidF
    (100) exp -> . bool empty
    (56) voidF -> . R_PAR np_endVoid empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 250
    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    voidT                          shift and go to state 247
    exp                            shift and go to state 248
    voidF                          shift and go to state 249
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 205

    (61) var -> ID DOT VAR varF .

    EQUAL           reduce using rule 61 (var -> ID DOT VAR varF .)
    PLUS_EQ         reduce using rule 61 (var -> ID DOT VAR varF .)
    MIN_EQ          reduce using rule 61 (var -> ID DOT VAR varF .)
    MULT_EQ         reduce using rule 61 (var -> ID DOT VAR varF .)
    DIV_EQ          reduce using rule 61 (var -> ID DOT VAR varF .)
    MULT            reduce using rule 61 (var -> ID DOT VAR varF .)
    DIV             reduce using rule 61 (var -> ID DOT VAR varF .)
    PLUS            reduce using rule 61 (var -> ID DOT VAR varF .)
    MINUS           reduce using rule 61 (var -> ID DOT VAR varF .)
    LESS            reduce using rule 61 (var -> ID DOT VAR varF .)
    GREATER         reduce using rule 61 (var -> ID DOT VAR varF .)
    LESS_TH         reduce using rule 61 (var -> ID DOT VAR varF .)
    GREAT_TH        reduce using rule 61 (var -> ID DOT VAR varF .)
    SAME            reduce using rule 61 (var -> ID DOT VAR varF .)
    DIF             reduce using rule 61 (var -> ID DOT VAR varF .)
    OR              reduce using rule 61 (var -> ID DOT VAR varF .)
    AND             reduce using rule 61 (var -> ID DOT VAR varF .)
    R_PAR           reduce using rule 61 (var -> ID DOT VAR varF .)
    COMMA           reduce using rule 61 (var -> ID DOT VAR varF .)
    R_BREAK         reduce using rule 61 (var -> ID DOT VAR varF .)
    SEMICOLON       reduce using rule 61 (var -> ID DOT VAR varF .)
    TO              reduce using rule 61 (var -> ID DOT VAR varF .)
    DO              reduce using rule 61 (var -> ID DOT VAR varF .)


state 206

    (52) void -> ID np_checkVoid L_PAR np_eraQuad . voidT
    (53) voidT -> . exp np_checkParam COMMA voidT
    (54) voidT -> . exp np_checkParam voidF
    (55) voidT -> . voidF
    (100) exp -> . bool empty
    (56) voidF -> . R_PAR np_endVoid empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 250
    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    voidT                          shift and go to state 251
    exp                            shift and go to state 248
    voidF                          shift and go to state 249
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 207

    (109) factor -> L_PAR np_addPar . exp R_PAR np_popPar empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 252
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 208

    (59) return -> RETURN L_PAR exp np_addReturn . R_PAR empty

    R_PAR           shift and go to state 253


state 209

    (100) exp -> bool empty .

    R_PAR           reduce using rule 100 (exp -> bool empty .)
    COMMA           reduce using rule 100 (exp -> bool empty .)
    R_BREAK         reduce using rule 100 (exp -> bool empty .)
    SEMICOLON       reduce using rule 100 (exp -> bool empty .)
    TO              reduce using rule 100 (exp -> bool empty .)
    DO              reduce using rule 100 (exp -> bool empty .)


state 210

    (88) bool -> logical np_addBool . boolF
    (89) boolF -> . OR np_addOp bool
    (90) boolF -> . AND np_addOp bool
    (91) boolF -> . empty
    (120) empty -> .

    OR              shift and go to state 255
    AND             shift and go to state 256
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    boolF                          shift and go to state 254
    empty                          shift and go to state 257

state 211

    (92) logical -> ex np_addLogical . logicalF
    (93) logicalF -> . LESS np_addOp logical
    (94) logicalF -> . GREATER np_addOp logical
    (95) logicalF -> . LESS_TH np_addOp logical
    (96) logicalF -> . GREAT_TH np_addOp logical
    (97) logicalF -> . SAME np_addOp logical
    (98) logicalF -> . DIF np_addOp logical
    (99) logicalF -> . empty
    (120) empty -> .

    LESS            shift and go to state 259
    GREATER         shift and go to state 260
    LESS_TH         shift and go to state 261
    GREAT_TH        shift and go to state 262
    SAME            shift and go to state 263
    DIF             shift and go to state 264
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    logicalF                       shift and go to state 258
    empty                          shift and go to state 265

state 212

    (101) ex -> term np_addEx . exF
    (102) exF -> . PLUS np_addOp ex
    (103) exF -> . MINUS np_addOp ex
    (104) exF -> . empty
    (120) empty -> .

    PLUS            shift and go to state 267
    MINUS           shift and go to state 268
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    exF                            shift and go to state 266
    empty                          shift and go to state 269

state 213

    (105) term -> factor np_addTerm . termF
    (106) termF -> . MULT np_addOp term
    (107) termF -> . DIV np_addOp term
    (108) termF -> . empty
    (120) empty -> .

    MULT            shift and go to state 271
    DIV             shift and go to state 272
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    termF                          shift and go to state 270
    empty                          shift and go to state 273

state 214

    (111) factorT -> PLUS factorF .

    MULT            reduce using rule 111 (factorT -> PLUS factorF .)
    DIV             reduce using rule 111 (factorT -> PLUS factorF .)
    PLUS            reduce using rule 111 (factorT -> PLUS factorF .)
    MINUS           reduce using rule 111 (factorT -> PLUS factorF .)
    LESS            reduce using rule 111 (factorT -> PLUS factorF .)
    GREATER         reduce using rule 111 (factorT -> PLUS factorF .)
    LESS_TH         reduce using rule 111 (factorT -> PLUS factorF .)
    GREAT_TH        reduce using rule 111 (factorT -> PLUS factorF .)
    SAME            reduce using rule 111 (factorT -> PLUS factorF .)
    DIF             reduce using rule 111 (factorT -> PLUS factorF .)
    OR              reduce using rule 111 (factorT -> PLUS factorF .)
    AND             reduce using rule 111 (factorT -> PLUS factorF .)
    R_PAR           reduce using rule 111 (factorT -> PLUS factorF .)
    COMMA           reduce using rule 111 (factorT -> PLUS factorF .)
    R_BREAK         reduce using rule 111 (factorT -> PLUS factorF .)
    SEMICOLON       reduce using rule 111 (factorT -> PLUS factorF .)
    TO              reduce using rule 111 (factorT -> PLUS factorF .)
    DO              reduce using rule 111 (factorT -> PLUS factorF .)


state 215

    (112) factorT -> MINUS factorF .

    MULT            reduce using rule 112 (factorT -> MINUS factorF .)
    DIV             reduce using rule 112 (factorT -> MINUS factorF .)
    PLUS            reduce using rule 112 (factorT -> MINUS factorF .)
    MINUS           reduce using rule 112 (factorT -> MINUS factorF .)
    LESS            reduce using rule 112 (factorT -> MINUS factorF .)
    GREATER         reduce using rule 112 (factorT -> MINUS factorF .)
    LESS_TH         reduce using rule 112 (factorT -> MINUS factorF .)
    GREAT_TH        reduce using rule 112 (factorT -> MINUS factorF .)
    SAME            reduce using rule 112 (factorT -> MINUS factorF .)
    DIF             reduce using rule 112 (factorT -> MINUS factorF .)
    OR              reduce using rule 112 (factorT -> MINUS factorF .)
    AND             reduce using rule 112 (factorT -> MINUS factorF .)
    R_PAR           reduce using rule 112 (factorT -> MINUS factorF .)
    COMMA           reduce using rule 112 (factorT -> MINUS factorF .)
    R_BREAK         reduce using rule 112 (factorT -> MINUS factorF .)
    SEMICOLON       reduce using rule 112 (factorT -> MINUS factorF .)
    TO              reduce using rule 112 (factorT -> MINUS factorF .)
    DO              reduce using rule 112 (factorT -> MINUS factorF .)


state 216

    (114) factorF -> varcte empty .

    MULT            reduce using rule 114 (factorF -> varcte empty .)
    DIV             reduce using rule 114 (factorF -> varcte empty .)
    PLUS            reduce using rule 114 (factorF -> varcte empty .)
    MINUS           reduce using rule 114 (factorF -> varcte empty .)
    LESS            reduce using rule 114 (factorF -> varcte empty .)
    GREATER         reduce using rule 114 (factorF -> varcte empty .)
    LESS_TH         reduce using rule 114 (factorF -> varcte empty .)
    GREAT_TH        reduce using rule 114 (factorF -> varcte empty .)
    SAME            reduce using rule 114 (factorF -> varcte empty .)
    DIF             reduce using rule 114 (factorF -> varcte empty .)
    OR              reduce using rule 114 (factorF -> varcte empty .)
    AND             reduce using rule 114 (factorF -> varcte empty .)
    R_PAR           reduce using rule 114 (factorF -> varcte empty .)
    COMMA           reduce using rule 114 (factorF -> varcte empty .)
    R_BREAK         reduce using rule 114 (factorF -> varcte empty .)
    SEMICOLON       reduce using rule 114 (factorF -> varcte empty .)
    TO              reduce using rule 114 (factorF -> varcte empty .)
    DO              reduce using rule 114 (factorF -> varcte empty .)


state 217

    (115) varcte -> var np_addId . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 274

state 218

    (116) varcte -> CTE_INT np_addConstInt . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 275

state 219

    (117) varcte -> CTE_FLOAT np_addConstFloat . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 276

state 220

    (118) varcte -> CTE_CHAR np_addConstChar . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 277

state 221

    (119) varcte -> CTE_BOOL np_addConstBool . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 278

state 222

    (61) var -> ID DOT . VAR varF

    VAR             shift and go to state 156


state 223

    (65) readF -> var np_addRead . COMMA readF
    (66) readF -> var np_addRead . R_PAR empty

    COMMA           shift and go to state 279
    R_PAR           shift and go to state 280


state 224

    (68) writeT -> CTE_STRING np_addConstString . writeF
    (70) writeF -> . COMMA np_addWrite writeT
    (71) writeF -> . R_PAR np_addWrite empty

    COMMA           shift and go to state 226
    R_PAR           shift and go to state 227

    writeF                         shift and go to state 281

state 225

    (69) writeT -> exp writeF .

    SEMICOLON       reduce using rule 69 (writeT -> exp writeF .)


state 226

    (70) writeF -> COMMA . np_addWrite writeT
    (145) np_addWrite -> .

    CTE_STRING      reduce using rule 145 (np_addWrite -> .)
    L_PAR           reduce using rule 145 (np_addWrite -> .)
    PLUS            reduce using rule 145 (np_addWrite -> .)
    MINUS           reduce using rule 145 (np_addWrite -> .)
    CTE_INT         reduce using rule 145 (np_addWrite -> .)
    CTE_FLOAT       reduce using rule 145 (np_addWrite -> .)
    CTE_CHAR        reduce using rule 145 (np_addWrite -> .)
    CTE_BOOL        reduce using rule 145 (np_addWrite -> .)
    VAR             reduce using rule 145 (np_addWrite -> .)
    ID              reduce using rule 145 (np_addWrite -> .)

    np_addWrite                    shift and go to state 282

state 227

    (71) writeF -> R_PAR . np_addWrite empty
    (145) np_addWrite -> .

    SEMICOLON       reduce using rule 145 (np_addWrite -> .)

    np_addWrite                    shift and go to state 283

state 228

    (74) if -> IF L_PAR exp np_checkBool . R_PAR THEN L_CURPAR statement R_CURPAR ifF

    R_PAR           shift and go to state 284


state 229

    (57) arrfunc -> L_BREAK exp COMMA . exp R_BREAK empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 285
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 230

    (58) arrfunc -> L_BREAK exp R_BREAK . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 286

state 231

    (84) conditional -> WHILE np_addWhile L_PAR exp . R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty

    R_PAR           shift and go to state 287


state 232

    (85) nonconditional -> FROM VAR arrfunc nonconditionalF .

    ID              reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    RETURN          reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    READ            reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WRITE           reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    IF              reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    VAR             reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WHILE           reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    FROM            reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    R_CURPAR        reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)


state 233

    (87) nonconditionalF -> EQUAL . np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 288

state 234

    (86) nonconditional -> FROM VAR np_addId nonconditionalF .

    ID              reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    RETURN          reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    READ            reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    WRITE           reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    IF              reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    VAR             reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    WHILE           reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    FROM            reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)
    R_CURPAR        reduce using rule 86 (nonconditional -> FROM VAR np_addId nonconditionalF .)


state 235

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON . empty
    (120) empty -> .

    CLASS           reduce using rule 120 (empty -> .)
    VARS            reduce using rule 120 (empty -> .)
    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 289

state 236

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .

    MAIN            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    INT             reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    FLOAT           reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    CHAR            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    BOOL            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    ID              reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    VOID            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    METHODS         reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    L_CURPAR        reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)


state 237

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR np_endFunc empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    statement                      shift and go to state 290
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 238

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR np_endFunc empty

    R_CURPAR        shift and go to state 291


state 239

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType . np_addParam SEMICOLON np_getDec parameterF
    (127) np_addParam -> .

    SEMICOLON       reduce using rule 127 (np_addParam -> .)

    np_addParam                    shift and go to state 292

state 240

    (36) typepar -> INT empty .

    SEMICOLON       reduce using rule 36 (typepar -> INT empty .)


state 241

    (37) typepar -> FLOAT empty .

    SEMICOLON       reduce using rule 37 (typepar -> FLOAT empty .)


state 242

    (38) typepar -> CHAR empty .

    SEMICOLON       reduce using rule 38 (typepar -> CHAR empty .)


state 243

    (39) typepar -> BOOL empty .

    SEMICOLON       reduce using rule 39 (typepar -> BOOL empty .)


state 244

    (40) typepar -> ID empty .

    SEMICOLON       reduce using rule 40 (typepar -> ID empty .)


state 245

    (78) assigmentF -> EQUAL np_addOp exp . np_doAssign empty
    (143) np_doAssign -> .

    SEMICOLON       reduce using rule 143 (np_doAssign -> .)

    np_doAssign                    shift and go to state 293

state 246

    (79) assigmentF -> ope np_addOp exp . np_doAssign empty
    (143) np_doAssign -> .

    SEMICOLON       reduce using rule 143 (np_doAssign -> .)

    np_doAssign                    shift and go to state 294

state 247

    (51) void -> ID DOT ID L_PAR voidT .

    SEMICOLON       reduce using rule 51 (void -> ID DOT ID L_PAR voidT .)


state 248

    (53) voidT -> exp . np_checkParam COMMA voidT
    (54) voidT -> exp . np_checkParam voidF
    (157) np_checkParam -> .

    COMMA           reduce using rule 157 (np_checkParam -> .)
    R_PAR           reduce using rule 157 (np_checkParam -> .)

    np_checkParam                  shift and go to state 295

state 249

    (55) voidT -> voidF .

    SEMICOLON       reduce using rule 55 (voidT -> voidF .)


state 250

    (56) voidF -> R_PAR . np_endVoid empty
    (158) np_endVoid -> .

    SEMICOLON       reduce using rule 158 (np_endVoid -> .)

    np_endVoid                     shift and go to state 296

state 251

    (52) void -> ID np_checkVoid L_PAR np_eraQuad voidT .

    SEMICOLON       reduce using rule 52 (void -> ID np_checkVoid L_PAR np_eraQuad voidT .)


state 252

    (109) factor -> L_PAR np_addPar exp . R_PAR np_popPar empty

    R_PAR           shift and go to state 297


state 253

    (59) return -> RETURN L_PAR exp np_addReturn R_PAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 298

state 254

    (88) bool -> logical np_addBool boolF .

    R_PAR           reduce using rule 88 (bool -> logical np_addBool boolF .)
    COMMA           reduce using rule 88 (bool -> logical np_addBool boolF .)
    R_BREAK         reduce using rule 88 (bool -> logical np_addBool boolF .)
    SEMICOLON       reduce using rule 88 (bool -> logical np_addBool boolF .)
    TO              reduce using rule 88 (bool -> logical np_addBool boolF .)
    DO              reduce using rule 88 (bool -> logical np_addBool boolF .)


state 255

    (89) boolF -> OR . np_addOp bool
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 299

state 256

    (90) boolF -> AND . np_addOp bool
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 300

state 257

    (91) boolF -> empty .

    R_PAR           reduce using rule 91 (boolF -> empty .)
    COMMA           reduce using rule 91 (boolF -> empty .)
    R_BREAK         reduce using rule 91 (boolF -> empty .)
    SEMICOLON       reduce using rule 91 (boolF -> empty .)
    TO              reduce using rule 91 (boolF -> empty .)
    DO              reduce using rule 91 (boolF -> empty .)


state 258

    (92) logical -> ex np_addLogical logicalF .

    OR              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    AND             reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_PAR           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    COMMA           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_BREAK         reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    SEMICOLON       reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    TO              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    DO              reduce using rule 92 (logical -> ex np_addLogical logicalF .)


state 259

    (93) logicalF -> LESS . np_addOp logical
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 301

state 260

    (94) logicalF -> GREATER . np_addOp logical
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 302

state 261

    (95) logicalF -> LESS_TH . np_addOp logical
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 303

state 262

    (96) logicalF -> GREAT_TH . np_addOp logical
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 304

state 263

    (97) logicalF -> SAME . np_addOp logical
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 305

state 264

    (98) logicalF -> DIF . np_addOp logical
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 306

state 265

    (99) logicalF -> empty .

    OR              reduce using rule 99 (logicalF -> empty .)
    AND             reduce using rule 99 (logicalF -> empty .)
    R_PAR           reduce using rule 99 (logicalF -> empty .)
    COMMA           reduce using rule 99 (logicalF -> empty .)
    R_BREAK         reduce using rule 99 (logicalF -> empty .)
    SEMICOLON       reduce using rule 99 (logicalF -> empty .)
    TO              reduce using rule 99 (logicalF -> empty .)
    DO              reduce using rule 99 (logicalF -> empty .)


state 266

    (101) ex -> term np_addEx exF .

    LESS            reduce using rule 101 (ex -> term np_addEx exF .)
    GREATER         reduce using rule 101 (ex -> term np_addEx exF .)
    LESS_TH         reduce using rule 101 (ex -> term np_addEx exF .)
    GREAT_TH        reduce using rule 101 (ex -> term np_addEx exF .)
    SAME            reduce using rule 101 (ex -> term np_addEx exF .)
    DIF             reduce using rule 101 (ex -> term np_addEx exF .)
    OR              reduce using rule 101 (ex -> term np_addEx exF .)
    AND             reduce using rule 101 (ex -> term np_addEx exF .)
    R_PAR           reduce using rule 101 (ex -> term np_addEx exF .)
    COMMA           reduce using rule 101 (ex -> term np_addEx exF .)
    R_BREAK         reduce using rule 101 (ex -> term np_addEx exF .)
    SEMICOLON       reduce using rule 101 (ex -> term np_addEx exF .)
    TO              reduce using rule 101 (ex -> term np_addEx exF .)
    DO              reduce using rule 101 (ex -> term np_addEx exF .)


state 267

    (102) exF -> PLUS . np_addOp ex
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 307

state 268

    (103) exF -> MINUS . np_addOp ex
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 308

state 269

    (104) exF -> empty .

    LESS            reduce using rule 104 (exF -> empty .)
    GREATER         reduce using rule 104 (exF -> empty .)
    LESS_TH         reduce using rule 104 (exF -> empty .)
    GREAT_TH        reduce using rule 104 (exF -> empty .)
    SAME            reduce using rule 104 (exF -> empty .)
    DIF             reduce using rule 104 (exF -> empty .)
    OR              reduce using rule 104 (exF -> empty .)
    AND             reduce using rule 104 (exF -> empty .)
    R_PAR           reduce using rule 104 (exF -> empty .)
    COMMA           reduce using rule 104 (exF -> empty .)
    R_BREAK         reduce using rule 104 (exF -> empty .)
    SEMICOLON       reduce using rule 104 (exF -> empty .)
    TO              reduce using rule 104 (exF -> empty .)
    DO              reduce using rule 104 (exF -> empty .)


state 270

    (105) term -> factor np_addTerm termF .

    PLUS            reduce using rule 105 (term -> factor np_addTerm termF .)
    MINUS           reduce using rule 105 (term -> factor np_addTerm termF .)
    LESS            reduce using rule 105 (term -> factor np_addTerm termF .)
    GREATER         reduce using rule 105 (term -> factor np_addTerm termF .)
    LESS_TH         reduce using rule 105 (term -> factor np_addTerm termF .)
    GREAT_TH        reduce using rule 105 (term -> factor np_addTerm termF .)
    SAME            reduce using rule 105 (term -> factor np_addTerm termF .)
    DIF             reduce using rule 105 (term -> factor np_addTerm termF .)
    OR              reduce using rule 105 (term -> factor np_addTerm termF .)
    AND             reduce using rule 105 (term -> factor np_addTerm termF .)
    R_PAR           reduce using rule 105 (term -> factor np_addTerm termF .)
    COMMA           reduce using rule 105 (term -> factor np_addTerm termF .)
    R_BREAK         reduce using rule 105 (term -> factor np_addTerm termF .)
    SEMICOLON       reduce using rule 105 (term -> factor np_addTerm termF .)
    TO              reduce using rule 105 (term -> factor np_addTerm termF .)
    DO              reduce using rule 105 (term -> factor np_addTerm termF .)


state 271

    (106) termF -> MULT . np_addOp term
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 309

state 272

    (107) termF -> DIV . np_addOp term
    (136) np_addOp -> .

    L_PAR           reduce using rule 136 (np_addOp -> .)
    PLUS            reduce using rule 136 (np_addOp -> .)
    MINUS           reduce using rule 136 (np_addOp -> .)
    CTE_INT         reduce using rule 136 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 136 (np_addOp -> .)
    CTE_CHAR        reduce using rule 136 (np_addOp -> .)
    CTE_BOOL        reduce using rule 136 (np_addOp -> .)
    VAR             reduce using rule 136 (np_addOp -> .)
    ID              reduce using rule 136 (np_addOp -> .)

    np_addOp                       shift and go to state 310

state 273

    (108) termF -> empty .

    PLUS            reduce using rule 108 (termF -> empty .)
    MINUS           reduce using rule 108 (termF -> empty .)
    LESS            reduce using rule 108 (termF -> empty .)
    GREATER         reduce using rule 108 (termF -> empty .)
    LESS_TH         reduce using rule 108 (termF -> empty .)
    GREAT_TH        reduce using rule 108 (termF -> empty .)
    SAME            reduce using rule 108 (termF -> empty .)
    DIF             reduce using rule 108 (termF -> empty .)
    OR              reduce using rule 108 (termF -> empty .)
    AND             reduce using rule 108 (termF -> empty .)
    R_PAR           reduce using rule 108 (termF -> empty .)
    COMMA           reduce using rule 108 (termF -> empty .)
    R_BREAK         reduce using rule 108 (termF -> empty .)
    SEMICOLON       reduce using rule 108 (termF -> empty .)
    TO              reduce using rule 108 (termF -> empty .)
    DO              reduce using rule 108 (termF -> empty .)


state 274

    (115) varcte -> var np_addId empty .

    MULT            reduce using rule 115 (varcte -> var np_addId empty .)
    DIV             reduce using rule 115 (varcte -> var np_addId empty .)
    PLUS            reduce using rule 115 (varcte -> var np_addId empty .)
    MINUS           reduce using rule 115 (varcte -> var np_addId empty .)
    LESS            reduce using rule 115 (varcte -> var np_addId empty .)
    GREATER         reduce using rule 115 (varcte -> var np_addId empty .)
    LESS_TH         reduce using rule 115 (varcte -> var np_addId empty .)
    GREAT_TH        reduce using rule 115 (varcte -> var np_addId empty .)
    SAME            reduce using rule 115 (varcte -> var np_addId empty .)
    DIF             reduce using rule 115 (varcte -> var np_addId empty .)
    OR              reduce using rule 115 (varcte -> var np_addId empty .)
    AND             reduce using rule 115 (varcte -> var np_addId empty .)
    R_PAR           reduce using rule 115 (varcte -> var np_addId empty .)
    COMMA           reduce using rule 115 (varcte -> var np_addId empty .)
    R_BREAK         reduce using rule 115 (varcte -> var np_addId empty .)
    SEMICOLON       reduce using rule 115 (varcte -> var np_addId empty .)
    TO              reduce using rule 115 (varcte -> var np_addId empty .)
    DO              reduce using rule 115 (varcte -> var np_addId empty .)


state 275

    (116) varcte -> CTE_INT np_addConstInt empty .

    MULT            reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    DIV             reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    PLUS            reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    MINUS           reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    LESS            reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    GREATER         reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    LESS_TH         reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    GREAT_TH        reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    SAME            reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    DIF             reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    OR              reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    AND             reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    R_PAR           reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    COMMA           reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    R_BREAK         reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    SEMICOLON       reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    TO              reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    DO              reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)


state 276

    (117) varcte -> CTE_FLOAT np_addConstFloat empty .

    MULT            reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    DIV             reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    PLUS            reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    MINUS           reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    LESS            reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    GREATER         reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    LESS_TH         reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    GREAT_TH        reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    SAME            reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    DIF             reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    OR              reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    AND             reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    R_PAR           reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    COMMA           reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    R_BREAK         reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    SEMICOLON       reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    TO              reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    DO              reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)


state 277

    (118) varcte -> CTE_CHAR np_addConstChar empty .

    MULT            reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    DIV             reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    PLUS            reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    MINUS           reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    LESS            reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    GREATER         reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    LESS_TH         reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    GREAT_TH        reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    SAME            reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    DIF             reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    OR              reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    AND             reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    R_PAR           reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    COMMA           reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    R_BREAK         reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    SEMICOLON       reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    TO              reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    DO              reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)


state 278

    (119) varcte -> CTE_BOOL np_addConstBool empty .

    MULT            reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    DIV             reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    PLUS            reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    MINUS           reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    LESS            reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    GREATER         reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    LESS_TH         reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    GREAT_TH        reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    SAME            reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    DIF             reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    OR              reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    AND             reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    R_PAR           reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    COMMA           reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    R_BREAK         reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    SEMICOLON       reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    TO              reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    DO              reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)


state 279

    (65) readF -> var np_addRead COMMA . readF
    (65) readF -> . var np_addRead COMMA readF
    (66) readF -> . var np_addRead R_PAR empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 101
    ID              shift and go to state 175

    var                            shift and go to state 177
    readF                          shift and go to state 311

state 280

    (66) readF -> var np_addRead R_PAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 312

state 281

    (68) writeT -> CTE_STRING np_addConstString writeF .

    SEMICOLON       reduce using rule 68 (writeT -> CTE_STRING np_addConstString writeF .)


state 282

    (70) writeF -> COMMA np_addWrite . writeT
    (68) writeT -> . CTE_STRING np_addConstString writeF
    (69) writeT -> . exp writeF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 179
    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    writeT                         shift and go to state 313
    exp                            shift and go to state 180
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 283

    (71) writeF -> R_PAR np_addWrite . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 314

state 284

    (74) if -> IF L_PAR exp np_checkBool R_PAR . THEN L_CURPAR statement R_CURPAR ifF

    THEN            shift and go to state 315


state 285

    (57) arrfunc -> L_BREAK exp COMMA exp . R_BREAK empty

    R_BREAK         shift and go to state 316


state 286

    (58) arrfunc -> L_BREAK exp R_BREAK empty .

    EQUAL           reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MIN_EQ          reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT_EQ         reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV_EQ          reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT            reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV             reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS            reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MINUS           reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS            reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREATER         reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS_TH         reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREAT_TH        reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SAME            reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIF             reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    OR              reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    AND             reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_PAR           reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    COMMA           reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_BREAK         reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SEMICOLON       reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    TO              reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DO              reduce using rule 58 (arrfunc -> L_BREAK exp R_BREAK empty .)


state 287

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR . np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (147) np_checkBool -> .

    DO              reduce using rule 147 (np_checkBool -> .)

    np_checkBool                   shift and go to state 317

state 288

    (87) nonconditionalF -> EQUAL np_addOp . exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 318
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 289

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .

    CLASS           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VARS            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    MAIN            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    INT             reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    FLOAT           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    CHAR            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    BOOL            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    ID              reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VOID            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)


state 290

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR np_endFunc empty

    R_CURPAR        shift and go to state 319


state 291

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . np_endFunc empty
    (129) np_endFunc -> .

    MAIN            reduce using rule 129 (np_endFunc -> .)
    INT             reduce using rule 129 (np_endFunc -> .)
    FLOAT           reduce using rule 129 (np_endFunc -> .)
    CHAR            reduce using rule 129 (np_endFunc -> .)
    BOOL            reduce using rule 129 (np_endFunc -> .)
    ID              reduce using rule 129 (np_endFunc -> .)
    VOID            reduce using rule 129 (np_endFunc -> .)
    R_CURPAR        reduce using rule 129 (np_endFunc -> .)

    np_endFunc                     shift and go to state 320

state 292

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam . SEMICOLON np_getDec parameterF

    SEMICOLON       shift and go to state 321


state 293

    (78) assigmentF -> EQUAL np_addOp exp np_doAssign . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 322

state 294

    (79) assigmentF -> ope np_addOp exp np_doAssign . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 323

state 295

    (53) voidT -> exp np_checkParam . COMMA voidT
    (54) voidT -> exp np_checkParam . voidF
    (56) voidF -> . R_PAR np_endVoid empty

    COMMA           shift and go to state 324
    R_PAR           shift and go to state 250

    voidF                          shift and go to state 325

state 296

    (56) voidF -> R_PAR np_endVoid . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 326

state 297

    (109) factor -> L_PAR np_addPar exp R_PAR . np_popPar empty
    (138) np_popPar -> .

    MULT            reduce using rule 138 (np_popPar -> .)
    DIV             reduce using rule 138 (np_popPar -> .)
    PLUS            reduce using rule 138 (np_popPar -> .)
    MINUS           reduce using rule 138 (np_popPar -> .)
    LESS            reduce using rule 138 (np_popPar -> .)
    GREATER         reduce using rule 138 (np_popPar -> .)
    LESS_TH         reduce using rule 138 (np_popPar -> .)
    GREAT_TH        reduce using rule 138 (np_popPar -> .)
    SAME            reduce using rule 138 (np_popPar -> .)
    DIF             reduce using rule 138 (np_popPar -> .)
    OR              reduce using rule 138 (np_popPar -> .)
    AND             reduce using rule 138 (np_popPar -> .)
    R_PAR           reduce using rule 138 (np_popPar -> .)
    COMMA           reduce using rule 138 (np_popPar -> .)
    R_BREAK         reduce using rule 138 (np_popPar -> .)
    SEMICOLON       reduce using rule 138 (np_popPar -> .)
    TO              reduce using rule 138 (np_popPar -> .)
    DO              reduce using rule 138 (np_popPar -> .)

    np_popPar                      shift and go to state 327

state 298

    (59) return -> RETURN L_PAR exp np_addReturn R_PAR empty .

    SEMICOLON       reduce using rule 59 (return -> RETURN L_PAR exp np_addReturn R_PAR empty .)


state 299

    (89) boolF -> OR np_addOp . bool
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    bool                           shift and go to state 328
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 300

    (90) boolF -> AND np_addOp . bool
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    bool                           shift and go to state 329
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 301

    (93) logicalF -> LESS np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    logical                        shift and go to state 330
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 302

    (94) logicalF -> GREATER np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    logical                        shift and go to state 331
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 303

    (95) logicalF -> LESS_TH np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    logical                        shift and go to state 332
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 304

    (96) logicalF -> GREAT_TH np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    logical                        shift and go to state 333
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 305

    (97) logicalF -> SAME np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    logical                        shift and go to state 334
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 306

    (98) logicalF -> DIF np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    logical                        shift and go to state 335
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 307

    (102) exF -> PLUS np_addOp . ex
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    ex                             shift and go to state 336
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 308

    (103) exF -> MINUS np_addOp . ex
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    ex                             shift and go to state 337
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 309

    (106) termF -> MULT np_addOp . term
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    term                           shift and go to state 338
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 310

    (107) termF -> DIV np_addOp . term
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    term                           shift and go to state 339
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 311

    (65) readF -> var np_addRead COMMA readF .

    SEMICOLON       reduce using rule 65 (readF -> var np_addRead COMMA readF .)


state 312

    (66) readF -> var np_addRead R_PAR empty .

    SEMICOLON       reduce using rule 66 (readF -> var np_addRead R_PAR empty .)


state 313

    (70) writeF -> COMMA np_addWrite writeT .

    SEMICOLON       reduce using rule 70 (writeF -> COMMA np_addWrite writeT .)


state 314

    (71) writeF -> R_PAR np_addWrite empty .

    SEMICOLON       reduce using rule 71 (writeF -> R_PAR np_addWrite empty .)


state 315

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN . L_CURPAR statement R_CURPAR ifF

    L_CURPAR        shift and go to state 340


state 316

    (57) arrfunc -> L_BREAK exp COMMA exp R_BREAK . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 341

state 317

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool . DO L_CURPAR statement R_CURPAR np_endWhile empty

    DO              shift and go to state 342


state 318

    (87) nonconditionalF -> EQUAL np_addOp exp . np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
    (152) np_assingFor -> .

    TO              reduce using rule 152 (np_assingFor -> .)

    np_assingFor                   shift and go to state 343

state 319

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . np_endFunc empty
    (129) np_endFunc -> .

    MAIN            reduce using rule 129 (np_endFunc -> .)
    INT             reduce using rule 129 (np_endFunc -> .)
    FLOAT           reduce using rule 129 (np_endFunc -> .)
    CHAR            reduce using rule 129 (np_endFunc -> .)
    BOOL            reduce using rule 129 (np_endFunc -> .)
    ID              reduce using rule 129 (np_endFunc -> .)
    VOID            reduce using rule 129 (np_endFunc -> .)
    R_CURPAR        reduce using rule 129 (np_endFunc -> .)

    np_endFunc                     shift and go to state 344

state 320

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 345

state 321

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON . np_getDec parameterF
    (124) np_getDec -> .

    VAR             reduce using rule 124 (np_getDec -> .)
    R_PAR           reduce using rule 124 (np_getDec -> .)

    np_getDec                      shift and go to state 346

state 322

    (78) assigmentF -> EQUAL np_addOp exp np_doAssign empty .

    SEMICOLON       reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)


state 323

    (79) assigmentF -> ope np_addOp exp np_doAssign empty .

    SEMICOLON       reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)


state 324

    (53) voidT -> exp np_checkParam COMMA . voidT
    (53) voidT -> . exp np_checkParam COMMA voidT
    (54) voidT -> . exp np_checkParam voidF
    (55) voidT -> . voidF
    (100) exp -> . bool empty
    (56) voidF -> . R_PAR np_endVoid empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 250
    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 248
    voidT                          shift and go to state 347
    voidF                          shift and go to state 249
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 325

    (54) voidT -> exp np_checkParam voidF .

    SEMICOLON       reduce using rule 54 (voidT -> exp np_checkParam voidF .)


state 326

    (56) voidF -> R_PAR np_endVoid empty .

    SEMICOLON       reduce using rule 56 (voidF -> R_PAR np_endVoid empty .)


state 327

    (109) factor -> L_PAR np_addPar exp R_PAR np_popPar . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 348

state 328

    (89) boolF -> OR np_addOp bool .

    R_PAR           reduce using rule 89 (boolF -> OR np_addOp bool .)
    COMMA           reduce using rule 89 (boolF -> OR np_addOp bool .)
    R_BREAK         reduce using rule 89 (boolF -> OR np_addOp bool .)
    SEMICOLON       reduce using rule 89 (boolF -> OR np_addOp bool .)
    TO              reduce using rule 89 (boolF -> OR np_addOp bool .)
    DO              reduce using rule 89 (boolF -> OR np_addOp bool .)


state 329

    (90) boolF -> AND np_addOp bool .

    R_PAR           reduce using rule 90 (boolF -> AND np_addOp bool .)
    COMMA           reduce using rule 90 (boolF -> AND np_addOp bool .)
    R_BREAK         reduce using rule 90 (boolF -> AND np_addOp bool .)
    SEMICOLON       reduce using rule 90 (boolF -> AND np_addOp bool .)
    TO              reduce using rule 90 (boolF -> AND np_addOp bool .)
    DO              reduce using rule 90 (boolF -> AND np_addOp bool .)


state 330

    (93) logicalF -> LESS np_addOp logical .

    OR              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    AND             reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_PAR           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    COMMA           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_BREAK         reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    SEMICOLON       reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    TO              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    DO              reduce using rule 93 (logicalF -> LESS np_addOp logical .)


state 331

    (94) logicalF -> GREATER np_addOp logical .

    OR              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    AND             reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_PAR           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    COMMA           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_BREAK         reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    SEMICOLON       reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    TO              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    DO              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)


state 332

    (95) logicalF -> LESS_TH np_addOp logical .

    OR              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    AND             reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_PAR           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    COMMA           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_BREAK         reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    SEMICOLON       reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    TO              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    DO              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)


state 333

    (96) logicalF -> GREAT_TH np_addOp logical .

    OR              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    AND             reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_PAR           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    COMMA           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_BREAK         reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    SEMICOLON       reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    TO              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    DO              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)


state 334

    (97) logicalF -> SAME np_addOp logical .

    OR              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    AND             reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_PAR           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    COMMA           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_BREAK         reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    SEMICOLON       reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    TO              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    DO              reduce using rule 97 (logicalF -> SAME np_addOp logical .)


state 335

    (98) logicalF -> DIF np_addOp logical .

    OR              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    AND             reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_PAR           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    COMMA           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_BREAK         reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    SEMICOLON       reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    TO              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    DO              reduce using rule 98 (logicalF -> DIF np_addOp logical .)


state 336

    (102) exF -> PLUS np_addOp ex .

    LESS            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    GREATER         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    LESS_TH         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    GREAT_TH        reduce using rule 102 (exF -> PLUS np_addOp ex .)
    SAME            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    DIF             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    OR              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    AND             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_PAR           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    COMMA           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_BREAK         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    SEMICOLON       reduce using rule 102 (exF -> PLUS np_addOp ex .)
    TO              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    DO              reduce using rule 102 (exF -> PLUS np_addOp ex .)


state 337

    (103) exF -> MINUS np_addOp ex .

    LESS            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    GREATER         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    LESS_TH         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    GREAT_TH        reduce using rule 103 (exF -> MINUS np_addOp ex .)
    SAME            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    DIF             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    OR              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    AND             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_PAR           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    COMMA           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_BREAK         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    SEMICOLON       reduce using rule 103 (exF -> MINUS np_addOp ex .)
    TO              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    DO              reduce using rule 103 (exF -> MINUS np_addOp ex .)


state 338

    (106) termF -> MULT np_addOp term .

    PLUS            reduce using rule 106 (termF -> MULT np_addOp term .)
    MINUS           reduce using rule 106 (termF -> MULT np_addOp term .)
    LESS            reduce using rule 106 (termF -> MULT np_addOp term .)
    GREATER         reduce using rule 106 (termF -> MULT np_addOp term .)
    LESS_TH         reduce using rule 106 (termF -> MULT np_addOp term .)
    GREAT_TH        reduce using rule 106 (termF -> MULT np_addOp term .)
    SAME            reduce using rule 106 (termF -> MULT np_addOp term .)
    DIF             reduce using rule 106 (termF -> MULT np_addOp term .)
    OR              reduce using rule 106 (termF -> MULT np_addOp term .)
    AND             reduce using rule 106 (termF -> MULT np_addOp term .)
    R_PAR           reduce using rule 106 (termF -> MULT np_addOp term .)
    COMMA           reduce using rule 106 (termF -> MULT np_addOp term .)
    R_BREAK         reduce using rule 106 (termF -> MULT np_addOp term .)
    SEMICOLON       reduce using rule 106 (termF -> MULT np_addOp term .)
    TO              reduce using rule 106 (termF -> MULT np_addOp term .)
    DO              reduce using rule 106 (termF -> MULT np_addOp term .)


state 339

    (107) termF -> DIV np_addOp term .

    PLUS            reduce using rule 107 (termF -> DIV np_addOp term .)
    MINUS           reduce using rule 107 (termF -> DIV np_addOp term .)
    LESS            reduce using rule 107 (termF -> DIV np_addOp term .)
    GREATER         reduce using rule 107 (termF -> DIV np_addOp term .)
    LESS_TH         reduce using rule 107 (termF -> DIV np_addOp term .)
    GREAT_TH        reduce using rule 107 (termF -> DIV np_addOp term .)
    SAME            reduce using rule 107 (termF -> DIV np_addOp term .)
    DIF             reduce using rule 107 (termF -> DIV np_addOp term .)
    OR              reduce using rule 107 (termF -> DIV np_addOp term .)
    AND             reduce using rule 107 (termF -> DIV np_addOp term .)
    R_PAR           reduce using rule 107 (termF -> DIV np_addOp term .)
    COMMA           reduce using rule 107 (termF -> DIV np_addOp term .)
    R_BREAK         reduce using rule 107 (termF -> DIV np_addOp term .)
    SEMICOLON       reduce using rule 107 (termF -> DIV np_addOp term .)
    TO              reduce using rule 107 (termF -> DIV np_addOp term .)
    DO              reduce using rule 107 (termF -> DIV np_addOp term .)


state 340

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR . statement R_CURPAR ifF
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    statement                      shift and go to state 349
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 341

    (57) arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .

    EQUAL           reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MIN_EQ          reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT_EQ         reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV_EQ          reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT            reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV             reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS            reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MINUS           reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS            reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREATER         reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS_TH         reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREAT_TH        reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SAME            reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIF             reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    OR              reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    AND             reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_PAR           reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    COMMA           reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_BREAK         reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SEMICOLON       reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    TO              reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DO              reduce using rule 57 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)


state 342

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO . L_CURPAR statement R_CURPAR np_endWhile empty

    L_CURPAR        shift and go to state 350


state 343

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor . TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty

    TO              shift and go to state 351


state 344

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 352

state 345

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .

    MAIN            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    INT             reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    FLOAT           reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    CHAR            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    BOOL            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    ID              reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    VOID            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    R_CURPAR        reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)


state 346

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec . parameterF
    (34) parameterF -> . parameter
    (35) parameterF -> . empty
    (33) parameter -> . VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec parameterF
    (120) empty -> .

    VAR             shift and go to state 84
    R_PAR           reduce using rule 120 (empty -> .)

    parameterF                     shift and go to state 353
    parameter                      shift and go to state 354
    empty                          shift and go to state 355

state 347

    (53) voidT -> exp np_checkParam COMMA voidT .

    SEMICOLON       reduce using rule 53 (voidT -> exp np_checkParam COMMA voidT .)


state 348

    (109) factor -> L_PAR np_addPar exp R_PAR np_popPar empty .

    MULT            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIV             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    PLUS            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    MINUS           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREATER         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS_TH         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREAT_TH        reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SAME            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIF             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    OR              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    AND             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_PAR           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    COMMA           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_BREAK         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SEMICOLON       reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    TO              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DO              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)


state 349

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement . R_CURPAR ifF

    R_CURPAR        shift and go to state 356


state 350

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR . statement R_CURPAR np_endWhile empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    statement                      shift and go to state 357
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 351

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO . exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 158
    PLUS            shift and go to state 166
    MINUS           shift and go to state 168
    CTE_INT         shift and go to state 171
    CTE_FLOAT       shift and go to state 172
    CTE_CHAR        shift and go to state 173
    CTE_BOOL        shift and go to state 174
    VAR             shift and go to state 101
    ID              shift and go to state 175

    exp                            shift and go to state 358
    bool                           shift and go to state 160
    logical                        shift and go to state 161
    ex                             shift and go to state 162
    term                           shift and go to state 163
    factor                         shift and go to state 164
    factorT                        shift and go to state 165
    factorF                        shift and go to state 167
    varcte                         shift and go to state 169
    var                            shift and go to state 170

state 352

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .

    MAIN            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    INT             reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    FLOAT           reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    CHAR            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    BOOL            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    ID              reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    VOID            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)
    R_CURPAR        reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR np_endFunc empty .)


state 353

    (33) parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec parameterF .

    R_PAR           reduce using rule 33 (parameter -> VAR np_getDec COLON typepar np_getVarType np_addParam SEMICOLON np_getDec parameterF .)


state 354

    (34) parameterF -> parameter .

    R_PAR           reduce using rule 34 (parameterF -> parameter .)


state 355

    (35) parameterF -> empty .

    R_PAR           reduce using rule 35 (parameterF -> empty .)


state 356

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR . ifF
    (75) ifF -> . ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty
    (76) ifF -> . np_endIf empty
    (148) np_endIf -> .

    ELSE            shift and go to state 360
    ID              reduce using rule 148 (np_endIf -> .)
    RETURN          reduce using rule 148 (np_endIf -> .)
    READ            reduce using rule 148 (np_endIf -> .)
    WRITE           reduce using rule 148 (np_endIf -> .)
    IF              reduce using rule 148 (np_endIf -> .)
    VAR             reduce using rule 148 (np_endIf -> .)
    WHILE           reduce using rule 148 (np_endIf -> .)
    FROM            reduce using rule 148 (np_endIf -> .)
    R_CURPAR        reduce using rule 148 (np_endIf -> .)

    ifF                            shift and go to state 359
    np_endIf                       shift and go to state 361

state 357

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement . R_CURPAR np_endWhile empty

    R_CURPAR        shift and go to state 362


state 358

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp . np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty
    (153) np_checkExp -> .

    DO              reduce using rule 153 (np_checkExp -> .)

    np_checkExp                    shift and go to state 363

state 359

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .

    ID              reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    RETURN          reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    READ            reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    WRITE           reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    IF              reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    VAR             reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    WHILE           reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    FROM            reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    R_CURPAR        reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)


state 360

    (75) ifF -> ELSE . np_else L_CURPAR statement R_CURPAR np_endIf empty
    (149) np_else -> .

    L_CURPAR        reduce using rule 149 (np_else -> .)

    np_else                        shift and go to state 364

state 361

    (76) ifF -> np_endIf . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 365

state 362

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR . np_endWhile empty
    (151) np_endWhile -> .

    ID              reduce using rule 151 (np_endWhile -> .)
    RETURN          reduce using rule 151 (np_endWhile -> .)
    READ            reduce using rule 151 (np_endWhile -> .)
    WRITE           reduce using rule 151 (np_endWhile -> .)
    IF              reduce using rule 151 (np_endWhile -> .)
    VAR             reduce using rule 151 (np_endWhile -> .)
    WHILE           reduce using rule 151 (np_endWhile -> .)
    FROM            reduce using rule 151 (np_endWhile -> .)
    R_CURPAR        reduce using rule 151 (np_endWhile -> .)

    np_endWhile                    shift and go to state 366

state 363

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp . DO L_CURPAR statement R_CURPAR np_endFor empty

    DO              shift and go to state 367


state 364

    (75) ifF -> ELSE np_else . L_CURPAR statement R_CURPAR np_endIf empty

    L_CURPAR        shift and go to state 368


state 365

    (76) ifF -> np_endIf empty .

    ID              reduce using rule 76 (ifF -> np_endIf empty .)
    RETURN          reduce using rule 76 (ifF -> np_endIf empty .)
    READ            reduce using rule 76 (ifF -> np_endIf empty .)
    WRITE           reduce using rule 76 (ifF -> np_endIf empty .)
    IF              reduce using rule 76 (ifF -> np_endIf empty .)
    VAR             reduce using rule 76 (ifF -> np_endIf empty .)
    WHILE           reduce using rule 76 (ifF -> np_endIf empty .)
    FROM            reduce using rule 76 (ifF -> np_endIf empty .)
    R_CURPAR        reduce using rule 76 (ifF -> np_endIf empty .)


state 366

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 369

state 367

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO . L_CURPAR statement R_CURPAR np_endFor empty

    L_CURPAR        shift and go to state 370


state 368

    (75) ifF -> ELSE np_else L_CURPAR . statement R_CURPAR np_endIf empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    statement                      shift and go to state 371
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 369

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .

    ID              reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    RETURN          reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    READ            reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    WRITE           reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    IF              reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    VAR             reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    WHILE           reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    FROM            reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    R_CURPAR        reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)


state 370

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR . statement R_CURPAR np_endFor empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR voidT
    (52) void -> . ID np_checkVoid L_PAR np_eraQuad voidT
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR np_addId nonconditionalF

    ID              shift and go to state 94
    RETURN          shift and go to state 95
    READ            shift and go to state 96
    WRITE           shift and go to state 97
    IF              shift and go to state 98
    VAR             shift and go to state 101
    WHILE           shift and go to state 102
    FROM            shift and go to state 103

    statement                      shift and go to state 372
    assigment                      shift and go to state 86
    void                           shift and go to state 87
    return                         shift and go to state 88
    read                           shift and go to state 89
    write                          shift and go to state 90
    if                             shift and go to state 91
    repeat                         shift and go to state 92
    var                            shift and go to state 93
    conditional                    shift and go to state 99
    nonconditional                 shift and go to state 100

state 371

    (75) ifF -> ELSE np_else L_CURPAR statement . R_CURPAR np_endIf empty

    R_CURPAR        shift and go to state 373


state 372

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement . R_CURPAR np_endFor empty

    R_CURPAR        shift and go to state 374


state 373

    (75) ifF -> ELSE np_else L_CURPAR statement R_CURPAR . np_endIf empty
    (148) np_endIf -> .

    ID              reduce using rule 148 (np_endIf -> .)
    RETURN          reduce using rule 148 (np_endIf -> .)
    READ            reduce using rule 148 (np_endIf -> .)
    WRITE           reduce using rule 148 (np_endIf -> .)
    IF              reduce using rule 148 (np_endIf -> .)
    VAR             reduce using rule 148 (np_endIf -> .)
    WHILE           reduce using rule 148 (np_endIf -> .)
    FROM            reduce using rule 148 (np_endIf -> .)
    R_CURPAR        reduce using rule 148 (np_endIf -> .)

    np_endIf                       shift and go to state 375

state 374

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR . np_endFor empty
    (154) np_endFor -> .

    ID              reduce using rule 154 (np_endFor -> .)
    RETURN          reduce using rule 154 (np_endFor -> .)
    READ            reduce using rule 154 (np_endFor -> .)
    WRITE           reduce using rule 154 (np_endFor -> .)
    IF              reduce using rule 154 (np_endFor -> .)
    VAR             reduce using rule 154 (np_endFor -> .)
    WHILE           reduce using rule 154 (np_endFor -> .)
    FROM            reduce using rule 154 (np_endFor -> .)
    R_CURPAR        reduce using rule 154 (np_endFor -> .)

    np_endFor                      shift and go to state 376

state 375

    (75) ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 377

state 376

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 378

state 377

    (75) ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .

    ID              reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    RETURN          reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    READ            reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    WRITE           reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    IF              reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    VAR             reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    WHILE           reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    FROM            reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    R_CURPAR        reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)


state 378

    (87) nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .

    ID              reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    RETURN          reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    READ            reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    WRITE           reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    IF              reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    VAR             reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    WHILE           reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    FROM            reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)
    R_CURPAR        reduce using rule 87 (nonconditionalF -> EQUAL np_addOp exp np_assingFor TO exp np_checkExp DO L_CURPAR statement R_CURPAR np_endFor empty .)

