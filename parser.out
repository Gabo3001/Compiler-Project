Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON programT
Rule 2     programT -> class programT
Rule 3     programT -> vars programF
Rule 4     programT -> programF
Rule 5     programF -> func programF
Rule 6     programF -> main empty
Rule 7     class -> CLASS ID classT
Rule 8     classT -> LESS INHERIT ID GREATER classF
Rule 9     classT -> classF
Rule 10    classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty
Rule 11    vars -> VARS dec empty
Rule 12    dec -> VAR arr decF
Rule 13    dec -> VAR decF
Rule 14    decF -> COMMA dec
Rule 15    decF -> COLON type SEMICOLON dec
Rule 16    decF -> COLON type SEMICOLON empty
Rule 17    type -> INT empty
Rule 18    type -> FLOAT empty
Rule 19    type -> CHAR empty
Rule 20    type -> STRING empty
Rule 21    type -> ID empty
Rule 22    arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
Rule 23    arr -> L_BREAK CTE_INT R_BREAK empty
Rule 24    func -> type funcT
Rule 25    func -> VOID funcT
Rule 26    funcT -> FUNCTION ID L_PAR funcF
Rule 27    funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 28    funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 29    parameter -> VAR COLON type SEMICOLON parameterF
Rule 30    parameterF -> parameter
Rule 31    parameterF -> empty
Rule 32    main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
Rule 33    statement -> assigment statementF
Rule 34    statement -> void statementF
Rule 35    statement -> return statementF
Rule 36    statement -> read statementF
Rule 37    statement -> write statementF
Rule 38    statement -> if statementF
Rule 39    statement -> repeat statementF
Rule 40    statementF -> statement
Rule 41    statementF -> empty
Rule 42    void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty
Rule 43    void -> ID L_PAR param R_PAR SEMICOLON empty
Rule 44    arrfunc -> L_BREAK exp COMMA exp R_BREAK empty
Rule 45    arrfunc -> L_BREAK exp R_BREAK empty
Rule 46    param -> var paramF
Rule 47    paramF -> COMMA param
Rule 48    paramF -> empty
Rule 49    return -> RETURN L_PAR exp R_PAR SEMICOLON empty
Rule 50    var -> VAR varF
Rule 51    var -> ID DOT VAR varF
Rule 52    varF -> arrfunc empty
Rule 53    varF -> empty
Rule 54    read -> READ L_PAR readF
Rule 55    readF -> var COMMA readF
Rule 56    readF -> var R_PAR SEMICOLON empty
Rule 57    write -> WRITE L_PAR writeT
Rule 58    writeT -> CTE_STRING writeF
Rule 59    writeT -> exp writeF
Rule 60    writeF -> COMMA writeT
Rule 61    writeF -> R_PAR SEMICOLON empty
Rule 62    repeat -> conditional empty
Rule 63    repeat -> nonconditional empty
Rule 64    if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
Rule 65    ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 66    ifF -> empty
Rule 67    assigment -> var assigmentF
Rule 68    assigmentF -> EQUAL exp empty
Rule 69    assigmentF -> ope exp empty
Rule 70    ope -> PLUS_EQ empty
Rule 71    ope -> MIN_EQ empty
Rule 72    ope -> MULT_EQ empty
Rule 73    ope -> DIV_EQ empty
Rule 74    conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 75    nonconditional -> FROM VAR arr nonconditionalF
Rule 76    nonconditional -> FROM VAR nonconditionalF
Rule 77    nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 78    bool -> OR exp empty
Rule 79    bool -> AND exp empty
Rule 80    exp -> ex expT
Rule 81    expT -> LESS expf
Rule 82    expT -> GREATER expf
Rule 83    expT -> LESS_TH expf
Rule 84    expT -> GREAT_TH expf
Rule 85    expT -> SAME expf
Rule 86    expT -> DIF expf
Rule 87    expT -> empty
Rule 88    expf -> ex empty
Rule 89    expf -> ex bool empty
Rule 90    ex -> term exF
Rule 91    exF -> PLUS ex
Rule 92    exF -> MINUS ex
Rule 93    exF -> empty
Rule 94    term -> factor termF
Rule 95    termF -> MULT term
Rule 96    termF -> DIV term
Rule 97    termF -> empty
Rule 98    factor -> L_PAR exp R_PAR empty
Rule 99    factor -> factorT
Rule 100   factorT -> PLUS factorF
Rule 101   factorT -> MINUS factorF
Rule 102   factorT -> factorF
Rule 103   factorF -> varcte empty
Rule 104   varcte -> var empty
Rule 105   varcte -> CTE_INT empty
Rule 106   varcte -> CTE_FLOAT empty
Rule 107   varcte -> CTE_STRING empty
Rule 108   empty -> <empty>

Terminals, with rules where they appear

AND                  : 79
ATTRIBUTES           : 10
CHAR                 : 19
CLASS                : 7
COLON                : 15 16 29
COMMA                : 14 22 44 47 55 60
CTE_FLOAT            : 106
CTE_INT              : 22 22 23 105
CTE_STRING           : 58 107
DIF                  : 86
DIV                  : 96
DIV_EQ               : 73
DO                   : 74 77
DOT                  : 42 51
ELSE                 : 65
EQUAL                : 68
FLOAT                : 18
FROM                 : 75 76
FUNCTION             : 26
GREATER              : 8 82
GREAT_TH             : 84
ID                   : 1 7 8 21 26 42 42 43 51
IF                   : 64
INHERIT              : 8
INT                  : 17
LESS                 : 8 81
LESS_TH              : 83
L_BREAK              : 22 23 44 45
L_CURPAR             : 10 27 28 32 64 65 74 77
L_PAR                : 26 32 42 43 49 54 57 64 74 98
MAIN                 : 32
METHODS              : 10
MINUS                : 92 101
MIN_EQ               : 71
MULT                 : 95
MULT_EQ              : 72
OR                   : 78
PLUS                 : 91 100
PLUS_EQ              : 70
PROGRAM              : 1
READ                 : 54
RETURN               : 49
R_BREAK              : 22 23 44 45
R_CURPAR             : 10 27 28 32 64 65 74 77
R_PAR                : 27 28 32 42 43 49 56 61 64 74 98
SAME                 : 85
SEMICOLON            : 1 10 10 15 16 27 28 29 42 43 49 56 61 64 65 74 77
STRING               : 20
THEN                 : 64
TO                   : 77
VAR                  : 12 13 29 50 51 75 76
VARS                 : 11
VOID                 : 25
WHILE                : 74
WRITE                : 57
error                : 

Nonterminals, with rules where they appear

arr                  : 12 75
arrfunc              : 52
assigment            : 33
assigmentF           : 67
bool                 : 89
class                : 2
classF               : 8 9
classT               : 7
conditional          : 62
dec                  : 10 11 14 15 27 28
decF                 : 12 13
empty                : 6 10 11 16 17 18 19 20 21 22 23 27 28 31 32 41 42 43 44 45 48 49 52 53 56 61 62 63 65 66 68 69 70 71 72 73 74 77 78 79 87 88 89 93 97 98 103 104 105 106 107
ex                   : 80 88 89 91 92
exF                  : 90
exp                  : 44 44 45 49 59 64 68 69 74 77 77 78 79 98
expT                 : 80
expf                 : 81 82 83 84 85 86
factor               : 94
factorF              : 100 101 102
factorT              : 99
func                 : 5 10
funcF                : 26
funcT                : 24 25
if                   : 38
ifF                  : 64
main                 : 6
nonconditional       : 63
nonconditionalF      : 75 76
ope                  : 69
param                : 42 43 47
paramF               : 46
parameter            : 27 30
parameterF           : 29
program              : 0
programF             : 3 4 5
programT             : 1 2
read                 : 36
readF                : 54 55
repeat               : 39
return               : 35
statement            : 27 28 32 40 64 65 74 77
statementF           : 33 34 35 36 37 38 39
term                 : 90 95 96
termF                : 94
type                 : 15 16 24 29
var                  : 46 55 56 67 104
varF                 : 50 51
varcte               : 103
vars                 : 3
void                 : 34
write                : 37
writeF               : 58 59
writeT               : 57 60

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON programT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON programT

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . type funcT
    (25) func -> . VOID funcT
    (32) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . STRING empty
    (21) type -> . ID empty

    CLASS           shift and go to state 10
    VARS            shift and go to state 11
    VOID            shift and go to state 15
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    STRING          shift and go to state 20
    ID              shift and go to state 5

    programT                       shift and go to state 6
    class                          shift and go to state 7
    vars                           shift and go to state 8
    programF                       shift and go to state 9
    func                           shift and go to state 12
    main                           shift and go to state 13
    type                           shift and go to state 14

state 5

    (21) type -> ID . empty
    (108) empty -> .

    FUNCTION        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 21

state 6

    (1) program -> PROGRAM ID SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON programT .)


state 7

    (2) programT -> class . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . type funcT
    (25) func -> . VOID funcT
    (32) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . STRING empty
    (21) type -> . ID empty

    CLASS           shift and go to state 10
    VARS            shift and go to state 11
    VOID            shift and go to state 15
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    STRING          shift and go to state 20
    ID              shift and go to state 5

    class                          shift and go to state 7
    programT                       shift and go to state 22
    vars                           shift and go to state 8
    programF                       shift and go to state 9
    func                           shift and go to state 12
    main                           shift and go to state 13
    type                           shift and go to state 14

state 8

    (3) programT -> vars . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . type funcT
    (25) func -> . VOID funcT
    (32) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . STRING empty
    (21) type -> . ID empty

    VOID            shift and go to state 15
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    STRING          shift and go to state 20
    ID              shift and go to state 5

    programF                       shift and go to state 23
    func                           shift and go to state 12
    main                           shift and go to state 13
    type                           shift and go to state 14

state 9

    (4) programT -> programF .

    $end            reduce using rule 4 (programT -> programF .)


state 10

    (7) class -> CLASS . ID classT

    ID              shift and go to state 24


state 11

    (11) vars -> VARS . dec empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 26

    dec                            shift and go to state 25

state 12

    (5) programF -> func . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . type funcT
    (25) func -> . VOID funcT
    (32) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . STRING empty
    (21) type -> . ID empty

    VOID            shift and go to state 15
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    STRING          shift and go to state 20
    ID              shift and go to state 5

    func                           shift and go to state 12
    programF                       shift and go to state 27
    main                           shift and go to state 13
    type                           shift and go to state 14

state 13

    (6) programF -> main . empty
    (108) empty -> .

    $end            reduce using rule 108 (empty -> .)

    empty                          shift and go to state 28

state 14

    (24) func -> type . funcT
    (26) funcT -> . FUNCTION ID L_PAR funcF

    FUNCTION        shift and go to state 30

    funcT                          shift and go to state 29

state 15

    (25) func -> VOID . funcT
    (26) funcT -> . FUNCTION ID L_PAR funcF

    FUNCTION        shift and go to state 30

    funcT                          shift and go to state 31

state 16

    (32) main -> MAIN . L_PAR R_PAR L_CURPAR statement R_CURPAR empty

    L_PAR           shift and go to state 32


state 17

    (17) type -> INT . empty
    (108) empty -> .

    FUNCTION        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 33

state 18

    (18) type -> FLOAT . empty
    (108) empty -> .

    FUNCTION        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 34

state 19

    (19) type -> CHAR . empty
    (108) empty -> .

    FUNCTION        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 35

state 20

    (20) type -> STRING . empty
    (108) empty -> .

    FUNCTION        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 36

state 21

    (21) type -> ID empty .

    FUNCTION        reduce using rule 21 (type -> ID empty .)
    SEMICOLON       reduce using rule 21 (type -> ID empty .)


state 22

    (2) programT -> class programT .

    $end            reduce using rule 2 (programT -> class programT .)


state 23

    (3) programT -> vars programF .

    $end            reduce using rule 3 (programT -> vars programF .)


state 24

    (7) class -> CLASS ID . classT
    (8) classT -> . LESS INHERIT ID GREATER classF
    (9) classT -> . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    LESS            shift and go to state 38
    SEMICOLON       shift and go to state 40

    classT                         shift and go to state 37
    classF                         shift and go to state 39

state 25

    (11) vars -> VARS dec . empty
    (108) empty -> .

    VOID            reduce using rule 108 (empty -> .)
    MAIN            reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    CHAR            reduce using rule 108 (empty -> .)
    STRING          reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 41

state 26

    (12) dec -> VAR . arr decF
    (13) dec -> VAR . decF
    (22) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> . L_BREAK CTE_INT R_BREAK empty
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type SEMICOLON dec
    (16) decF -> . COLON type SEMICOLON empty

    L_BREAK         shift and go to state 44
    COMMA           shift and go to state 45
    COLON           shift and go to state 46

    arr                            shift and go to state 42
    decF                           shift and go to state 43

state 27

    (5) programF -> func programF .

    $end            reduce using rule 5 (programF -> func programF .)


state 28

    (6) programF -> main empty .

    $end            reduce using rule 6 (programF -> main empty .)


state 29

    (24) func -> type funcT .

    VOID            reduce using rule 24 (func -> type funcT .)
    MAIN            reduce using rule 24 (func -> type funcT .)
    INT             reduce using rule 24 (func -> type funcT .)
    FLOAT           reduce using rule 24 (func -> type funcT .)
    CHAR            reduce using rule 24 (func -> type funcT .)
    STRING          reduce using rule 24 (func -> type funcT .)
    ID              reduce using rule 24 (func -> type funcT .)
    R_CURPAR        reduce using rule 24 (func -> type funcT .)


state 30

    (26) funcT -> FUNCTION . ID L_PAR funcF

    ID              shift and go to state 47


state 31

    (25) func -> VOID funcT .

    VOID            reduce using rule 25 (func -> VOID funcT .)
    MAIN            reduce using rule 25 (func -> VOID funcT .)
    INT             reduce using rule 25 (func -> VOID funcT .)
    FLOAT           reduce using rule 25 (func -> VOID funcT .)
    CHAR            reduce using rule 25 (func -> VOID funcT .)
    STRING          reduce using rule 25 (func -> VOID funcT .)
    ID              reduce using rule 25 (func -> VOID funcT .)
    R_CURPAR        reduce using rule 25 (func -> VOID funcT .)


state 32

    (32) main -> MAIN L_PAR . R_PAR L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 48


state 33

    (17) type -> INT empty .

    FUNCTION        reduce using rule 17 (type -> INT empty .)
    SEMICOLON       reduce using rule 17 (type -> INT empty .)


state 34

    (18) type -> FLOAT empty .

    FUNCTION        reduce using rule 18 (type -> FLOAT empty .)
    SEMICOLON       reduce using rule 18 (type -> FLOAT empty .)


state 35

    (19) type -> CHAR empty .

    FUNCTION        reduce using rule 19 (type -> CHAR empty .)
    SEMICOLON       reduce using rule 19 (type -> CHAR empty .)


state 36

    (20) type -> STRING empty .

    FUNCTION        reduce using rule 20 (type -> STRING empty .)
    SEMICOLON       reduce using rule 20 (type -> STRING empty .)


state 37

    (7) class -> CLASS ID classT .

    CLASS           reduce using rule 7 (class -> CLASS ID classT .)
    VARS            reduce using rule 7 (class -> CLASS ID classT .)
    VOID            reduce using rule 7 (class -> CLASS ID classT .)
    MAIN            reduce using rule 7 (class -> CLASS ID classT .)
    INT             reduce using rule 7 (class -> CLASS ID classT .)
    FLOAT           reduce using rule 7 (class -> CLASS ID classT .)
    CHAR            reduce using rule 7 (class -> CLASS ID classT .)
    STRING          reduce using rule 7 (class -> CLASS ID classT .)
    ID              reduce using rule 7 (class -> CLASS ID classT .)


state 38

    (8) classT -> LESS . INHERIT ID GREATER classF

    INHERIT         shift and go to state 49


state 39

    (9) classT -> classF .

    CLASS           reduce using rule 9 (classT -> classF .)
    VARS            reduce using rule 9 (classT -> classF .)
    VOID            reduce using rule 9 (classT -> classF .)
    MAIN            reduce using rule 9 (classT -> classF .)
    INT             reduce using rule 9 (classT -> classF .)
    FLOAT           reduce using rule 9 (classT -> classF .)
    CHAR            reduce using rule 9 (classT -> classF .)
    STRING          reduce using rule 9 (classT -> classF .)
    ID              reduce using rule 9 (classT -> classF .)


state 40

    (10) classF -> SEMICOLON . L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    L_CURPAR        shift and go to state 50


state 41

    (11) vars -> VARS dec empty .

    VOID            reduce using rule 11 (vars -> VARS dec empty .)
    MAIN            reduce using rule 11 (vars -> VARS dec empty .)
    INT             reduce using rule 11 (vars -> VARS dec empty .)
    FLOAT           reduce using rule 11 (vars -> VARS dec empty .)
    CHAR            reduce using rule 11 (vars -> VARS dec empty .)
    STRING          reduce using rule 11 (vars -> VARS dec empty .)
    ID              reduce using rule 11 (vars -> VARS dec empty .)


state 42

    (12) dec -> VAR arr . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type SEMICOLON dec
    (16) decF -> . COLON type SEMICOLON empty

    COMMA           shift and go to state 45
    COLON           shift and go to state 46

    decF                           shift and go to state 51

state 43

    (13) dec -> VAR decF .

    VOID            reduce using rule 13 (dec -> VAR decF .)
    MAIN            reduce using rule 13 (dec -> VAR decF .)
    INT             reduce using rule 13 (dec -> VAR decF .)
    FLOAT           reduce using rule 13 (dec -> VAR decF .)
    CHAR            reduce using rule 13 (dec -> VAR decF .)
    STRING          reduce using rule 13 (dec -> VAR decF .)
    ID              reduce using rule 13 (dec -> VAR decF .)
    METHODS         reduce using rule 13 (dec -> VAR decF .)
    L_CURPAR        reduce using rule 13 (dec -> VAR decF .)


state 44

    (22) arr -> L_BREAK . CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 52


state 45

    (14) decF -> COMMA . dec
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 26

    dec                            shift and go to state 53

state 46

    (15) decF -> COLON . type SEMICOLON dec
    (16) decF -> COLON . type SEMICOLON empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . STRING empty
    (21) type -> . ID empty

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    STRING          shift and go to state 20
    ID              shift and go to state 5

    type                           shift and go to state 54

state 47

    (26) funcT -> FUNCTION ID . L_PAR funcF

    L_PAR           shift and go to state 55


state 48

    (32) main -> MAIN L_PAR R_PAR . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 56


state 49

    (8) classT -> LESS INHERIT . ID GREATER classF

    ID              shift and go to state 57


state 50

    (10) classF -> SEMICOLON L_CURPAR . ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    ATTRIBUTES      shift and go to state 58


state 51

    (12) dec -> VAR arr decF .

    VOID            reduce using rule 12 (dec -> VAR arr decF .)
    MAIN            reduce using rule 12 (dec -> VAR arr decF .)
    INT             reduce using rule 12 (dec -> VAR arr decF .)
    FLOAT           reduce using rule 12 (dec -> VAR arr decF .)
    CHAR            reduce using rule 12 (dec -> VAR arr decF .)
    STRING          reduce using rule 12 (dec -> VAR arr decF .)
    ID              reduce using rule 12 (dec -> VAR arr decF .)
    METHODS         reduce using rule 12 (dec -> VAR arr decF .)
    L_CURPAR        reduce using rule 12 (dec -> VAR arr decF .)


state 52

    (22) arr -> L_BREAK CTE_INT . COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK CTE_INT . R_BREAK empty

    COMMA           shift and go to state 59
    R_BREAK         shift and go to state 60


state 53

    (14) decF -> COMMA dec .

    VOID            reduce using rule 14 (decF -> COMMA dec .)
    MAIN            reduce using rule 14 (decF -> COMMA dec .)
    INT             reduce using rule 14 (decF -> COMMA dec .)
    FLOAT           reduce using rule 14 (decF -> COMMA dec .)
    CHAR            reduce using rule 14 (decF -> COMMA dec .)
    STRING          reduce using rule 14 (decF -> COMMA dec .)
    ID              reduce using rule 14 (decF -> COMMA dec .)
    METHODS         reduce using rule 14 (decF -> COMMA dec .)
    L_CURPAR        reduce using rule 14 (decF -> COMMA dec .)


state 54

    (15) decF -> COLON type . SEMICOLON dec
    (16) decF -> COLON type . SEMICOLON empty

    SEMICOLON       shift and go to state 61


state 55

    (26) funcT -> FUNCTION ID L_PAR . funcF
    (27) funcF -> . parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (28) funcF -> . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (29) parameter -> . VAR COLON type SEMICOLON parameterF

    R_PAR           shift and go to state 64
    VAR             shift and go to state 65

    funcF                          shift and go to state 62
    parameter                      shift and go to state 63

state 56

    (32) main -> MAIN L_PAR R_PAR L_CURPAR . statement R_CURPAR empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    statement                      shift and go to state 66
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 57

    (8) classT -> LESS INHERIT ID . GREATER classF

    GREATER         shift and go to state 85


state 58

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES . dec METHODS func R_CURPAR SEMICOLON empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 26

    dec                            shift and go to state 86

state 59

    (22) arr -> L_BREAK CTE_INT COMMA . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 87


state 60

    (23) arr -> L_BREAK CTE_INT R_BREAK . empty
    (108) empty -> .

    COMMA           reduce using rule 108 (empty -> .)
    COLON           reduce using rule 108 (empty -> .)
    L_PAR           reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    CTE_INT         reduce using rule 108 (empty -> .)
    CTE_FLOAT       reduce using rule 108 (empty -> .)
    CTE_STRING      reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 88

state 61

    (15) decF -> COLON type SEMICOLON . dec
    (16) decF -> COLON type SEMICOLON . empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF
    (108) empty -> .

    VAR             shift and go to state 26
    VOID            reduce using rule 108 (empty -> .)
    MAIN            reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    CHAR            reduce using rule 108 (empty -> .)
    STRING          reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    METHODS         reduce using rule 108 (empty -> .)
    L_CURPAR        reduce using rule 108 (empty -> .)

    dec                            shift and go to state 89
    empty                          shift and go to state 90

state 62

    (26) funcT -> FUNCTION ID L_PAR funcF .

    VOID            reduce using rule 26 (funcT -> FUNCTION ID L_PAR funcF .)
    MAIN            reduce using rule 26 (funcT -> FUNCTION ID L_PAR funcF .)
    INT             reduce using rule 26 (funcT -> FUNCTION ID L_PAR funcF .)
    FLOAT           reduce using rule 26 (funcT -> FUNCTION ID L_PAR funcF .)
    CHAR            reduce using rule 26 (funcT -> FUNCTION ID L_PAR funcF .)
    STRING          reduce using rule 26 (funcT -> FUNCTION ID L_PAR funcF .)
    ID              reduce using rule 26 (funcT -> FUNCTION ID L_PAR funcF .)
    R_CURPAR        reduce using rule 26 (funcT -> FUNCTION ID L_PAR funcF .)


state 63

    (27) funcF -> parameter . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 91


state 64

    (28) funcF -> R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 92


state 65

    (29) parameter -> VAR . COLON type SEMICOLON parameterF

    COLON           shift and go to state 93


state 66

    (32) main -> MAIN L_PAR R_PAR L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 94


state 67

    (33) statement -> assigment . statementF
    (40) statementF -> . statement
    (41) statementF -> . empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (108) empty -> .
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    assigment                      shift and go to state 67
    statementF                     shift and go to state 95
    statement                      shift and go to state 96
    empty                          shift and go to state 97
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 68

    (34) statement -> void . statementF
    (40) statementF -> . statement
    (41) statementF -> . empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (108) empty -> .
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    void                           shift and go to state 68
    statementF                     shift and go to state 98
    statement                      shift and go to state 96
    empty                          shift and go to state 97
    assigment                      shift and go to state 67
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 69

    (35) statement -> return . statementF
    (40) statementF -> . statement
    (41) statementF -> . empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (108) empty -> .
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    return                         shift and go to state 69
    statementF                     shift and go to state 99
    statement                      shift and go to state 96
    empty                          shift and go to state 97
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 70

    (36) statement -> read . statementF
    (40) statementF -> . statement
    (41) statementF -> . empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (108) empty -> .
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    read                           shift and go to state 70
    statementF                     shift and go to state 100
    statement                      shift and go to state 96
    empty                          shift and go to state 97
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 71

    (37) statement -> write . statementF
    (40) statementF -> . statement
    (41) statementF -> . empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (108) empty -> .
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    write                          shift and go to state 71
    statementF                     shift and go to state 101
    statement                      shift and go to state 96
    empty                          shift and go to state 97
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 72

    (38) statement -> if . statementF
    (40) statementF -> . statement
    (41) statementF -> . empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (108) empty -> .
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    if                             shift and go to state 72
    statementF                     shift and go to state 102
    statement                      shift and go to state 96
    empty                          shift and go to state 97
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 73

    (39) statement -> repeat . statementF
    (40) statementF -> . statement
    (41) statementF -> . empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (108) empty -> .
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    repeat                         shift and go to state 73
    statementF                     shift and go to state 103
    statement                      shift and go to state 96
    empty                          shift and go to state 97
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 74

    (67) assigment -> var . assigmentF
    (68) assigmentF -> . EQUAL exp empty
    (69) assigmentF -> . ope exp empty
    (70) ope -> . PLUS_EQ empty
    (71) ope -> . MIN_EQ empty
    (72) ope -> . MULT_EQ empty
    (73) ope -> . DIV_EQ empty

    EQUAL           shift and go to state 105
    PLUS_EQ         shift and go to state 107
    MIN_EQ          shift and go to state 108
    MULT_EQ         shift and go to state 109
    DIV_EQ          shift and go to state 110

    assigmentF                     shift and go to state 104
    ope                            shift and go to state 106

state 75

    (42) void -> ID . DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> ID . L_PAR param R_PAR SEMICOLON empty
    (51) var -> ID . DOT VAR varF

    DOT             shift and go to state 111
    L_PAR           shift and go to state 112


state 76

    (49) return -> RETURN . L_PAR exp R_PAR SEMICOLON empty

    L_PAR           shift and go to state 113


state 77

    (54) read -> READ . L_PAR readF

    L_PAR           shift and go to state 114


state 78

    (57) write -> WRITE . L_PAR writeT

    L_PAR           shift and go to state 115


state 79

    (64) if -> IF . L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_PAR           shift and go to state 116


state 80

    (62) repeat -> conditional . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 117

state 81

    (63) repeat -> nonconditional . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 118

state 82

    (50) var -> VAR . varF
    (52) varF -> . arrfunc empty
    (53) varF -> . empty
    (44) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (45) arrfunc -> . L_BREAK exp R_BREAK empty
    (108) empty -> .

    L_BREAK         shift and go to state 122
    EQUAL           reduce using rule 108 (empty -> .)
    PLUS_EQ         reduce using rule 108 (empty -> .)
    MIN_EQ          reduce using rule 108 (empty -> .)
    MULT_EQ         reduce using rule 108 (empty -> .)
    DIV_EQ          reduce using rule 108 (empty -> .)
    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    varF                           shift and go to state 119
    arrfunc                        shift and go to state 120
    empty                          shift and go to state 121

state 83

    (74) conditional -> WHILE . L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    L_PAR           shift and go to state 123


state 84

    (75) nonconditional -> FROM . VAR arr nonconditionalF
    (76) nonconditional -> FROM . VAR nonconditionalF

    VAR             shift and go to state 124


state 85

    (8) classT -> LESS INHERIT ID GREATER . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    SEMICOLON       shift and go to state 40

    classF                         shift and go to state 125

state 86

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec . METHODS func R_CURPAR SEMICOLON empty

    METHODS         shift and go to state 126


state 87

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT . R_BREAK empty

    R_BREAK         shift and go to state 127


state 88

    (23) arr -> L_BREAK CTE_INT R_BREAK empty .

    COMMA           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    COLON           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    L_PAR           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    PLUS            reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    MINUS           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    CTE_INT         reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    CTE_FLOAT       reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    CTE_STRING      reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    VAR             reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    ID              reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)


state 89

    (15) decF -> COLON type SEMICOLON dec .

    VOID            reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    MAIN            reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    INT             reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    FLOAT           reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    CHAR            reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    STRING          reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    ID              reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    METHODS         reduce using rule 15 (decF -> COLON type SEMICOLON dec .)
    L_CURPAR        reduce using rule 15 (decF -> COLON type SEMICOLON dec .)


state 90

    (16) decF -> COLON type SEMICOLON empty .

    VOID            reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    MAIN            reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    INT             reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    FLOAT           reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    CHAR            reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    STRING          reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    ID              reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    METHODS         reduce using rule 16 (decF -> COLON type SEMICOLON empty .)
    L_CURPAR        reduce using rule 16 (decF -> COLON type SEMICOLON empty .)


state 91

    (27) funcF -> parameter R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 128


state 92

    (28) funcF -> R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 26

    dec                            shift and go to state 129

state 93

    (29) parameter -> VAR COLON . type SEMICOLON parameterF
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . STRING empty
    (21) type -> . ID empty

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    STRING          shift and go to state 20
    ID              shift and go to state 5

    type                           shift and go to state 130

state 94

    (32) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR . empty
    (108) empty -> .

    $end            reduce using rule 108 (empty -> .)

    empty                          shift and go to state 131

state 95

    (33) statement -> assigment statementF .

    R_CURPAR        reduce using rule 33 (statement -> assigment statementF .)
    SEMICOLON       reduce using rule 33 (statement -> assigment statementF .)


state 96

    (40) statementF -> statement .

    R_CURPAR        reduce using rule 40 (statementF -> statement .)
    SEMICOLON       reduce using rule 40 (statementF -> statement .)


state 97

    (41) statementF -> empty .

    R_CURPAR        reduce using rule 41 (statementF -> empty .)
    SEMICOLON       reduce using rule 41 (statementF -> empty .)


state 98

    (34) statement -> void statementF .

    R_CURPAR        reduce using rule 34 (statement -> void statementF .)
    SEMICOLON       reduce using rule 34 (statement -> void statementF .)


state 99

    (35) statement -> return statementF .

    R_CURPAR        reduce using rule 35 (statement -> return statementF .)
    SEMICOLON       reduce using rule 35 (statement -> return statementF .)


state 100

    (36) statement -> read statementF .

    R_CURPAR        reduce using rule 36 (statement -> read statementF .)
    SEMICOLON       reduce using rule 36 (statement -> read statementF .)


state 101

    (37) statement -> write statementF .

    R_CURPAR        reduce using rule 37 (statement -> write statementF .)
    SEMICOLON       reduce using rule 37 (statement -> write statementF .)


state 102

    (38) statement -> if statementF .

    R_CURPAR        reduce using rule 38 (statement -> if statementF .)
    SEMICOLON       reduce using rule 38 (statement -> if statementF .)


state 103

    (39) statement -> repeat statementF .

    R_CURPAR        reduce using rule 39 (statement -> repeat statementF .)
    SEMICOLON       reduce using rule 39 (statement -> repeat statementF .)


state 104

    (67) assigment -> var assigmentF .

    ID              reduce using rule 67 (assigment -> var assigmentF .)
    RETURN          reduce using rule 67 (assigment -> var assigmentF .)
    READ            reduce using rule 67 (assigment -> var assigmentF .)
    WRITE           reduce using rule 67 (assigment -> var assigmentF .)
    IF              reduce using rule 67 (assigment -> var assigmentF .)
    VAR             reduce using rule 67 (assigment -> var assigmentF .)
    WHILE           reduce using rule 67 (assigment -> var assigmentF .)
    FROM            reduce using rule 67 (assigment -> var assigmentF .)
    R_CURPAR        reduce using rule 67 (assigment -> var assigmentF .)
    SEMICOLON       reduce using rule 67 (assigment -> var assigmentF .)


state 105

    (68) assigmentF -> EQUAL . exp empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 132
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 106

    (69) assigmentF -> ope . exp empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 147
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 107

    (70) ope -> PLUS_EQ . empty
    (108) empty -> .

    L_PAR           reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    CTE_INT         reduce using rule 108 (empty -> .)
    CTE_FLOAT       reduce using rule 108 (empty -> .)
    CTE_STRING      reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 148

state 108

    (71) ope -> MIN_EQ . empty
    (108) empty -> .

    L_PAR           reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    CTE_INT         reduce using rule 108 (empty -> .)
    CTE_FLOAT       reduce using rule 108 (empty -> .)
    CTE_STRING      reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 149

state 109

    (72) ope -> MULT_EQ . empty
    (108) empty -> .

    L_PAR           reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    CTE_INT         reduce using rule 108 (empty -> .)
    CTE_FLOAT       reduce using rule 108 (empty -> .)
    CTE_STRING      reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 150

state 110

    (73) ope -> DIV_EQ . empty
    (108) empty -> .

    L_PAR           reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    CTE_INT         reduce using rule 108 (empty -> .)
    CTE_FLOAT       reduce using rule 108 (empty -> .)
    CTE_STRING      reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 151

state 111

    (42) void -> ID DOT . ID L_PAR param R_PAR SEMICOLON empty
    (51) var -> ID DOT . VAR varF

    ID              shift and go to state 152
    VAR             shift and go to state 153


state 112

    (43) void -> ID L_PAR . param R_PAR SEMICOLON empty
    (46) param -> . var paramF
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    VAR             shift and go to state 82
    ID              shift and go to state 146

    param                          shift and go to state 154
    var                            shift and go to state 155

state 113

    (49) return -> RETURN L_PAR . exp R_PAR SEMICOLON empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 156
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 114

    (54) read -> READ L_PAR . readF
    (55) readF -> . var COMMA readF
    (56) readF -> . var R_PAR SEMICOLON empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    VAR             shift and go to state 82
    ID              shift and go to state 146

    readF                          shift and go to state 157
    var                            shift and go to state 158

state 115

    (57) write -> WRITE L_PAR . writeT
    (58) writeT -> . CTE_STRING writeF
    (59) writeT -> . exp writeF
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 160
    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    VAR             shift and go to state 82
    ID              shift and go to state 146

    writeT                         shift and go to state 159
    exp                            shift and go to state 161
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 116

    (64) if -> IF L_PAR . exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 162
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 117

    (62) repeat -> conditional empty .

    ID              reduce using rule 62 (repeat -> conditional empty .)
    RETURN          reduce using rule 62 (repeat -> conditional empty .)
    READ            reduce using rule 62 (repeat -> conditional empty .)
    WRITE           reduce using rule 62 (repeat -> conditional empty .)
    IF              reduce using rule 62 (repeat -> conditional empty .)
    VAR             reduce using rule 62 (repeat -> conditional empty .)
    WHILE           reduce using rule 62 (repeat -> conditional empty .)
    FROM            reduce using rule 62 (repeat -> conditional empty .)
    R_CURPAR        reduce using rule 62 (repeat -> conditional empty .)
    SEMICOLON       reduce using rule 62 (repeat -> conditional empty .)


state 118

    (63) repeat -> nonconditional empty .

    ID              reduce using rule 63 (repeat -> nonconditional empty .)
    RETURN          reduce using rule 63 (repeat -> nonconditional empty .)
    READ            reduce using rule 63 (repeat -> nonconditional empty .)
    WRITE           reduce using rule 63 (repeat -> nonconditional empty .)
    IF              reduce using rule 63 (repeat -> nonconditional empty .)
    VAR             reduce using rule 63 (repeat -> nonconditional empty .)
    WHILE           reduce using rule 63 (repeat -> nonconditional empty .)
    FROM            reduce using rule 63 (repeat -> nonconditional empty .)
    R_CURPAR        reduce using rule 63 (repeat -> nonconditional empty .)
    SEMICOLON       reduce using rule 63 (repeat -> nonconditional empty .)


state 119

    (50) var -> VAR varF .

    EQUAL           reduce using rule 50 (var -> VAR varF .)
    PLUS_EQ         reduce using rule 50 (var -> VAR varF .)
    MIN_EQ          reduce using rule 50 (var -> VAR varF .)
    MULT_EQ         reduce using rule 50 (var -> VAR varF .)
    DIV_EQ          reduce using rule 50 (var -> VAR varF .)
    MULT            reduce using rule 50 (var -> VAR varF .)
    DIV             reduce using rule 50 (var -> VAR varF .)
    PLUS            reduce using rule 50 (var -> VAR varF .)
    MINUS           reduce using rule 50 (var -> VAR varF .)
    LESS            reduce using rule 50 (var -> VAR varF .)
    GREATER         reduce using rule 50 (var -> VAR varF .)
    LESS_TH         reduce using rule 50 (var -> VAR varF .)
    GREAT_TH        reduce using rule 50 (var -> VAR varF .)
    SAME            reduce using rule 50 (var -> VAR varF .)
    DIF             reduce using rule 50 (var -> VAR varF .)
    ID              reduce using rule 50 (var -> VAR varF .)
    RETURN          reduce using rule 50 (var -> VAR varF .)
    READ            reduce using rule 50 (var -> VAR varF .)
    WRITE           reduce using rule 50 (var -> VAR varF .)
    IF              reduce using rule 50 (var -> VAR varF .)
    VAR             reduce using rule 50 (var -> VAR varF .)
    WHILE           reduce using rule 50 (var -> VAR varF .)
    FROM            reduce using rule 50 (var -> VAR varF .)
    R_CURPAR        reduce using rule 50 (var -> VAR varF .)
    SEMICOLON       reduce using rule 50 (var -> VAR varF .)
    COMMA           reduce using rule 50 (var -> VAR varF .)
    R_PAR           reduce using rule 50 (var -> VAR varF .)
    R_BREAK         reduce using rule 50 (var -> VAR varF .)
    TO              reduce using rule 50 (var -> VAR varF .)
    OR              reduce using rule 50 (var -> VAR varF .)
    AND             reduce using rule 50 (var -> VAR varF .)
    DO              reduce using rule 50 (var -> VAR varF .)


state 120

    (52) varF -> arrfunc . empty
    (108) empty -> .

    EQUAL           reduce using rule 108 (empty -> .)
    PLUS_EQ         reduce using rule 108 (empty -> .)
    MIN_EQ          reduce using rule 108 (empty -> .)
    MULT_EQ         reduce using rule 108 (empty -> .)
    DIV_EQ          reduce using rule 108 (empty -> .)
    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 163

state 121

    (53) varF -> empty .

    EQUAL           reduce using rule 53 (varF -> empty .)
    PLUS_EQ         reduce using rule 53 (varF -> empty .)
    MIN_EQ          reduce using rule 53 (varF -> empty .)
    MULT_EQ         reduce using rule 53 (varF -> empty .)
    DIV_EQ          reduce using rule 53 (varF -> empty .)
    MULT            reduce using rule 53 (varF -> empty .)
    DIV             reduce using rule 53 (varF -> empty .)
    PLUS            reduce using rule 53 (varF -> empty .)
    MINUS           reduce using rule 53 (varF -> empty .)
    LESS            reduce using rule 53 (varF -> empty .)
    GREATER         reduce using rule 53 (varF -> empty .)
    LESS_TH         reduce using rule 53 (varF -> empty .)
    GREAT_TH        reduce using rule 53 (varF -> empty .)
    SAME            reduce using rule 53 (varF -> empty .)
    DIF             reduce using rule 53 (varF -> empty .)
    ID              reduce using rule 53 (varF -> empty .)
    RETURN          reduce using rule 53 (varF -> empty .)
    READ            reduce using rule 53 (varF -> empty .)
    WRITE           reduce using rule 53 (varF -> empty .)
    IF              reduce using rule 53 (varF -> empty .)
    VAR             reduce using rule 53 (varF -> empty .)
    WHILE           reduce using rule 53 (varF -> empty .)
    FROM            reduce using rule 53 (varF -> empty .)
    R_CURPAR        reduce using rule 53 (varF -> empty .)
    SEMICOLON       reduce using rule 53 (varF -> empty .)
    COMMA           reduce using rule 53 (varF -> empty .)
    R_PAR           reduce using rule 53 (varF -> empty .)
    R_BREAK         reduce using rule 53 (varF -> empty .)
    TO              reduce using rule 53 (varF -> empty .)
    OR              reduce using rule 53 (varF -> empty .)
    AND             reduce using rule 53 (varF -> empty .)
    DO              reduce using rule 53 (varF -> empty .)


state 122

    (44) arrfunc -> L_BREAK . exp COMMA exp R_BREAK empty
    (45) arrfunc -> L_BREAK . exp R_BREAK empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 164
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 123

    (74) conditional -> WHILE L_PAR . exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 165
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 124

    (75) nonconditional -> FROM VAR . arr nonconditionalF
    (76) nonconditional -> FROM VAR . nonconditionalF
    (22) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> . L_BREAK CTE_INT R_BREAK empty
    (77) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_BREAK         shift and go to state 44
    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    arr                            shift and go to state 166
    nonconditionalF                shift and go to state 167
    exp                            shift and go to state 168
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 125

    (8) classT -> LESS INHERIT ID GREATER classF .

    CLASS           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VARS            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VOID            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    MAIN            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    INT             reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    FLOAT           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    CHAR            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    STRING          reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    ID              reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)


state 126

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS . func R_CURPAR SEMICOLON empty
    (24) func -> . type funcT
    (25) func -> . VOID funcT
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . STRING empty
    (21) type -> . ID empty

    VOID            shift and go to state 15
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    STRING          shift and go to state 20
    ID              shift and go to state 5

    func                           shift and go to state 169
    type                           shift and go to state 14

state 127

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK . empty
    (108) empty -> .

    COMMA           reduce using rule 108 (empty -> .)
    COLON           reduce using rule 108 (empty -> .)
    L_PAR           reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    CTE_INT         reduce using rule 108 (empty -> .)
    CTE_FLOAT       reduce using rule 108 (empty -> .)
    CTE_STRING      reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 170

state 128

    (27) funcF -> parameter R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr decF
    (13) dec -> . VAR decF

    VAR             shift and go to state 26

    dec                            shift and go to state 171

state 129

    (28) funcF -> R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 172


state 130

    (29) parameter -> VAR COLON type . SEMICOLON parameterF

    SEMICOLON       shift and go to state 173


state 131

    (32) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .

    $end            reduce using rule 32 (main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .)


state 132

    (68) assigmentF -> EQUAL exp . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 174

state 133

    (80) exp -> ex . expT
    (81) expT -> . LESS expf
    (82) expT -> . GREATER expf
    (83) expT -> . LESS_TH expf
    (84) expT -> . GREAT_TH expf
    (85) expT -> . SAME expf
    (86) expT -> . DIF expf
    (87) expT -> . empty
    (108) empty -> .

    LESS            shift and go to state 176
    GREATER         shift and go to state 177
    LESS_TH         shift and go to state 178
    GREAT_TH        shift and go to state 179
    SAME            shift and go to state 180
    DIF             shift and go to state 181
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    expT                           shift and go to state 175
    empty                          shift and go to state 182

state 134

    (90) ex -> term . exF
    (91) exF -> . PLUS ex
    (92) exF -> . MINUS ex
    (93) exF -> . empty
    (108) empty -> .

    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    exF                            shift and go to state 183
    empty                          shift and go to state 186

state 135

    (94) term -> factor . termF
    (95) termF -> . MULT term
    (96) termF -> . DIV term
    (97) termF -> . empty
    (108) empty -> .

    MULT            shift and go to state 188
    DIV             shift and go to state 189
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    termF                          shift and go to state 187
    empty                          shift and go to state 190

state 136

    (98) factor -> L_PAR . exp R_PAR empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 191
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 137

    (99) factor -> factorT .

    MULT            reduce using rule 99 (factor -> factorT .)
    DIV             reduce using rule 99 (factor -> factorT .)
    PLUS            reduce using rule 99 (factor -> factorT .)
    MINUS           reduce using rule 99 (factor -> factorT .)
    LESS            reduce using rule 99 (factor -> factorT .)
    GREATER         reduce using rule 99 (factor -> factorT .)
    LESS_TH         reduce using rule 99 (factor -> factorT .)
    GREAT_TH        reduce using rule 99 (factor -> factorT .)
    SAME            reduce using rule 99 (factor -> factorT .)
    DIF             reduce using rule 99 (factor -> factorT .)
    ID              reduce using rule 99 (factor -> factorT .)
    RETURN          reduce using rule 99 (factor -> factorT .)
    READ            reduce using rule 99 (factor -> factorT .)
    WRITE           reduce using rule 99 (factor -> factorT .)
    IF              reduce using rule 99 (factor -> factorT .)
    VAR             reduce using rule 99 (factor -> factorT .)
    WHILE           reduce using rule 99 (factor -> factorT .)
    FROM            reduce using rule 99 (factor -> factorT .)
    R_CURPAR        reduce using rule 99 (factor -> factorT .)
    SEMICOLON       reduce using rule 99 (factor -> factorT .)
    R_PAR           reduce using rule 99 (factor -> factorT .)
    COMMA           reduce using rule 99 (factor -> factorT .)
    R_BREAK         reduce using rule 99 (factor -> factorT .)
    TO              reduce using rule 99 (factor -> factorT .)
    OR              reduce using rule 99 (factor -> factorT .)
    AND             reduce using rule 99 (factor -> factorT .)
    DO              reduce using rule 99 (factor -> factorT .)


state 138

    (100) factorT -> PLUS . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    factorF                        shift and go to state 192
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 139

    (102) factorT -> factorF .

    MULT            reduce using rule 102 (factorT -> factorF .)
    DIV             reduce using rule 102 (factorT -> factorF .)
    PLUS            reduce using rule 102 (factorT -> factorF .)
    MINUS           reduce using rule 102 (factorT -> factorF .)
    LESS            reduce using rule 102 (factorT -> factorF .)
    GREATER         reduce using rule 102 (factorT -> factorF .)
    LESS_TH         reduce using rule 102 (factorT -> factorF .)
    GREAT_TH        reduce using rule 102 (factorT -> factorF .)
    SAME            reduce using rule 102 (factorT -> factorF .)
    DIF             reduce using rule 102 (factorT -> factorF .)
    ID              reduce using rule 102 (factorT -> factorF .)
    RETURN          reduce using rule 102 (factorT -> factorF .)
    READ            reduce using rule 102 (factorT -> factorF .)
    WRITE           reduce using rule 102 (factorT -> factorF .)
    IF              reduce using rule 102 (factorT -> factorF .)
    VAR             reduce using rule 102 (factorT -> factorF .)
    WHILE           reduce using rule 102 (factorT -> factorF .)
    FROM            reduce using rule 102 (factorT -> factorF .)
    R_CURPAR        reduce using rule 102 (factorT -> factorF .)
    SEMICOLON       reduce using rule 102 (factorT -> factorF .)
    R_PAR           reduce using rule 102 (factorT -> factorF .)
    COMMA           reduce using rule 102 (factorT -> factorF .)
    R_BREAK         reduce using rule 102 (factorT -> factorF .)
    TO              reduce using rule 102 (factorT -> factorF .)
    OR              reduce using rule 102 (factorT -> factorF .)
    AND             reduce using rule 102 (factorT -> factorF .)
    DO              reduce using rule 102 (factorT -> factorF .)


state 140

    (101) factorT -> MINUS . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    factorF                        shift and go to state 193
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 141

    (103) factorF -> varcte . empty
    (108) empty -> .

    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 194

state 142

    (104) varcte -> var . empty
    (108) empty -> .

    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 195

state 143

    (105) varcte -> CTE_INT . empty
    (108) empty -> .

    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 196

state 144

    (106) varcte -> CTE_FLOAT . empty
    (108) empty -> .

    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 197

state 145

    (107) varcte -> CTE_STRING . empty
    (108) empty -> .

    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 198

state 146

    (51) var -> ID . DOT VAR varF

    DOT             shift and go to state 199


state 147

    (69) assigmentF -> ope exp . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 200

state 148

    (70) ope -> PLUS_EQ empty .

    L_PAR           reduce using rule 70 (ope -> PLUS_EQ empty .)
    PLUS            reduce using rule 70 (ope -> PLUS_EQ empty .)
    MINUS           reduce using rule 70 (ope -> PLUS_EQ empty .)
    CTE_INT         reduce using rule 70 (ope -> PLUS_EQ empty .)
    CTE_FLOAT       reduce using rule 70 (ope -> PLUS_EQ empty .)
    CTE_STRING      reduce using rule 70 (ope -> PLUS_EQ empty .)
    VAR             reduce using rule 70 (ope -> PLUS_EQ empty .)
    ID              reduce using rule 70 (ope -> PLUS_EQ empty .)


state 149

    (71) ope -> MIN_EQ empty .

    L_PAR           reduce using rule 71 (ope -> MIN_EQ empty .)
    PLUS            reduce using rule 71 (ope -> MIN_EQ empty .)
    MINUS           reduce using rule 71 (ope -> MIN_EQ empty .)
    CTE_INT         reduce using rule 71 (ope -> MIN_EQ empty .)
    CTE_FLOAT       reduce using rule 71 (ope -> MIN_EQ empty .)
    CTE_STRING      reduce using rule 71 (ope -> MIN_EQ empty .)
    VAR             reduce using rule 71 (ope -> MIN_EQ empty .)
    ID              reduce using rule 71 (ope -> MIN_EQ empty .)


state 150

    (72) ope -> MULT_EQ empty .

    L_PAR           reduce using rule 72 (ope -> MULT_EQ empty .)
    PLUS            reduce using rule 72 (ope -> MULT_EQ empty .)
    MINUS           reduce using rule 72 (ope -> MULT_EQ empty .)
    CTE_INT         reduce using rule 72 (ope -> MULT_EQ empty .)
    CTE_FLOAT       reduce using rule 72 (ope -> MULT_EQ empty .)
    CTE_STRING      reduce using rule 72 (ope -> MULT_EQ empty .)
    VAR             reduce using rule 72 (ope -> MULT_EQ empty .)
    ID              reduce using rule 72 (ope -> MULT_EQ empty .)


state 151

    (73) ope -> DIV_EQ empty .

    L_PAR           reduce using rule 73 (ope -> DIV_EQ empty .)
    PLUS            reduce using rule 73 (ope -> DIV_EQ empty .)
    MINUS           reduce using rule 73 (ope -> DIV_EQ empty .)
    CTE_INT         reduce using rule 73 (ope -> DIV_EQ empty .)
    CTE_FLOAT       reduce using rule 73 (ope -> DIV_EQ empty .)
    CTE_STRING      reduce using rule 73 (ope -> DIV_EQ empty .)
    VAR             reduce using rule 73 (ope -> DIV_EQ empty .)
    ID              reduce using rule 73 (ope -> DIV_EQ empty .)


state 152

    (42) void -> ID DOT ID . L_PAR param R_PAR SEMICOLON empty

    L_PAR           shift and go to state 201


state 153

    (51) var -> ID DOT VAR . varF
    (52) varF -> . arrfunc empty
    (53) varF -> . empty
    (44) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (45) arrfunc -> . L_BREAK exp R_BREAK empty
    (108) empty -> .

    L_BREAK         shift and go to state 122
    EQUAL           reduce using rule 108 (empty -> .)
    PLUS_EQ         reduce using rule 108 (empty -> .)
    MIN_EQ          reduce using rule 108 (empty -> .)
    MULT_EQ         reduce using rule 108 (empty -> .)
    DIV_EQ          reduce using rule 108 (empty -> .)
    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    varF                           shift and go to state 202
    arrfunc                        shift and go to state 120
    empty                          shift and go to state 121

state 154

    (43) void -> ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 203


state 155

    (46) param -> var . paramF
    (47) paramF -> . COMMA param
    (48) paramF -> . empty
    (108) empty -> .

    COMMA           shift and go to state 205
    R_PAR           reduce using rule 108 (empty -> .)

    paramF                         shift and go to state 204
    empty                          shift and go to state 206

state 156

    (49) return -> RETURN L_PAR exp . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 207


state 157

    (54) read -> READ L_PAR readF .

    ID              reduce using rule 54 (read -> READ L_PAR readF .)
    RETURN          reduce using rule 54 (read -> READ L_PAR readF .)
    READ            reduce using rule 54 (read -> READ L_PAR readF .)
    WRITE           reduce using rule 54 (read -> READ L_PAR readF .)
    IF              reduce using rule 54 (read -> READ L_PAR readF .)
    VAR             reduce using rule 54 (read -> READ L_PAR readF .)
    WHILE           reduce using rule 54 (read -> READ L_PAR readF .)
    FROM            reduce using rule 54 (read -> READ L_PAR readF .)
    R_CURPAR        reduce using rule 54 (read -> READ L_PAR readF .)
    SEMICOLON       reduce using rule 54 (read -> READ L_PAR readF .)


state 158

    (55) readF -> var . COMMA readF
    (56) readF -> var . R_PAR SEMICOLON empty

    COMMA           shift and go to state 208
    R_PAR           shift and go to state 209


state 159

    (57) write -> WRITE L_PAR writeT .

    ID              reduce using rule 57 (write -> WRITE L_PAR writeT .)
    RETURN          reduce using rule 57 (write -> WRITE L_PAR writeT .)
    READ            reduce using rule 57 (write -> WRITE L_PAR writeT .)
    WRITE           reduce using rule 57 (write -> WRITE L_PAR writeT .)
    IF              reduce using rule 57 (write -> WRITE L_PAR writeT .)
    VAR             reduce using rule 57 (write -> WRITE L_PAR writeT .)
    WHILE           reduce using rule 57 (write -> WRITE L_PAR writeT .)
    FROM            reduce using rule 57 (write -> WRITE L_PAR writeT .)
    R_CURPAR        reduce using rule 57 (write -> WRITE L_PAR writeT .)
    SEMICOLON       reduce using rule 57 (write -> WRITE L_PAR writeT .)


state 160

    (58) writeT -> CTE_STRING . writeF
    (107) varcte -> CTE_STRING . empty
    (60) writeF -> . COMMA writeT
    (61) writeF -> . R_PAR SEMICOLON empty
    (108) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for R_PAR resolved as shift
    COMMA           shift and go to state 211
    R_PAR           shift and go to state 212
    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)

  ! COMMA           [ reduce using rule 108 (empty -> .) ]
  ! R_PAR           [ reduce using rule 108 (empty -> .) ]

    writeF                         shift and go to state 210
    empty                          shift and go to state 198

state 161

    (59) writeT -> exp . writeF
    (60) writeF -> . COMMA writeT
    (61) writeF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 211
    R_PAR           shift and go to state 212

    writeF                         shift and go to state 213

state 162

    (64) if -> IF L_PAR exp . R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    R_PAR           shift and go to state 214


state 163

    (52) varF -> arrfunc empty .

    EQUAL           reduce using rule 52 (varF -> arrfunc empty .)
    PLUS_EQ         reduce using rule 52 (varF -> arrfunc empty .)
    MIN_EQ          reduce using rule 52 (varF -> arrfunc empty .)
    MULT_EQ         reduce using rule 52 (varF -> arrfunc empty .)
    DIV_EQ          reduce using rule 52 (varF -> arrfunc empty .)
    MULT            reduce using rule 52 (varF -> arrfunc empty .)
    DIV             reduce using rule 52 (varF -> arrfunc empty .)
    PLUS            reduce using rule 52 (varF -> arrfunc empty .)
    MINUS           reduce using rule 52 (varF -> arrfunc empty .)
    LESS            reduce using rule 52 (varF -> arrfunc empty .)
    GREATER         reduce using rule 52 (varF -> arrfunc empty .)
    LESS_TH         reduce using rule 52 (varF -> arrfunc empty .)
    GREAT_TH        reduce using rule 52 (varF -> arrfunc empty .)
    SAME            reduce using rule 52 (varF -> arrfunc empty .)
    DIF             reduce using rule 52 (varF -> arrfunc empty .)
    ID              reduce using rule 52 (varF -> arrfunc empty .)
    RETURN          reduce using rule 52 (varF -> arrfunc empty .)
    READ            reduce using rule 52 (varF -> arrfunc empty .)
    WRITE           reduce using rule 52 (varF -> arrfunc empty .)
    IF              reduce using rule 52 (varF -> arrfunc empty .)
    VAR             reduce using rule 52 (varF -> arrfunc empty .)
    WHILE           reduce using rule 52 (varF -> arrfunc empty .)
    FROM            reduce using rule 52 (varF -> arrfunc empty .)
    R_CURPAR        reduce using rule 52 (varF -> arrfunc empty .)
    SEMICOLON       reduce using rule 52 (varF -> arrfunc empty .)
    COMMA           reduce using rule 52 (varF -> arrfunc empty .)
    R_PAR           reduce using rule 52 (varF -> arrfunc empty .)
    R_BREAK         reduce using rule 52 (varF -> arrfunc empty .)
    TO              reduce using rule 52 (varF -> arrfunc empty .)
    OR              reduce using rule 52 (varF -> arrfunc empty .)
    AND             reduce using rule 52 (varF -> arrfunc empty .)
    DO              reduce using rule 52 (varF -> arrfunc empty .)


state 164

    (44) arrfunc -> L_BREAK exp . COMMA exp R_BREAK empty
    (45) arrfunc -> L_BREAK exp . R_BREAK empty

    COMMA           shift and go to state 215
    R_BREAK         shift and go to state 216


state 165

    (74) conditional -> WHILE L_PAR exp . R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    R_PAR           shift and go to state 217


state 166

    (75) nonconditional -> FROM VAR arr . nonconditionalF
    (77) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    nonconditionalF                shift and go to state 218
    exp                            shift and go to state 168
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 167

    (76) nonconditional -> FROM VAR nonconditionalF .

    ID              reduce using rule 76 (nonconditional -> FROM VAR nonconditionalF .)
    RETURN          reduce using rule 76 (nonconditional -> FROM VAR nonconditionalF .)
    READ            reduce using rule 76 (nonconditional -> FROM VAR nonconditionalF .)
    WRITE           reduce using rule 76 (nonconditional -> FROM VAR nonconditionalF .)
    IF              reduce using rule 76 (nonconditional -> FROM VAR nonconditionalF .)
    VAR             reduce using rule 76 (nonconditional -> FROM VAR nonconditionalF .)
    WHILE           reduce using rule 76 (nonconditional -> FROM VAR nonconditionalF .)
    FROM            reduce using rule 76 (nonconditional -> FROM VAR nonconditionalF .)
    R_CURPAR        reduce using rule 76 (nonconditional -> FROM VAR nonconditionalF .)
    SEMICOLON       reduce using rule 76 (nonconditional -> FROM VAR nonconditionalF .)


state 168

    (77) nonconditionalF -> exp . TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty

    TO              shift and go to state 219


state 169

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func . R_CURPAR SEMICOLON empty

    R_CURPAR        shift and go to state 220


state 170

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .

    COMMA           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    COLON           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    L_PAR           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    PLUS            reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    MINUS           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    CTE_INT         reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    CTE_FLOAT       reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    CTE_STRING      reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    VAR             reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    ID              reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)


state 171

    (27) funcF -> parameter R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 221


state 172

    (28) funcF -> R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    statement                      shift and go to state 222
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 173

    (29) parameter -> VAR COLON type SEMICOLON . parameterF
    (30) parameterF -> . parameter
    (31) parameterF -> . empty
    (29) parameter -> . VAR COLON type SEMICOLON parameterF
    (108) empty -> .

    VAR             shift and go to state 65
    R_PAR           reduce using rule 108 (empty -> .)

    parameterF                     shift and go to state 223
    parameter                      shift and go to state 224
    empty                          shift and go to state 225

state 174

    (68) assigmentF -> EQUAL exp empty .

    ID              reduce using rule 68 (assigmentF -> EQUAL exp empty .)
    RETURN          reduce using rule 68 (assigmentF -> EQUAL exp empty .)
    READ            reduce using rule 68 (assigmentF -> EQUAL exp empty .)
    WRITE           reduce using rule 68 (assigmentF -> EQUAL exp empty .)
    IF              reduce using rule 68 (assigmentF -> EQUAL exp empty .)
    VAR             reduce using rule 68 (assigmentF -> EQUAL exp empty .)
    WHILE           reduce using rule 68 (assigmentF -> EQUAL exp empty .)
    FROM            reduce using rule 68 (assigmentF -> EQUAL exp empty .)
    R_CURPAR        reduce using rule 68 (assigmentF -> EQUAL exp empty .)
    SEMICOLON       reduce using rule 68 (assigmentF -> EQUAL exp empty .)


state 175

    (80) exp -> ex expT .

    ID              reduce using rule 80 (exp -> ex expT .)
    RETURN          reduce using rule 80 (exp -> ex expT .)
    READ            reduce using rule 80 (exp -> ex expT .)
    WRITE           reduce using rule 80 (exp -> ex expT .)
    IF              reduce using rule 80 (exp -> ex expT .)
    VAR             reduce using rule 80 (exp -> ex expT .)
    WHILE           reduce using rule 80 (exp -> ex expT .)
    FROM            reduce using rule 80 (exp -> ex expT .)
    R_CURPAR        reduce using rule 80 (exp -> ex expT .)
    SEMICOLON       reduce using rule 80 (exp -> ex expT .)
    R_PAR           reduce using rule 80 (exp -> ex expT .)
    COMMA           reduce using rule 80 (exp -> ex expT .)
    R_BREAK         reduce using rule 80 (exp -> ex expT .)
    TO              reduce using rule 80 (exp -> ex expT .)
    DO              reduce using rule 80 (exp -> ex expT .)


state 176

    (81) expT -> LESS . expf
    (88) expf -> . ex empty
    (89) expf -> . ex bool empty
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    expf                           shift and go to state 226
    ex                             shift and go to state 227
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 177

    (82) expT -> GREATER . expf
    (88) expf -> . ex empty
    (89) expf -> . ex bool empty
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    expf                           shift and go to state 228
    ex                             shift and go to state 227
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 178

    (83) expT -> LESS_TH . expf
    (88) expf -> . ex empty
    (89) expf -> . ex bool empty
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    expf                           shift and go to state 229
    ex                             shift and go to state 227
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 179

    (84) expT -> GREAT_TH . expf
    (88) expf -> . ex empty
    (89) expf -> . ex bool empty
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    expf                           shift and go to state 230
    ex                             shift and go to state 227
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 180

    (85) expT -> SAME . expf
    (88) expf -> . ex empty
    (89) expf -> . ex bool empty
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    expf                           shift and go to state 231
    ex                             shift and go to state 227
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 181

    (86) expT -> DIF . expf
    (88) expf -> . ex empty
    (89) expf -> . ex bool empty
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    expf                           shift and go to state 232
    ex                             shift and go to state 227
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 182

    (87) expT -> empty .

    ID              reduce using rule 87 (expT -> empty .)
    RETURN          reduce using rule 87 (expT -> empty .)
    READ            reduce using rule 87 (expT -> empty .)
    WRITE           reduce using rule 87 (expT -> empty .)
    IF              reduce using rule 87 (expT -> empty .)
    VAR             reduce using rule 87 (expT -> empty .)
    WHILE           reduce using rule 87 (expT -> empty .)
    FROM            reduce using rule 87 (expT -> empty .)
    R_CURPAR        reduce using rule 87 (expT -> empty .)
    SEMICOLON       reduce using rule 87 (expT -> empty .)
    R_PAR           reduce using rule 87 (expT -> empty .)
    COMMA           reduce using rule 87 (expT -> empty .)
    R_BREAK         reduce using rule 87 (expT -> empty .)
    TO              reduce using rule 87 (expT -> empty .)
    DO              reduce using rule 87 (expT -> empty .)


state 183

    (90) ex -> term exF .

    LESS            reduce using rule 90 (ex -> term exF .)
    GREATER         reduce using rule 90 (ex -> term exF .)
    LESS_TH         reduce using rule 90 (ex -> term exF .)
    GREAT_TH        reduce using rule 90 (ex -> term exF .)
    SAME            reduce using rule 90 (ex -> term exF .)
    DIF             reduce using rule 90 (ex -> term exF .)
    ID              reduce using rule 90 (ex -> term exF .)
    RETURN          reduce using rule 90 (ex -> term exF .)
    READ            reduce using rule 90 (ex -> term exF .)
    WRITE           reduce using rule 90 (ex -> term exF .)
    IF              reduce using rule 90 (ex -> term exF .)
    VAR             reduce using rule 90 (ex -> term exF .)
    WHILE           reduce using rule 90 (ex -> term exF .)
    FROM            reduce using rule 90 (ex -> term exF .)
    R_CURPAR        reduce using rule 90 (ex -> term exF .)
    SEMICOLON       reduce using rule 90 (ex -> term exF .)
    R_PAR           reduce using rule 90 (ex -> term exF .)
    COMMA           reduce using rule 90 (ex -> term exF .)
    R_BREAK         reduce using rule 90 (ex -> term exF .)
    TO              reduce using rule 90 (ex -> term exF .)
    OR              reduce using rule 90 (ex -> term exF .)
    AND             reduce using rule 90 (ex -> term exF .)
    DO              reduce using rule 90 (ex -> term exF .)


state 184

    (91) exF -> PLUS . ex
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    ex                             shift and go to state 233
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 185

    (92) exF -> MINUS . ex
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    ex                             shift and go to state 234
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 186

    (93) exF -> empty .

    LESS            reduce using rule 93 (exF -> empty .)
    GREATER         reduce using rule 93 (exF -> empty .)
    LESS_TH         reduce using rule 93 (exF -> empty .)
    GREAT_TH        reduce using rule 93 (exF -> empty .)
    SAME            reduce using rule 93 (exF -> empty .)
    DIF             reduce using rule 93 (exF -> empty .)
    ID              reduce using rule 93 (exF -> empty .)
    RETURN          reduce using rule 93 (exF -> empty .)
    READ            reduce using rule 93 (exF -> empty .)
    WRITE           reduce using rule 93 (exF -> empty .)
    IF              reduce using rule 93 (exF -> empty .)
    VAR             reduce using rule 93 (exF -> empty .)
    WHILE           reduce using rule 93 (exF -> empty .)
    FROM            reduce using rule 93 (exF -> empty .)
    R_CURPAR        reduce using rule 93 (exF -> empty .)
    SEMICOLON       reduce using rule 93 (exF -> empty .)
    R_PAR           reduce using rule 93 (exF -> empty .)
    COMMA           reduce using rule 93 (exF -> empty .)
    R_BREAK         reduce using rule 93 (exF -> empty .)
    TO              reduce using rule 93 (exF -> empty .)
    OR              reduce using rule 93 (exF -> empty .)
    AND             reduce using rule 93 (exF -> empty .)
    DO              reduce using rule 93 (exF -> empty .)


state 187

    (94) term -> factor termF .

    PLUS            reduce using rule 94 (term -> factor termF .)
    MINUS           reduce using rule 94 (term -> factor termF .)
    LESS            reduce using rule 94 (term -> factor termF .)
    GREATER         reduce using rule 94 (term -> factor termF .)
    LESS_TH         reduce using rule 94 (term -> factor termF .)
    GREAT_TH        reduce using rule 94 (term -> factor termF .)
    SAME            reduce using rule 94 (term -> factor termF .)
    DIF             reduce using rule 94 (term -> factor termF .)
    ID              reduce using rule 94 (term -> factor termF .)
    RETURN          reduce using rule 94 (term -> factor termF .)
    READ            reduce using rule 94 (term -> factor termF .)
    WRITE           reduce using rule 94 (term -> factor termF .)
    IF              reduce using rule 94 (term -> factor termF .)
    VAR             reduce using rule 94 (term -> factor termF .)
    WHILE           reduce using rule 94 (term -> factor termF .)
    FROM            reduce using rule 94 (term -> factor termF .)
    R_CURPAR        reduce using rule 94 (term -> factor termF .)
    SEMICOLON       reduce using rule 94 (term -> factor termF .)
    R_PAR           reduce using rule 94 (term -> factor termF .)
    COMMA           reduce using rule 94 (term -> factor termF .)
    R_BREAK         reduce using rule 94 (term -> factor termF .)
    TO              reduce using rule 94 (term -> factor termF .)
    OR              reduce using rule 94 (term -> factor termF .)
    AND             reduce using rule 94 (term -> factor termF .)
    DO              reduce using rule 94 (term -> factor termF .)


state 188

    (95) termF -> MULT . term
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    term                           shift and go to state 235
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 189

    (96) termF -> DIV . term
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    term                           shift and go to state 236
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 190

    (97) termF -> empty .

    PLUS            reduce using rule 97 (termF -> empty .)
    MINUS           reduce using rule 97 (termF -> empty .)
    LESS            reduce using rule 97 (termF -> empty .)
    GREATER         reduce using rule 97 (termF -> empty .)
    LESS_TH         reduce using rule 97 (termF -> empty .)
    GREAT_TH        reduce using rule 97 (termF -> empty .)
    SAME            reduce using rule 97 (termF -> empty .)
    DIF             reduce using rule 97 (termF -> empty .)
    ID              reduce using rule 97 (termF -> empty .)
    RETURN          reduce using rule 97 (termF -> empty .)
    READ            reduce using rule 97 (termF -> empty .)
    WRITE           reduce using rule 97 (termF -> empty .)
    IF              reduce using rule 97 (termF -> empty .)
    VAR             reduce using rule 97 (termF -> empty .)
    WHILE           reduce using rule 97 (termF -> empty .)
    FROM            reduce using rule 97 (termF -> empty .)
    R_CURPAR        reduce using rule 97 (termF -> empty .)
    SEMICOLON       reduce using rule 97 (termF -> empty .)
    R_PAR           reduce using rule 97 (termF -> empty .)
    COMMA           reduce using rule 97 (termF -> empty .)
    R_BREAK         reduce using rule 97 (termF -> empty .)
    TO              reduce using rule 97 (termF -> empty .)
    OR              reduce using rule 97 (termF -> empty .)
    AND             reduce using rule 97 (termF -> empty .)
    DO              reduce using rule 97 (termF -> empty .)


state 191

    (98) factor -> L_PAR exp . R_PAR empty

    R_PAR           shift and go to state 237


state 192

    (100) factorT -> PLUS factorF .

    MULT            reduce using rule 100 (factorT -> PLUS factorF .)
    DIV             reduce using rule 100 (factorT -> PLUS factorF .)
    PLUS            reduce using rule 100 (factorT -> PLUS factorF .)
    MINUS           reduce using rule 100 (factorT -> PLUS factorF .)
    LESS            reduce using rule 100 (factorT -> PLUS factorF .)
    GREATER         reduce using rule 100 (factorT -> PLUS factorF .)
    LESS_TH         reduce using rule 100 (factorT -> PLUS factorF .)
    GREAT_TH        reduce using rule 100 (factorT -> PLUS factorF .)
    SAME            reduce using rule 100 (factorT -> PLUS factorF .)
    DIF             reduce using rule 100 (factorT -> PLUS factorF .)
    ID              reduce using rule 100 (factorT -> PLUS factorF .)
    RETURN          reduce using rule 100 (factorT -> PLUS factorF .)
    READ            reduce using rule 100 (factorT -> PLUS factorF .)
    WRITE           reduce using rule 100 (factorT -> PLUS factorF .)
    IF              reduce using rule 100 (factorT -> PLUS factorF .)
    VAR             reduce using rule 100 (factorT -> PLUS factorF .)
    WHILE           reduce using rule 100 (factorT -> PLUS factorF .)
    FROM            reduce using rule 100 (factorT -> PLUS factorF .)
    R_CURPAR        reduce using rule 100 (factorT -> PLUS factorF .)
    SEMICOLON       reduce using rule 100 (factorT -> PLUS factorF .)
    R_PAR           reduce using rule 100 (factorT -> PLUS factorF .)
    COMMA           reduce using rule 100 (factorT -> PLUS factorF .)
    R_BREAK         reduce using rule 100 (factorT -> PLUS factorF .)
    TO              reduce using rule 100 (factorT -> PLUS factorF .)
    OR              reduce using rule 100 (factorT -> PLUS factorF .)
    AND             reduce using rule 100 (factorT -> PLUS factorF .)
    DO              reduce using rule 100 (factorT -> PLUS factorF .)


state 193

    (101) factorT -> MINUS factorF .

    MULT            reduce using rule 101 (factorT -> MINUS factorF .)
    DIV             reduce using rule 101 (factorT -> MINUS factorF .)
    PLUS            reduce using rule 101 (factorT -> MINUS factorF .)
    MINUS           reduce using rule 101 (factorT -> MINUS factorF .)
    LESS            reduce using rule 101 (factorT -> MINUS factorF .)
    GREATER         reduce using rule 101 (factorT -> MINUS factorF .)
    LESS_TH         reduce using rule 101 (factorT -> MINUS factorF .)
    GREAT_TH        reduce using rule 101 (factorT -> MINUS factorF .)
    SAME            reduce using rule 101 (factorT -> MINUS factorF .)
    DIF             reduce using rule 101 (factorT -> MINUS factorF .)
    ID              reduce using rule 101 (factorT -> MINUS factorF .)
    RETURN          reduce using rule 101 (factorT -> MINUS factorF .)
    READ            reduce using rule 101 (factorT -> MINUS factorF .)
    WRITE           reduce using rule 101 (factorT -> MINUS factorF .)
    IF              reduce using rule 101 (factorT -> MINUS factorF .)
    VAR             reduce using rule 101 (factorT -> MINUS factorF .)
    WHILE           reduce using rule 101 (factorT -> MINUS factorF .)
    FROM            reduce using rule 101 (factorT -> MINUS factorF .)
    R_CURPAR        reduce using rule 101 (factorT -> MINUS factorF .)
    SEMICOLON       reduce using rule 101 (factorT -> MINUS factorF .)
    R_PAR           reduce using rule 101 (factorT -> MINUS factorF .)
    COMMA           reduce using rule 101 (factorT -> MINUS factorF .)
    R_BREAK         reduce using rule 101 (factorT -> MINUS factorF .)
    TO              reduce using rule 101 (factorT -> MINUS factorF .)
    OR              reduce using rule 101 (factorT -> MINUS factorF .)
    AND             reduce using rule 101 (factorT -> MINUS factorF .)
    DO              reduce using rule 101 (factorT -> MINUS factorF .)


state 194

    (103) factorF -> varcte empty .

    MULT            reduce using rule 103 (factorF -> varcte empty .)
    DIV             reduce using rule 103 (factorF -> varcte empty .)
    PLUS            reduce using rule 103 (factorF -> varcte empty .)
    MINUS           reduce using rule 103 (factorF -> varcte empty .)
    LESS            reduce using rule 103 (factorF -> varcte empty .)
    GREATER         reduce using rule 103 (factorF -> varcte empty .)
    LESS_TH         reduce using rule 103 (factorF -> varcte empty .)
    GREAT_TH        reduce using rule 103 (factorF -> varcte empty .)
    SAME            reduce using rule 103 (factorF -> varcte empty .)
    DIF             reduce using rule 103 (factorF -> varcte empty .)
    ID              reduce using rule 103 (factorF -> varcte empty .)
    RETURN          reduce using rule 103 (factorF -> varcte empty .)
    READ            reduce using rule 103 (factorF -> varcte empty .)
    WRITE           reduce using rule 103 (factorF -> varcte empty .)
    IF              reduce using rule 103 (factorF -> varcte empty .)
    VAR             reduce using rule 103 (factorF -> varcte empty .)
    WHILE           reduce using rule 103 (factorF -> varcte empty .)
    FROM            reduce using rule 103 (factorF -> varcte empty .)
    R_CURPAR        reduce using rule 103 (factorF -> varcte empty .)
    SEMICOLON       reduce using rule 103 (factorF -> varcte empty .)
    R_PAR           reduce using rule 103 (factorF -> varcte empty .)
    COMMA           reduce using rule 103 (factorF -> varcte empty .)
    R_BREAK         reduce using rule 103 (factorF -> varcte empty .)
    TO              reduce using rule 103 (factorF -> varcte empty .)
    OR              reduce using rule 103 (factorF -> varcte empty .)
    AND             reduce using rule 103 (factorF -> varcte empty .)
    DO              reduce using rule 103 (factorF -> varcte empty .)


state 195

    (104) varcte -> var empty .

    MULT            reduce using rule 104 (varcte -> var empty .)
    DIV             reduce using rule 104 (varcte -> var empty .)
    PLUS            reduce using rule 104 (varcte -> var empty .)
    MINUS           reduce using rule 104 (varcte -> var empty .)
    LESS            reduce using rule 104 (varcte -> var empty .)
    GREATER         reduce using rule 104 (varcte -> var empty .)
    LESS_TH         reduce using rule 104 (varcte -> var empty .)
    GREAT_TH        reduce using rule 104 (varcte -> var empty .)
    SAME            reduce using rule 104 (varcte -> var empty .)
    DIF             reduce using rule 104 (varcte -> var empty .)
    ID              reduce using rule 104 (varcte -> var empty .)
    RETURN          reduce using rule 104 (varcte -> var empty .)
    READ            reduce using rule 104 (varcte -> var empty .)
    WRITE           reduce using rule 104 (varcte -> var empty .)
    IF              reduce using rule 104 (varcte -> var empty .)
    VAR             reduce using rule 104 (varcte -> var empty .)
    WHILE           reduce using rule 104 (varcte -> var empty .)
    FROM            reduce using rule 104 (varcte -> var empty .)
    R_CURPAR        reduce using rule 104 (varcte -> var empty .)
    SEMICOLON       reduce using rule 104 (varcte -> var empty .)
    R_PAR           reduce using rule 104 (varcte -> var empty .)
    COMMA           reduce using rule 104 (varcte -> var empty .)
    R_BREAK         reduce using rule 104 (varcte -> var empty .)
    TO              reduce using rule 104 (varcte -> var empty .)
    OR              reduce using rule 104 (varcte -> var empty .)
    AND             reduce using rule 104 (varcte -> var empty .)
    DO              reduce using rule 104 (varcte -> var empty .)


state 196

    (105) varcte -> CTE_INT empty .

    MULT            reduce using rule 105 (varcte -> CTE_INT empty .)
    DIV             reduce using rule 105 (varcte -> CTE_INT empty .)
    PLUS            reduce using rule 105 (varcte -> CTE_INT empty .)
    MINUS           reduce using rule 105 (varcte -> CTE_INT empty .)
    LESS            reduce using rule 105 (varcte -> CTE_INT empty .)
    GREATER         reduce using rule 105 (varcte -> CTE_INT empty .)
    LESS_TH         reduce using rule 105 (varcte -> CTE_INT empty .)
    GREAT_TH        reduce using rule 105 (varcte -> CTE_INT empty .)
    SAME            reduce using rule 105 (varcte -> CTE_INT empty .)
    DIF             reduce using rule 105 (varcte -> CTE_INT empty .)
    ID              reduce using rule 105 (varcte -> CTE_INT empty .)
    RETURN          reduce using rule 105 (varcte -> CTE_INT empty .)
    READ            reduce using rule 105 (varcte -> CTE_INT empty .)
    WRITE           reduce using rule 105 (varcte -> CTE_INT empty .)
    IF              reduce using rule 105 (varcte -> CTE_INT empty .)
    VAR             reduce using rule 105 (varcte -> CTE_INT empty .)
    WHILE           reduce using rule 105 (varcte -> CTE_INT empty .)
    FROM            reduce using rule 105 (varcte -> CTE_INT empty .)
    R_CURPAR        reduce using rule 105 (varcte -> CTE_INT empty .)
    SEMICOLON       reduce using rule 105 (varcte -> CTE_INT empty .)
    R_PAR           reduce using rule 105 (varcte -> CTE_INT empty .)
    COMMA           reduce using rule 105 (varcte -> CTE_INT empty .)
    R_BREAK         reduce using rule 105 (varcte -> CTE_INT empty .)
    TO              reduce using rule 105 (varcte -> CTE_INT empty .)
    OR              reduce using rule 105 (varcte -> CTE_INT empty .)
    AND             reduce using rule 105 (varcte -> CTE_INT empty .)
    DO              reduce using rule 105 (varcte -> CTE_INT empty .)


state 197

    (106) varcte -> CTE_FLOAT empty .

    MULT            reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    DIV             reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    PLUS            reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    MINUS           reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    LESS            reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    GREATER         reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    LESS_TH         reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    GREAT_TH        reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    SAME            reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    DIF             reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    ID              reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    RETURN          reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    READ            reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    WRITE           reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    IF              reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    VAR             reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    WHILE           reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    FROM            reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    R_CURPAR        reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    SEMICOLON       reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    R_PAR           reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    COMMA           reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    R_BREAK         reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    TO              reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    OR              reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    AND             reduce using rule 106 (varcte -> CTE_FLOAT empty .)
    DO              reduce using rule 106 (varcte -> CTE_FLOAT empty .)


state 198

    (107) varcte -> CTE_STRING empty .

    MULT            reduce using rule 107 (varcte -> CTE_STRING empty .)
    DIV             reduce using rule 107 (varcte -> CTE_STRING empty .)
    PLUS            reduce using rule 107 (varcte -> CTE_STRING empty .)
    MINUS           reduce using rule 107 (varcte -> CTE_STRING empty .)
    LESS            reduce using rule 107 (varcte -> CTE_STRING empty .)
    GREATER         reduce using rule 107 (varcte -> CTE_STRING empty .)
    LESS_TH         reduce using rule 107 (varcte -> CTE_STRING empty .)
    GREAT_TH        reduce using rule 107 (varcte -> CTE_STRING empty .)
    SAME            reduce using rule 107 (varcte -> CTE_STRING empty .)
    DIF             reduce using rule 107 (varcte -> CTE_STRING empty .)
    ID              reduce using rule 107 (varcte -> CTE_STRING empty .)
    RETURN          reduce using rule 107 (varcte -> CTE_STRING empty .)
    READ            reduce using rule 107 (varcte -> CTE_STRING empty .)
    WRITE           reduce using rule 107 (varcte -> CTE_STRING empty .)
    IF              reduce using rule 107 (varcte -> CTE_STRING empty .)
    VAR             reduce using rule 107 (varcte -> CTE_STRING empty .)
    WHILE           reduce using rule 107 (varcte -> CTE_STRING empty .)
    FROM            reduce using rule 107 (varcte -> CTE_STRING empty .)
    R_CURPAR        reduce using rule 107 (varcte -> CTE_STRING empty .)
    SEMICOLON       reduce using rule 107 (varcte -> CTE_STRING empty .)
    R_PAR           reduce using rule 107 (varcte -> CTE_STRING empty .)
    COMMA           reduce using rule 107 (varcte -> CTE_STRING empty .)
    R_BREAK         reduce using rule 107 (varcte -> CTE_STRING empty .)
    TO              reduce using rule 107 (varcte -> CTE_STRING empty .)
    OR              reduce using rule 107 (varcte -> CTE_STRING empty .)
    AND             reduce using rule 107 (varcte -> CTE_STRING empty .)
    DO              reduce using rule 107 (varcte -> CTE_STRING empty .)


state 199

    (51) var -> ID DOT . VAR varF

    VAR             shift and go to state 153


state 200

    (69) assigmentF -> ope exp empty .

    ID              reduce using rule 69 (assigmentF -> ope exp empty .)
    RETURN          reduce using rule 69 (assigmentF -> ope exp empty .)
    READ            reduce using rule 69 (assigmentF -> ope exp empty .)
    WRITE           reduce using rule 69 (assigmentF -> ope exp empty .)
    IF              reduce using rule 69 (assigmentF -> ope exp empty .)
    VAR             reduce using rule 69 (assigmentF -> ope exp empty .)
    WHILE           reduce using rule 69 (assigmentF -> ope exp empty .)
    FROM            reduce using rule 69 (assigmentF -> ope exp empty .)
    R_CURPAR        reduce using rule 69 (assigmentF -> ope exp empty .)
    SEMICOLON       reduce using rule 69 (assigmentF -> ope exp empty .)


state 201

    (42) void -> ID DOT ID L_PAR . param R_PAR SEMICOLON empty
    (46) param -> . var paramF
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    VAR             shift and go to state 82
    ID              shift and go to state 146

    param                          shift and go to state 238
    var                            shift and go to state 155

state 202

    (51) var -> ID DOT VAR varF .

    EQUAL           reduce using rule 51 (var -> ID DOT VAR varF .)
    PLUS_EQ         reduce using rule 51 (var -> ID DOT VAR varF .)
    MIN_EQ          reduce using rule 51 (var -> ID DOT VAR varF .)
    MULT_EQ         reduce using rule 51 (var -> ID DOT VAR varF .)
    DIV_EQ          reduce using rule 51 (var -> ID DOT VAR varF .)
    MULT            reduce using rule 51 (var -> ID DOT VAR varF .)
    DIV             reduce using rule 51 (var -> ID DOT VAR varF .)
    PLUS            reduce using rule 51 (var -> ID DOT VAR varF .)
    MINUS           reduce using rule 51 (var -> ID DOT VAR varF .)
    LESS            reduce using rule 51 (var -> ID DOT VAR varF .)
    GREATER         reduce using rule 51 (var -> ID DOT VAR varF .)
    LESS_TH         reduce using rule 51 (var -> ID DOT VAR varF .)
    GREAT_TH        reduce using rule 51 (var -> ID DOT VAR varF .)
    SAME            reduce using rule 51 (var -> ID DOT VAR varF .)
    DIF             reduce using rule 51 (var -> ID DOT VAR varF .)
    ID              reduce using rule 51 (var -> ID DOT VAR varF .)
    RETURN          reduce using rule 51 (var -> ID DOT VAR varF .)
    READ            reduce using rule 51 (var -> ID DOT VAR varF .)
    WRITE           reduce using rule 51 (var -> ID DOT VAR varF .)
    IF              reduce using rule 51 (var -> ID DOT VAR varF .)
    VAR             reduce using rule 51 (var -> ID DOT VAR varF .)
    WHILE           reduce using rule 51 (var -> ID DOT VAR varF .)
    FROM            reduce using rule 51 (var -> ID DOT VAR varF .)
    R_CURPAR        reduce using rule 51 (var -> ID DOT VAR varF .)
    SEMICOLON       reduce using rule 51 (var -> ID DOT VAR varF .)
    COMMA           reduce using rule 51 (var -> ID DOT VAR varF .)
    R_PAR           reduce using rule 51 (var -> ID DOT VAR varF .)
    R_BREAK         reduce using rule 51 (var -> ID DOT VAR varF .)
    TO              reduce using rule 51 (var -> ID DOT VAR varF .)
    OR              reduce using rule 51 (var -> ID DOT VAR varF .)
    AND             reduce using rule 51 (var -> ID DOT VAR varF .)
    DO              reduce using rule 51 (var -> ID DOT VAR varF .)


state 203

    (43) void -> ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 239


state 204

    (46) param -> var paramF .

    R_PAR           reduce using rule 46 (param -> var paramF .)


state 205

    (47) paramF -> COMMA . param
    (46) param -> . var paramF
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    VAR             shift and go to state 82
    ID              shift and go to state 146

    param                          shift and go to state 240
    var                            shift and go to state 155

state 206

    (48) paramF -> empty .

    R_PAR           reduce using rule 48 (paramF -> empty .)


state 207

    (49) return -> RETURN L_PAR exp R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 241


state 208

    (55) readF -> var COMMA . readF
    (55) readF -> . var COMMA readF
    (56) readF -> . var R_PAR SEMICOLON empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    VAR             shift and go to state 82
    ID              shift and go to state 146

    var                            shift and go to state 158
    readF                          shift and go to state 242

state 209

    (56) readF -> var R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 243


state 210

    (58) writeT -> CTE_STRING writeF .

    ID              reduce using rule 58 (writeT -> CTE_STRING writeF .)
    RETURN          reduce using rule 58 (writeT -> CTE_STRING writeF .)
    READ            reduce using rule 58 (writeT -> CTE_STRING writeF .)
    WRITE           reduce using rule 58 (writeT -> CTE_STRING writeF .)
    IF              reduce using rule 58 (writeT -> CTE_STRING writeF .)
    VAR             reduce using rule 58 (writeT -> CTE_STRING writeF .)
    WHILE           reduce using rule 58 (writeT -> CTE_STRING writeF .)
    FROM            reduce using rule 58 (writeT -> CTE_STRING writeF .)
    R_CURPAR        reduce using rule 58 (writeT -> CTE_STRING writeF .)
    SEMICOLON       reduce using rule 58 (writeT -> CTE_STRING writeF .)


state 211

    (60) writeF -> COMMA . writeT
    (58) writeT -> . CTE_STRING writeF
    (59) writeT -> . exp writeF
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 160
    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    VAR             shift and go to state 82
    ID              shift and go to state 146

    writeT                         shift and go to state 244
    exp                            shift and go to state 161
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 212

    (61) writeF -> R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 245


state 213

    (59) writeT -> exp writeF .

    ID              reduce using rule 59 (writeT -> exp writeF .)
    RETURN          reduce using rule 59 (writeT -> exp writeF .)
    READ            reduce using rule 59 (writeT -> exp writeF .)
    WRITE           reduce using rule 59 (writeT -> exp writeF .)
    IF              reduce using rule 59 (writeT -> exp writeF .)
    VAR             reduce using rule 59 (writeT -> exp writeF .)
    WHILE           reduce using rule 59 (writeT -> exp writeF .)
    FROM            reduce using rule 59 (writeT -> exp writeF .)
    R_CURPAR        reduce using rule 59 (writeT -> exp writeF .)
    SEMICOLON       reduce using rule 59 (writeT -> exp writeF .)


state 214

    (64) if -> IF L_PAR exp R_PAR . THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    THEN            shift and go to state 246


state 215

    (44) arrfunc -> L_BREAK exp COMMA . exp R_BREAK empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 247
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 216

    (45) arrfunc -> L_BREAK exp R_BREAK . empty
    (108) empty -> .

    EQUAL           reduce using rule 108 (empty -> .)
    PLUS_EQ         reduce using rule 108 (empty -> .)
    MIN_EQ          reduce using rule 108 (empty -> .)
    MULT_EQ         reduce using rule 108 (empty -> .)
    DIV_EQ          reduce using rule 108 (empty -> .)
    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 248

state 217

    (74) conditional -> WHILE L_PAR exp R_PAR . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 249


state 218

    (75) nonconditional -> FROM VAR arr nonconditionalF .

    ID              reduce using rule 75 (nonconditional -> FROM VAR arr nonconditionalF .)
    RETURN          reduce using rule 75 (nonconditional -> FROM VAR arr nonconditionalF .)
    READ            reduce using rule 75 (nonconditional -> FROM VAR arr nonconditionalF .)
    WRITE           reduce using rule 75 (nonconditional -> FROM VAR arr nonconditionalF .)
    IF              reduce using rule 75 (nonconditional -> FROM VAR arr nonconditionalF .)
    VAR             reduce using rule 75 (nonconditional -> FROM VAR arr nonconditionalF .)
    WHILE           reduce using rule 75 (nonconditional -> FROM VAR arr nonconditionalF .)
    FROM            reduce using rule 75 (nonconditional -> FROM VAR arr nonconditionalF .)
    R_CURPAR        reduce using rule 75 (nonconditional -> FROM VAR arr nonconditionalF .)
    SEMICOLON       reduce using rule 75 (nonconditional -> FROM VAR arr nonconditionalF .)


state 219

    (77) nonconditionalF -> exp TO . exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 250
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 220

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR . SEMICOLON empty

    SEMICOLON       shift and go to state 251


state 221

    (27) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    statement                      shift and go to state 252
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 222

    (28) funcF -> R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 253


state 223

    (29) parameter -> VAR COLON type SEMICOLON parameterF .

    R_PAR           reduce using rule 29 (parameter -> VAR COLON type SEMICOLON parameterF .)


state 224

    (30) parameterF -> parameter .

    R_PAR           reduce using rule 30 (parameterF -> parameter .)


state 225

    (31) parameterF -> empty .

    R_PAR           reduce using rule 31 (parameterF -> empty .)


state 226

    (81) expT -> LESS expf .

    ID              reduce using rule 81 (expT -> LESS expf .)
    RETURN          reduce using rule 81 (expT -> LESS expf .)
    READ            reduce using rule 81 (expT -> LESS expf .)
    WRITE           reduce using rule 81 (expT -> LESS expf .)
    IF              reduce using rule 81 (expT -> LESS expf .)
    VAR             reduce using rule 81 (expT -> LESS expf .)
    WHILE           reduce using rule 81 (expT -> LESS expf .)
    FROM            reduce using rule 81 (expT -> LESS expf .)
    R_CURPAR        reduce using rule 81 (expT -> LESS expf .)
    SEMICOLON       reduce using rule 81 (expT -> LESS expf .)
    R_PAR           reduce using rule 81 (expT -> LESS expf .)
    COMMA           reduce using rule 81 (expT -> LESS expf .)
    R_BREAK         reduce using rule 81 (expT -> LESS expf .)
    TO              reduce using rule 81 (expT -> LESS expf .)
    DO              reduce using rule 81 (expT -> LESS expf .)


state 227

    (88) expf -> ex . empty
    (89) expf -> ex . bool empty
    (108) empty -> .
    (78) bool -> . OR exp empty
    (79) bool -> . AND exp empty

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)
    OR              shift and go to state 256
    AND             shift and go to state 257

    empty                          shift and go to state 254
    bool                           shift and go to state 255

state 228

    (82) expT -> GREATER expf .

    ID              reduce using rule 82 (expT -> GREATER expf .)
    RETURN          reduce using rule 82 (expT -> GREATER expf .)
    READ            reduce using rule 82 (expT -> GREATER expf .)
    WRITE           reduce using rule 82 (expT -> GREATER expf .)
    IF              reduce using rule 82 (expT -> GREATER expf .)
    VAR             reduce using rule 82 (expT -> GREATER expf .)
    WHILE           reduce using rule 82 (expT -> GREATER expf .)
    FROM            reduce using rule 82 (expT -> GREATER expf .)
    R_CURPAR        reduce using rule 82 (expT -> GREATER expf .)
    SEMICOLON       reduce using rule 82 (expT -> GREATER expf .)
    R_PAR           reduce using rule 82 (expT -> GREATER expf .)
    COMMA           reduce using rule 82 (expT -> GREATER expf .)
    R_BREAK         reduce using rule 82 (expT -> GREATER expf .)
    TO              reduce using rule 82 (expT -> GREATER expf .)
    DO              reduce using rule 82 (expT -> GREATER expf .)


state 229

    (83) expT -> LESS_TH expf .

    ID              reduce using rule 83 (expT -> LESS_TH expf .)
    RETURN          reduce using rule 83 (expT -> LESS_TH expf .)
    READ            reduce using rule 83 (expT -> LESS_TH expf .)
    WRITE           reduce using rule 83 (expT -> LESS_TH expf .)
    IF              reduce using rule 83 (expT -> LESS_TH expf .)
    VAR             reduce using rule 83 (expT -> LESS_TH expf .)
    WHILE           reduce using rule 83 (expT -> LESS_TH expf .)
    FROM            reduce using rule 83 (expT -> LESS_TH expf .)
    R_CURPAR        reduce using rule 83 (expT -> LESS_TH expf .)
    SEMICOLON       reduce using rule 83 (expT -> LESS_TH expf .)
    R_PAR           reduce using rule 83 (expT -> LESS_TH expf .)
    COMMA           reduce using rule 83 (expT -> LESS_TH expf .)
    R_BREAK         reduce using rule 83 (expT -> LESS_TH expf .)
    TO              reduce using rule 83 (expT -> LESS_TH expf .)
    DO              reduce using rule 83 (expT -> LESS_TH expf .)


state 230

    (84) expT -> GREAT_TH expf .

    ID              reduce using rule 84 (expT -> GREAT_TH expf .)
    RETURN          reduce using rule 84 (expT -> GREAT_TH expf .)
    READ            reduce using rule 84 (expT -> GREAT_TH expf .)
    WRITE           reduce using rule 84 (expT -> GREAT_TH expf .)
    IF              reduce using rule 84 (expT -> GREAT_TH expf .)
    VAR             reduce using rule 84 (expT -> GREAT_TH expf .)
    WHILE           reduce using rule 84 (expT -> GREAT_TH expf .)
    FROM            reduce using rule 84 (expT -> GREAT_TH expf .)
    R_CURPAR        reduce using rule 84 (expT -> GREAT_TH expf .)
    SEMICOLON       reduce using rule 84 (expT -> GREAT_TH expf .)
    R_PAR           reduce using rule 84 (expT -> GREAT_TH expf .)
    COMMA           reduce using rule 84 (expT -> GREAT_TH expf .)
    R_BREAK         reduce using rule 84 (expT -> GREAT_TH expf .)
    TO              reduce using rule 84 (expT -> GREAT_TH expf .)
    DO              reduce using rule 84 (expT -> GREAT_TH expf .)


state 231

    (85) expT -> SAME expf .

    ID              reduce using rule 85 (expT -> SAME expf .)
    RETURN          reduce using rule 85 (expT -> SAME expf .)
    READ            reduce using rule 85 (expT -> SAME expf .)
    WRITE           reduce using rule 85 (expT -> SAME expf .)
    IF              reduce using rule 85 (expT -> SAME expf .)
    VAR             reduce using rule 85 (expT -> SAME expf .)
    WHILE           reduce using rule 85 (expT -> SAME expf .)
    FROM            reduce using rule 85 (expT -> SAME expf .)
    R_CURPAR        reduce using rule 85 (expT -> SAME expf .)
    SEMICOLON       reduce using rule 85 (expT -> SAME expf .)
    R_PAR           reduce using rule 85 (expT -> SAME expf .)
    COMMA           reduce using rule 85 (expT -> SAME expf .)
    R_BREAK         reduce using rule 85 (expT -> SAME expf .)
    TO              reduce using rule 85 (expT -> SAME expf .)
    DO              reduce using rule 85 (expT -> SAME expf .)


state 232

    (86) expT -> DIF expf .

    ID              reduce using rule 86 (expT -> DIF expf .)
    RETURN          reduce using rule 86 (expT -> DIF expf .)
    READ            reduce using rule 86 (expT -> DIF expf .)
    WRITE           reduce using rule 86 (expT -> DIF expf .)
    IF              reduce using rule 86 (expT -> DIF expf .)
    VAR             reduce using rule 86 (expT -> DIF expf .)
    WHILE           reduce using rule 86 (expT -> DIF expf .)
    FROM            reduce using rule 86 (expT -> DIF expf .)
    R_CURPAR        reduce using rule 86 (expT -> DIF expf .)
    SEMICOLON       reduce using rule 86 (expT -> DIF expf .)
    R_PAR           reduce using rule 86 (expT -> DIF expf .)
    COMMA           reduce using rule 86 (expT -> DIF expf .)
    R_BREAK         reduce using rule 86 (expT -> DIF expf .)
    TO              reduce using rule 86 (expT -> DIF expf .)
    DO              reduce using rule 86 (expT -> DIF expf .)


state 233

    (91) exF -> PLUS ex .

    LESS            reduce using rule 91 (exF -> PLUS ex .)
    GREATER         reduce using rule 91 (exF -> PLUS ex .)
    LESS_TH         reduce using rule 91 (exF -> PLUS ex .)
    GREAT_TH        reduce using rule 91 (exF -> PLUS ex .)
    SAME            reduce using rule 91 (exF -> PLUS ex .)
    DIF             reduce using rule 91 (exF -> PLUS ex .)
    ID              reduce using rule 91 (exF -> PLUS ex .)
    RETURN          reduce using rule 91 (exF -> PLUS ex .)
    READ            reduce using rule 91 (exF -> PLUS ex .)
    WRITE           reduce using rule 91 (exF -> PLUS ex .)
    IF              reduce using rule 91 (exF -> PLUS ex .)
    VAR             reduce using rule 91 (exF -> PLUS ex .)
    WHILE           reduce using rule 91 (exF -> PLUS ex .)
    FROM            reduce using rule 91 (exF -> PLUS ex .)
    R_CURPAR        reduce using rule 91 (exF -> PLUS ex .)
    SEMICOLON       reduce using rule 91 (exF -> PLUS ex .)
    R_PAR           reduce using rule 91 (exF -> PLUS ex .)
    COMMA           reduce using rule 91 (exF -> PLUS ex .)
    R_BREAK         reduce using rule 91 (exF -> PLUS ex .)
    TO              reduce using rule 91 (exF -> PLUS ex .)
    OR              reduce using rule 91 (exF -> PLUS ex .)
    AND             reduce using rule 91 (exF -> PLUS ex .)
    DO              reduce using rule 91 (exF -> PLUS ex .)


state 234

    (92) exF -> MINUS ex .

    LESS            reduce using rule 92 (exF -> MINUS ex .)
    GREATER         reduce using rule 92 (exF -> MINUS ex .)
    LESS_TH         reduce using rule 92 (exF -> MINUS ex .)
    GREAT_TH        reduce using rule 92 (exF -> MINUS ex .)
    SAME            reduce using rule 92 (exF -> MINUS ex .)
    DIF             reduce using rule 92 (exF -> MINUS ex .)
    ID              reduce using rule 92 (exF -> MINUS ex .)
    RETURN          reduce using rule 92 (exF -> MINUS ex .)
    READ            reduce using rule 92 (exF -> MINUS ex .)
    WRITE           reduce using rule 92 (exF -> MINUS ex .)
    IF              reduce using rule 92 (exF -> MINUS ex .)
    VAR             reduce using rule 92 (exF -> MINUS ex .)
    WHILE           reduce using rule 92 (exF -> MINUS ex .)
    FROM            reduce using rule 92 (exF -> MINUS ex .)
    R_CURPAR        reduce using rule 92 (exF -> MINUS ex .)
    SEMICOLON       reduce using rule 92 (exF -> MINUS ex .)
    R_PAR           reduce using rule 92 (exF -> MINUS ex .)
    COMMA           reduce using rule 92 (exF -> MINUS ex .)
    R_BREAK         reduce using rule 92 (exF -> MINUS ex .)
    TO              reduce using rule 92 (exF -> MINUS ex .)
    OR              reduce using rule 92 (exF -> MINUS ex .)
    AND             reduce using rule 92 (exF -> MINUS ex .)
    DO              reduce using rule 92 (exF -> MINUS ex .)


state 235

    (95) termF -> MULT term .

    PLUS            reduce using rule 95 (termF -> MULT term .)
    MINUS           reduce using rule 95 (termF -> MULT term .)
    LESS            reduce using rule 95 (termF -> MULT term .)
    GREATER         reduce using rule 95 (termF -> MULT term .)
    LESS_TH         reduce using rule 95 (termF -> MULT term .)
    GREAT_TH        reduce using rule 95 (termF -> MULT term .)
    SAME            reduce using rule 95 (termF -> MULT term .)
    DIF             reduce using rule 95 (termF -> MULT term .)
    ID              reduce using rule 95 (termF -> MULT term .)
    RETURN          reduce using rule 95 (termF -> MULT term .)
    READ            reduce using rule 95 (termF -> MULT term .)
    WRITE           reduce using rule 95 (termF -> MULT term .)
    IF              reduce using rule 95 (termF -> MULT term .)
    VAR             reduce using rule 95 (termF -> MULT term .)
    WHILE           reduce using rule 95 (termF -> MULT term .)
    FROM            reduce using rule 95 (termF -> MULT term .)
    R_CURPAR        reduce using rule 95 (termF -> MULT term .)
    SEMICOLON       reduce using rule 95 (termF -> MULT term .)
    R_PAR           reduce using rule 95 (termF -> MULT term .)
    COMMA           reduce using rule 95 (termF -> MULT term .)
    R_BREAK         reduce using rule 95 (termF -> MULT term .)
    TO              reduce using rule 95 (termF -> MULT term .)
    OR              reduce using rule 95 (termF -> MULT term .)
    AND             reduce using rule 95 (termF -> MULT term .)
    DO              reduce using rule 95 (termF -> MULT term .)


state 236

    (96) termF -> DIV term .

    PLUS            reduce using rule 96 (termF -> DIV term .)
    MINUS           reduce using rule 96 (termF -> DIV term .)
    LESS            reduce using rule 96 (termF -> DIV term .)
    GREATER         reduce using rule 96 (termF -> DIV term .)
    LESS_TH         reduce using rule 96 (termF -> DIV term .)
    GREAT_TH        reduce using rule 96 (termF -> DIV term .)
    SAME            reduce using rule 96 (termF -> DIV term .)
    DIF             reduce using rule 96 (termF -> DIV term .)
    ID              reduce using rule 96 (termF -> DIV term .)
    RETURN          reduce using rule 96 (termF -> DIV term .)
    READ            reduce using rule 96 (termF -> DIV term .)
    WRITE           reduce using rule 96 (termF -> DIV term .)
    IF              reduce using rule 96 (termF -> DIV term .)
    VAR             reduce using rule 96 (termF -> DIV term .)
    WHILE           reduce using rule 96 (termF -> DIV term .)
    FROM            reduce using rule 96 (termF -> DIV term .)
    R_CURPAR        reduce using rule 96 (termF -> DIV term .)
    SEMICOLON       reduce using rule 96 (termF -> DIV term .)
    R_PAR           reduce using rule 96 (termF -> DIV term .)
    COMMA           reduce using rule 96 (termF -> DIV term .)
    R_BREAK         reduce using rule 96 (termF -> DIV term .)
    TO              reduce using rule 96 (termF -> DIV term .)
    OR              reduce using rule 96 (termF -> DIV term .)
    AND             reduce using rule 96 (termF -> DIV term .)
    DO              reduce using rule 96 (termF -> DIV term .)


state 237

    (98) factor -> L_PAR exp R_PAR . empty
    (108) empty -> .

    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 258

state 238

    (42) void -> ID DOT ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 259


state 239

    (43) void -> ID L_PAR param R_PAR SEMICOLON . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 260

state 240

    (47) paramF -> COMMA param .

    R_PAR           reduce using rule 47 (paramF -> COMMA param .)


state 241

    (49) return -> RETURN L_PAR exp R_PAR SEMICOLON . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 261

state 242

    (55) readF -> var COMMA readF .

    ID              reduce using rule 55 (readF -> var COMMA readF .)
    RETURN          reduce using rule 55 (readF -> var COMMA readF .)
    READ            reduce using rule 55 (readF -> var COMMA readF .)
    WRITE           reduce using rule 55 (readF -> var COMMA readF .)
    IF              reduce using rule 55 (readF -> var COMMA readF .)
    VAR             reduce using rule 55 (readF -> var COMMA readF .)
    WHILE           reduce using rule 55 (readF -> var COMMA readF .)
    FROM            reduce using rule 55 (readF -> var COMMA readF .)
    R_CURPAR        reduce using rule 55 (readF -> var COMMA readF .)
    SEMICOLON       reduce using rule 55 (readF -> var COMMA readF .)


state 243

    (56) readF -> var R_PAR SEMICOLON . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 262

state 244

    (60) writeF -> COMMA writeT .

    ID              reduce using rule 60 (writeF -> COMMA writeT .)
    RETURN          reduce using rule 60 (writeF -> COMMA writeT .)
    READ            reduce using rule 60 (writeF -> COMMA writeT .)
    WRITE           reduce using rule 60 (writeF -> COMMA writeT .)
    IF              reduce using rule 60 (writeF -> COMMA writeT .)
    VAR             reduce using rule 60 (writeF -> COMMA writeT .)
    WHILE           reduce using rule 60 (writeF -> COMMA writeT .)
    FROM            reduce using rule 60 (writeF -> COMMA writeT .)
    R_CURPAR        reduce using rule 60 (writeF -> COMMA writeT .)
    SEMICOLON       reduce using rule 60 (writeF -> COMMA writeT .)


state 245

    (61) writeF -> R_PAR SEMICOLON . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 263

state 246

    (64) if -> IF L_PAR exp R_PAR THEN . L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_CURPAR        shift and go to state 264


state 247

    (44) arrfunc -> L_BREAK exp COMMA exp . R_BREAK empty

    R_BREAK         shift and go to state 265


state 248

    (45) arrfunc -> L_BREAK exp R_BREAK empty .

    EQUAL           reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MIN_EQ          reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT_EQ         reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV_EQ          reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT            reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV             reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS            reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MINUS           reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS            reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREATER         reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS_TH         reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREAT_TH        reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SAME            reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIF             reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    ID              reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    RETURN          reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    READ            reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WRITE           reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    IF              reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    VAR             reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WHILE           reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    FROM            reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_CURPAR        reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SEMICOLON       reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    COMMA           reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_PAR           reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_BREAK         reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    TO              reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    OR              reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    AND             reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DO              reduce using rule 45 (arrfunc -> L_BREAK exp R_BREAK empty .)


state 249

    (74) conditional -> WHILE L_PAR exp R_PAR DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 266


state 250

    (77) nonconditionalF -> exp TO exp . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 267


state 251

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON . empty
    (108) empty -> .

    CLASS           reduce using rule 108 (empty -> .)
    VARS            reduce using rule 108 (empty -> .)
    VOID            reduce using rule 108 (empty -> .)
    MAIN            reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    CHAR            reduce using rule 108 (empty -> .)
    STRING          reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 268

state 252

    (27) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 269


state 253

    (28) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (108) empty -> .

    VOID            reduce using rule 108 (empty -> .)
    MAIN            reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    CHAR            reduce using rule 108 (empty -> .)
    STRING          reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)

    empty                          shift and go to state 270

state 254

    (88) expf -> ex empty .

    ID              reduce using rule 88 (expf -> ex empty .)
    RETURN          reduce using rule 88 (expf -> ex empty .)
    READ            reduce using rule 88 (expf -> ex empty .)
    WRITE           reduce using rule 88 (expf -> ex empty .)
    IF              reduce using rule 88 (expf -> ex empty .)
    VAR             reduce using rule 88 (expf -> ex empty .)
    WHILE           reduce using rule 88 (expf -> ex empty .)
    FROM            reduce using rule 88 (expf -> ex empty .)
    R_CURPAR        reduce using rule 88 (expf -> ex empty .)
    SEMICOLON       reduce using rule 88 (expf -> ex empty .)
    R_PAR           reduce using rule 88 (expf -> ex empty .)
    COMMA           reduce using rule 88 (expf -> ex empty .)
    R_BREAK         reduce using rule 88 (expf -> ex empty .)
    TO              reduce using rule 88 (expf -> ex empty .)
    DO              reduce using rule 88 (expf -> ex empty .)


state 255

    (89) expf -> ex bool . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 271

state 256

    (78) bool -> OR . exp empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 272
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 257

    (79) bool -> AND . exp empty
    (80) exp -> . ex expT
    (90) ex -> . term exF
    (94) term -> . factor termF
    (98) factor -> . L_PAR exp R_PAR empty
    (99) factor -> . factorT
    (100) factorT -> . PLUS factorF
    (101) factorT -> . MINUS factorF
    (102) factorT -> . factorF
    (103) factorF -> . varcte empty
    (104) varcte -> . var empty
    (105) varcte -> . CTE_INT empty
    (106) varcte -> . CTE_FLOAT empty
    (107) varcte -> . CTE_STRING empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 136
    PLUS            shift and go to state 138
    MINUS           shift and go to state 140
    CTE_INT         shift and go to state 143
    CTE_FLOAT       shift and go to state 144
    CTE_STRING      shift and go to state 145
    VAR             shift and go to state 82
    ID              shift and go to state 146

    exp                            shift and go to state 273
    ex                             shift and go to state 133
    term                           shift and go to state 134
    factor                         shift and go to state 135
    factorT                        shift and go to state 137
    factorF                        shift and go to state 139
    varcte                         shift and go to state 141
    var                            shift and go to state 142

state 258

    (98) factor -> L_PAR exp R_PAR empty .

    MULT            reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    DIV             reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    PLUS            reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    MINUS           reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    LESS            reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    GREATER         reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    LESS_TH         reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    GREAT_TH        reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    SAME            reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    DIF             reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    ID              reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    RETURN          reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    READ            reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    WRITE           reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    IF              reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    VAR             reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    WHILE           reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    FROM            reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    R_CURPAR        reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    SEMICOLON       reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    R_PAR           reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    COMMA           reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    R_BREAK         reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    TO              reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    OR              reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    AND             reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)
    DO              reduce using rule 98 (factor -> L_PAR exp R_PAR empty .)


state 259

    (42) void -> ID DOT ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 274


state 260

    (43) void -> ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 43 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 43 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 43 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 43 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 43 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 43 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 43 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 43 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 43 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 43 (void -> ID L_PAR param R_PAR SEMICOLON empty .)


state 261

    (49) return -> RETURN L_PAR exp R_PAR SEMICOLON empty .

    ID              reduce using rule 49 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 49 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    READ            reduce using rule 49 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 49 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    IF              reduce using rule 49 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    VAR             reduce using rule 49 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 49 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    FROM            reduce using rule 49 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 49 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 49 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)


state 262

    (56) readF -> var R_PAR SEMICOLON empty .

    ID              reduce using rule 56 (readF -> var R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 56 (readF -> var R_PAR SEMICOLON empty .)
    READ            reduce using rule 56 (readF -> var R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 56 (readF -> var R_PAR SEMICOLON empty .)
    IF              reduce using rule 56 (readF -> var R_PAR SEMICOLON empty .)
    VAR             reduce using rule 56 (readF -> var R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 56 (readF -> var R_PAR SEMICOLON empty .)
    FROM            reduce using rule 56 (readF -> var R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 56 (readF -> var R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 56 (readF -> var R_PAR SEMICOLON empty .)


state 263

    (61) writeF -> R_PAR SEMICOLON empty .

    ID              reduce using rule 61 (writeF -> R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 61 (writeF -> R_PAR SEMICOLON empty .)
    READ            reduce using rule 61 (writeF -> R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 61 (writeF -> R_PAR SEMICOLON empty .)
    IF              reduce using rule 61 (writeF -> R_PAR SEMICOLON empty .)
    VAR             reduce using rule 61 (writeF -> R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 61 (writeF -> R_PAR SEMICOLON empty .)
    FROM            reduce using rule 61 (writeF -> R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 61 (writeF -> R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 61 (writeF -> R_PAR SEMICOLON empty .)


state 264

    (64) if -> IF L_PAR exp R_PAR THEN L_CURPAR . statement SEMICOLON R_CURPAR ifF
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    statement                      shift and go to state 275
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 265

    (44) arrfunc -> L_BREAK exp COMMA exp R_BREAK . empty
    (108) empty -> .

    EQUAL           reduce using rule 108 (empty -> .)
    PLUS_EQ         reduce using rule 108 (empty -> .)
    MIN_EQ          reduce using rule 108 (empty -> .)
    MULT_EQ         reduce using rule 108 (empty -> .)
    DIV_EQ          reduce using rule 108 (empty -> .)
    MULT            reduce using rule 108 (empty -> .)
    DIV             reduce using rule 108 (empty -> .)
    PLUS            reduce using rule 108 (empty -> .)
    MINUS           reduce using rule 108 (empty -> .)
    LESS            reduce using rule 108 (empty -> .)
    GREATER         reduce using rule 108 (empty -> .)
    LESS_TH         reduce using rule 108 (empty -> .)
    GREAT_TH        reduce using rule 108 (empty -> .)
    SAME            reduce using rule 108 (empty -> .)
    DIF             reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 276

state 266

    (74) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    statement                      shift and go to state 277
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 267

    (77) nonconditionalF -> exp TO exp DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 278


state 268

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .

    CLASS           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VARS            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VOID            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    MAIN            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    INT             reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    FLOAT           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    CHAR            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    STRING          reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    ID              reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)


state 269

    (27) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (108) empty -> .

    VOID            reduce using rule 108 (empty -> .)
    MAIN            reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    CHAR            reduce using rule 108 (empty -> .)
    STRING          reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)

    empty                          shift and go to state 279

state 270

    (28) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    VOID            reduce using rule 28 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    MAIN            reduce using rule 28 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 28 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 28 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 28 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    STRING          reduce using rule 28 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 28 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 28 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 271

    (89) expf -> ex bool empty .

    ID              reduce using rule 89 (expf -> ex bool empty .)
    RETURN          reduce using rule 89 (expf -> ex bool empty .)
    READ            reduce using rule 89 (expf -> ex bool empty .)
    WRITE           reduce using rule 89 (expf -> ex bool empty .)
    IF              reduce using rule 89 (expf -> ex bool empty .)
    VAR             reduce using rule 89 (expf -> ex bool empty .)
    WHILE           reduce using rule 89 (expf -> ex bool empty .)
    FROM            reduce using rule 89 (expf -> ex bool empty .)
    R_CURPAR        reduce using rule 89 (expf -> ex bool empty .)
    SEMICOLON       reduce using rule 89 (expf -> ex bool empty .)
    R_PAR           reduce using rule 89 (expf -> ex bool empty .)
    COMMA           reduce using rule 89 (expf -> ex bool empty .)
    R_BREAK         reduce using rule 89 (expf -> ex bool empty .)
    TO              reduce using rule 89 (expf -> ex bool empty .)
    DO              reduce using rule 89 (expf -> ex bool empty .)


state 272

    (78) bool -> OR exp . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 280

state 273

    (79) bool -> AND exp . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)
    R_PAR           reduce using rule 108 (empty -> .)
    COMMA           reduce using rule 108 (empty -> .)
    R_BREAK         reduce using rule 108 (empty -> .)
    TO              reduce using rule 108 (empty -> .)
    DO              reduce using rule 108 (empty -> .)

    empty                          shift and go to state 281

state 274

    (42) void -> ID DOT ID L_PAR param R_PAR SEMICOLON . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 282

state 275

    (64) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement . SEMICOLON R_CURPAR ifF

    SEMICOLON       shift and go to state 283


state 276

    (44) arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .

    EQUAL           reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MIN_EQ          reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT_EQ         reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV_EQ          reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT            reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV             reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS            reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MINUS           reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS            reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREATER         reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS_TH         reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREAT_TH        reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SAME            reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIF             reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    ID              reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    RETURN          reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    READ            reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WRITE           reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    IF              reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    VAR             reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WHILE           reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    FROM            reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_CURPAR        reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SEMICOLON       reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    COMMA           reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_PAR           reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_BREAK         reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    TO              reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    OR              reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    AND             reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DO              reduce using rule 44 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)


state 277

    (74) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 284


state 278

    (77) nonconditionalF -> exp TO exp DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    statement                      shift and go to state 285
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 279

    (27) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    VOID            reduce using rule 27 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    MAIN            reduce using rule 27 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 27 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 27 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 27 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    STRING          reduce using rule 27 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 27 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 27 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 280

    (78) bool -> OR exp empty .

    ID              reduce using rule 78 (bool -> OR exp empty .)
    RETURN          reduce using rule 78 (bool -> OR exp empty .)
    READ            reduce using rule 78 (bool -> OR exp empty .)
    WRITE           reduce using rule 78 (bool -> OR exp empty .)
    IF              reduce using rule 78 (bool -> OR exp empty .)
    VAR             reduce using rule 78 (bool -> OR exp empty .)
    WHILE           reduce using rule 78 (bool -> OR exp empty .)
    FROM            reduce using rule 78 (bool -> OR exp empty .)
    R_CURPAR        reduce using rule 78 (bool -> OR exp empty .)
    SEMICOLON       reduce using rule 78 (bool -> OR exp empty .)
    R_PAR           reduce using rule 78 (bool -> OR exp empty .)
    COMMA           reduce using rule 78 (bool -> OR exp empty .)
    R_BREAK         reduce using rule 78 (bool -> OR exp empty .)
    TO              reduce using rule 78 (bool -> OR exp empty .)
    DO              reduce using rule 78 (bool -> OR exp empty .)


state 281

    (79) bool -> AND exp empty .

    ID              reduce using rule 79 (bool -> AND exp empty .)
    RETURN          reduce using rule 79 (bool -> AND exp empty .)
    READ            reduce using rule 79 (bool -> AND exp empty .)
    WRITE           reduce using rule 79 (bool -> AND exp empty .)
    IF              reduce using rule 79 (bool -> AND exp empty .)
    VAR             reduce using rule 79 (bool -> AND exp empty .)
    WHILE           reduce using rule 79 (bool -> AND exp empty .)
    FROM            reduce using rule 79 (bool -> AND exp empty .)
    R_CURPAR        reduce using rule 79 (bool -> AND exp empty .)
    SEMICOLON       reduce using rule 79 (bool -> AND exp empty .)
    R_PAR           reduce using rule 79 (bool -> AND exp empty .)
    COMMA           reduce using rule 79 (bool -> AND exp empty .)
    R_BREAK         reduce using rule 79 (bool -> AND exp empty .)
    TO              reduce using rule 79 (bool -> AND exp empty .)
    DO              reduce using rule 79 (bool -> AND exp empty .)


state 282

    (42) void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 42 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 42 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 42 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 42 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 42 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 42 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 42 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 42 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 42 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 42 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)


state 283

    (64) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON . R_CURPAR ifF

    R_CURPAR        shift and go to state 286


state 284

    (74) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 287


state 285

    (77) nonconditionalF -> exp TO exp DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 288


state 286

    (64) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR . ifF
    (65) ifF -> . ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
    (66) ifF -> . empty
    (108) empty -> .

    ELSE            shift and go to state 290
    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    ifF                            shift and go to state 289
    empty                          shift and go to state 291

state 287

    (74) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 292

state 288

    (77) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 293


state 289

    (64) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .

    ID              reduce using rule 64 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    RETURN          reduce using rule 64 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    READ            reduce using rule 64 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WRITE           reduce using rule 64 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    IF              reduce using rule 64 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    VAR             reduce using rule 64 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WHILE           reduce using rule 64 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    FROM            reduce using rule 64 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    R_CURPAR        reduce using rule 64 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    SEMICOLON       reduce using rule 64 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)


state 290

    (65) ifF -> ELSE . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 294


state 291

    (66) ifF -> empty .

    ID              reduce using rule 66 (ifF -> empty .)
    RETURN          reduce using rule 66 (ifF -> empty .)
    READ            reduce using rule 66 (ifF -> empty .)
    WRITE           reduce using rule 66 (ifF -> empty .)
    IF              reduce using rule 66 (ifF -> empty .)
    VAR             reduce using rule 66 (ifF -> empty .)
    WHILE           reduce using rule 66 (ifF -> empty .)
    FROM            reduce using rule 66 (ifF -> empty .)
    R_CURPAR        reduce using rule 66 (ifF -> empty .)
    SEMICOLON       reduce using rule 66 (ifF -> empty .)


state 292

    (74) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 74 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 74 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 74 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 74 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 74 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 74 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 74 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 74 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 74 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 74 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 293

    (77) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 295

state 294

    (65) ifF -> ELSE L_CURPAR . statement SEMICOLON R_CURPAR empty
    (33) statement -> . assigment statementF
    (34) statement -> . void statementF
    (35) statement -> . return statementF
    (36) statement -> . read statementF
    (37) statement -> . write statementF
    (38) statement -> . if statementF
    (39) statement -> . repeat statementF
    (67) assigment -> . var assigmentF
    (42) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (43) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (49) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (54) read -> . READ L_PAR readF
    (57) write -> . WRITE L_PAR writeT
    (64) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (62) repeat -> . conditional empty
    (63) repeat -> . nonconditional empty
    (50) var -> . VAR varF
    (51) var -> . ID DOT VAR varF
    (74) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (75) nonconditional -> . FROM VAR arr nonconditionalF
    (76) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 75
    RETURN          shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    IF              shift and go to state 79
    VAR             shift and go to state 82
    WHILE           shift and go to state 83
    FROM            shift and go to state 84

    statement                      shift and go to state 296
    assigment                      shift and go to state 67
    void                           shift and go to state 68
    return                         shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    if                             shift and go to state 72
    repeat                         shift and go to state 73
    var                            shift and go to state 74
    conditional                    shift and go to state 80
    nonconditional                 shift and go to state 81

state 295

    (77) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 77 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 77 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 77 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 77 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 77 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 77 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 77 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 77 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 77 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 77 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 296

    (65) ifF -> ELSE L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 297


state 297

    (65) ifF -> ELSE L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 298


state 298

    (65) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR . empty
    (108) empty -> .

    ID              reduce using rule 108 (empty -> .)
    RETURN          reduce using rule 108 (empty -> .)
    READ            reduce using rule 108 (empty -> .)
    WRITE           reduce using rule 108 (empty -> .)
    IF              reduce using rule 108 (empty -> .)
    VAR             reduce using rule 108 (empty -> .)
    WHILE           reduce using rule 108 (empty -> .)
    FROM            reduce using rule 108 (empty -> .)
    R_CURPAR        reduce using rule 108 (empty -> .)
    SEMICOLON       reduce using rule 108 (empty -> .)

    empty                          shift and go to state 299

state 299

    (65) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 65 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 65 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 65 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 65 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 65 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 65 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 65 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 65 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 65 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 65 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 160 resolved as shift
WARNING: shift/reduce conflict for R_PAR in state 160 resolved as shift
