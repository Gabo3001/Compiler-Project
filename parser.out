Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID np_getcurrFunc SEMICOLON programT
Rule 2     programT -> class programT
Rule 3     programT -> vars programF
Rule 4     programT -> programF
Rule 5     programF -> func programF
Rule 6     programF -> main empty
Rule 7     class -> CLASS ID classT
Rule 8     classT -> LESS INHERIT ID GREATER classF
Rule 9     classT -> classF
Rule 10    classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty
Rule 11    vars -> VARS dec np_AddFunc empty
Rule 12    dec -> VAR arr np_getDecArr decF
Rule 13    dec -> VAR np_getDec decF
Rule 14    decF -> COMMA dec
Rule 15    decF -> COLON type np_getVarType SEMICOLON np_getDec dec
Rule 16    decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty
Rule 17    type -> INT empty
Rule 18    type -> FLOAT empty
Rule 19    type -> CHAR empty
Rule 20    type -> ID empty
Rule 21    arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
Rule 22    arr -> L_BREAK CTE_INT R_BREAK empty
Rule 23    func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
Rule 24    funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 25    funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 26    typeFunc -> INT empty
Rule 27    typeFunc -> FLOAT empty
Rule 28    typeFunc -> CHAR empty
Rule 29    typeFunc -> ID empty
Rule 30    typeFunc -> VOID empty
Rule 31    parameter -> VAR COLON typepar SEMICOLON parameterF
Rule 32    parameterF -> parameter
Rule 33    parameterF -> empty
Rule 34    typepar -> INT empty
Rule 35    typepar -> FLOAT empty
Rule 36    typepar -> CHAR empty
Rule 37    typepar -> ID empty
Rule 38    main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
Rule 39    statement -> assigment statementF
Rule 40    statement -> void statementF
Rule 41    statement -> return statementF
Rule 42    statement -> read statementF
Rule 43    statement -> write statementF
Rule 44    statement -> if statementF
Rule 45    statement -> repeat statementF
Rule 46    statementF -> statement
Rule 47    statementF -> empty
Rule 48    void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty
Rule 49    void -> ID L_PAR param R_PAR SEMICOLON empty
Rule 50    void -> ID L_PAR R_PAR SEMICOLON empty
Rule 51    arrfunc -> L_BREAK exp COMMA exp R_BREAK empty
Rule 52    arrfunc -> L_BREAK exp R_BREAK empty
Rule 53    param -> exp paramF
Rule 54    paramF -> COMMA param
Rule 55    paramF -> empty
Rule 56    return -> RETURN L_PAR exp R_PAR SEMICOLON empty
Rule 57    var -> VAR varF
Rule 58    var -> ID DOT VAR varF
Rule 59    varF -> arrfunc empty
Rule 60    varF -> empty
Rule 61    read -> READ L_PAR readF
Rule 62    readF -> var COMMA readF
Rule 63    readF -> var R_PAR SEMICOLON empty
Rule 64    write -> WRITE L_PAR writeT
Rule 65    writeT -> CTE_CHAR writeF
Rule 66    writeT -> exp writeF
Rule 67    writeF -> COMMA writeT
Rule 68    writeF -> R_PAR SEMICOLON empty
Rule 69    repeat -> conditional empty
Rule 70    repeat -> nonconditional empty
Rule 71    if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
Rule 72    ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 73    ifF -> empty
Rule 74    assigment -> var assigmentF
Rule 75    assigmentF -> EQUAL exp empty
Rule 76    assigmentF -> ope exp empty
Rule 77    ope -> PLUS_EQ empty
Rule 78    ope -> MIN_EQ empty
Rule 79    ope -> MULT_EQ empty
Rule 80    ope -> DIV_EQ empty
Rule 81    conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 82    nonconditional -> FROM VAR arrfunc nonconditionalF
Rule 83    nonconditional -> FROM VAR nonconditionalF
Rule 84    nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 85    bool -> OR exp empty
Rule 86    bool -> AND exp empty
Rule 87    exp -> ex expT
Rule 88    expT -> LESS expf
Rule 89    expT -> GREATER expf
Rule 90    expT -> LESS_TH expf
Rule 91    expT -> GREAT_TH expf
Rule 92    expT -> SAME expf
Rule 93    expT -> DIF expf
Rule 94    expT -> empty
Rule 95    expf -> ex empty
Rule 96    expf -> ex bool empty
Rule 97    ex -> term np_addEx exF
Rule 98    exF -> PLUS np_addOp ex
Rule 99    exF -> MINUS np_addOp ex
Rule 100   exF -> empty
Rule 101   term -> factor np_addTerm termF
Rule 102   termF -> MULT np_addOp term
Rule 103   termF -> DIV np_addOp term
Rule 104   termF -> empty
Rule 105   factor -> L_PAR np_addPar exp R_PAR np_popPar empty
Rule 106   factor -> factorT
Rule 107   factorT -> PLUS factorF
Rule 108   factorT -> MINUS factorF
Rule 109   factorT -> factorF
Rule 110   factorF -> varcte empty
Rule 111   varcte -> var np_addId empty
Rule 112   varcte -> CTE_INT empty
Rule 113   varcte -> CTE_FLOAT empty
Rule 114   varcte -> CTE_CHAR empty
Rule 115   empty -> <empty>
Rule 116   np_getcurrFunc -> <empty>
Rule 117   np_getDec -> <empty>
Rule 118   np_getDecArr -> <empty>
Rule 119   np_getVarType -> <empty>
Rule 120   np_AddFunc -> <empty>
Rule 121   np_addToDic -> <empty>
Rule 122   np_addId -> <empty>
Rule 123   np_addOp -> <empty>
Rule 124   np_addPar -> <empty>
Rule 125   np_popPar -> <empty>
Rule 126   np_addTerm -> <empty>
Rule 127   np_addEx -> <empty>

Terminals, with rules where they appear

AND                  : 86
ATTRIBUTES           : 10
CHAR                 : 19 28 36
CLASS                : 7
COLON                : 15 16 31
COMMA                : 14 21 51 54 62 67
CTE_CHAR             : 65 114
CTE_FLOAT            : 113
CTE_INT              : 21 21 22 112
DIF                  : 93
DIV                  : 103
DIV_EQ               : 80
DO                   : 81 84
DOT                  : 48 58
ELSE                 : 72
EQUAL                : 75
FLOAT                : 18 27 35
FROM                 : 82 83
FUNCTION             : 23
GREATER              : 8 89
GREAT_TH             : 91
ID                   : 1 7 8 20 23 29 37 48 48 49 50 58
IF                   : 71
INHERIT              : 8
INT                  : 17 26 34
LESS                 : 8 88
LESS_TH              : 90
L_BREAK              : 21 22 51 52
L_CURPAR             : 10 24 25 38 71 72 81 84
L_PAR                : 23 38 48 49 50 56 61 64 71 81 105
MAIN                 : 38
METHODS              : 10
MINUS                : 99 108
MIN_EQ               : 78
MULT                 : 102
MULT_EQ              : 79
OR                   : 85
PLUS                 : 98 107
PLUS_EQ              : 77
PROGRAM              : 1
READ                 : 61
RETURN               : 56
R_BREAK              : 21 22 51 52
R_CURPAR             : 10 24 25 38 71 72 81 84
R_PAR                : 24 25 38 48 49 50 56 63 68 71 81 105
SAME                 : 92
SEMICOLON            : 1 10 10 15 16 24 25 31 48 49 50 56 63 68 71 72 81 84
THEN                 : 71
TO                   : 84
VAR                  : 12 13 31 57 58 82 83
VARS                 : 11
VOID                 : 30
WHILE                : 81
WRITE                : 64
error                : 

Nonterminals, with rules where they appear

arr                  : 12
arrfunc              : 59 82
assigment            : 39
assigmentF           : 74
bool                 : 96
class                : 2
classF               : 8 9
classT               : 7
conditional          : 69
dec                  : 10 11 14 15 24 25
decF                 : 12 13
empty                : 6 10 11 16 17 18 19 20 21 22 24 25 26 27 28 29 30 33 34 35 36 37 38 47 48 49 50 51 52 55 56 59 60 63 68 69 70 72 73 75 76 77 78 79 80 81 84 85 86 94 95 96 100 104 105 110 111 112 113 114
ex                   : 87 95 96 98 99
exF                  : 97
exp                  : 51 51 52 53 56 66 71 75 76 81 84 84 85 86 105
expT                 : 87
expf                 : 88 89 90 91 92 93
factor               : 101
factorF              : 107 108 109
factorT              : 106
func                 : 5 10
funcF                : 23
if                   : 44
ifF                  : 71
main                 : 6
nonconditional       : 70
nonconditionalF      : 82 83
np_AddFunc           : 11 23
np_addEx             : 97
np_addId             : 111
np_addOp             : 98 99 102 103
np_addPar            : 105
np_addTerm           : 101
np_addToDic          : 16
np_getDec            : 13 15 16
np_getDecArr         : 12
np_getVarType        : 15 16
np_getcurrFunc       : 1 23
np_popPar            : 105
ope                  : 76
param                : 48 49 54
paramF               : 53
parameter            : 24 32
parameterF           : 31
program              : 0
programF             : 3 4 5
programT             : 1 2
read                 : 42
readF                : 61 62
repeat               : 45
return               : 41
statement            : 24 25 38 46 71 72 81 84
statementF           : 39 40 41 42 43 44 45
term                 : 97 102 103
termF                : 101
type                 : 15 16
typeFunc             : 23
typepar              : 31
var                  : 62 63 74 111
varF                 : 57 58
varcte               : 110
vars                 : 3
void                 : 40
write                : 43
writeF               : 65 66
writeT               : 64 67

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID np_getcurrFunc SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID np_getcurrFunc SEMICOLON programT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . np_getcurrFunc SEMICOLON programT
    (116) np_getcurrFunc -> .

    SEMICOLON       reduce using rule 116 (np_getcurrFunc -> .)

    np_getcurrFunc                 shift and go to state 4

state 4

    (1) program -> PROGRAM ID np_getcurrFunc . SEMICOLON programT

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID np_getcurrFunc SEMICOLON . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec np_AddFunc empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    CLASS           shift and go to state 11
    VARS            shift and go to state 12
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    ID              shift and go to state 6
    VOID            shift and go to state 20

    programT                       shift and go to state 7
    class                          shift and go to state 8
    vars                           shift and go to state 9
    programF                       shift and go to state 10
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 6

    (29) typeFunc -> ID . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)

    empty                          shift and go to state 21

state 7

    (1) program -> PROGRAM ID np_getcurrFunc SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM ID np_getcurrFunc SEMICOLON programT .)


state 8

    (2) programT -> class . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec np_AddFunc empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    CLASS           shift and go to state 11
    VARS            shift and go to state 12
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    ID              shift and go to state 6
    VOID            shift and go to state 20

    class                          shift and go to state 8
    programT                       shift and go to state 22
    vars                           shift and go to state 9
    programF                       shift and go to state 10
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 9

    (3) programT -> vars . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    ID              shift and go to state 6
    VOID            shift and go to state 20

    programF                       shift and go to state 23
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 10

    (4) programT -> programF .

    $end            reduce using rule 4 (programT -> programF .)


state 11

    (7) class -> CLASS . ID classT

    ID              shift and go to state 24


state 12

    (11) vars -> VARS . dec np_AddFunc empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 26

    dec                            shift and go to state 25

state 13

    (5) programF -> func . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    ID              shift and go to state 6
    VOID            shift and go to state 20

    func                           shift and go to state 13
    programF                       shift and go to state 27
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 14

    (6) programF -> main . empty
    (115) empty -> .

    $end            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 28

state 15

    (23) func -> typeFunc . FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF

    FUNCTION        shift and go to state 29


state 16

    (38) main -> MAIN . L_PAR R_PAR L_CURPAR statement R_CURPAR empty

    L_PAR           shift and go to state 30


state 17

    (26) typeFunc -> INT . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)

    empty                          shift and go to state 31

state 18

    (27) typeFunc -> FLOAT . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)

    empty                          shift and go to state 32

state 19

    (28) typeFunc -> CHAR . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)

    empty                          shift and go to state 33

state 20

    (30) typeFunc -> VOID . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)

    empty                          shift and go to state 34

state 21

    (29) typeFunc -> ID empty .

    FUNCTION        reduce using rule 29 (typeFunc -> ID empty .)


state 22

    (2) programT -> class programT .

    $end            reduce using rule 2 (programT -> class programT .)


state 23

    (3) programT -> vars programF .

    $end            reduce using rule 3 (programT -> vars programF .)


state 24

    (7) class -> CLASS ID . classT
    (8) classT -> . LESS INHERIT ID GREATER classF
    (9) classT -> . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    LESS            shift and go to state 36
    SEMICOLON       shift and go to state 38

    classT                         shift and go to state 35
    classF                         shift and go to state 37

state 25

    (11) vars -> VARS dec . np_AddFunc empty
    (120) np_AddFunc -> .

    MAIN            reduce using rule 120 (np_AddFunc -> .)
    INT             reduce using rule 120 (np_AddFunc -> .)
    FLOAT           reduce using rule 120 (np_AddFunc -> .)
    CHAR            reduce using rule 120 (np_AddFunc -> .)
    ID              reduce using rule 120 (np_AddFunc -> .)
    VOID            reduce using rule 120 (np_AddFunc -> .)

    np_AddFunc                     shift and go to state 39

state 26

    (12) dec -> VAR . arr np_getDecArr decF
    (13) dec -> VAR . np_getDec decF
    (21) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (22) arr -> . L_BREAK CTE_INT R_BREAK empty
    (117) np_getDec -> .

    L_BREAK         shift and go to state 42
    COMMA           reduce using rule 117 (np_getDec -> .)
    COLON           reduce using rule 117 (np_getDec -> .)

    arr                            shift and go to state 40
    np_getDec                      shift and go to state 41

state 27

    (5) programF -> func programF .

    $end            reduce using rule 5 (programF -> func programF .)


state 28

    (6) programF -> main empty .

    $end            reduce using rule 6 (programF -> main empty .)


state 29

    (23) func -> typeFunc FUNCTION . ID np_getcurrFunc np_AddFunc L_PAR funcF

    ID              shift and go to state 43


state 30

    (38) main -> MAIN L_PAR . R_PAR L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 44


state 31

    (26) typeFunc -> INT empty .

    FUNCTION        reduce using rule 26 (typeFunc -> INT empty .)


state 32

    (27) typeFunc -> FLOAT empty .

    FUNCTION        reduce using rule 27 (typeFunc -> FLOAT empty .)


state 33

    (28) typeFunc -> CHAR empty .

    FUNCTION        reduce using rule 28 (typeFunc -> CHAR empty .)


state 34

    (30) typeFunc -> VOID empty .

    FUNCTION        reduce using rule 30 (typeFunc -> VOID empty .)


state 35

    (7) class -> CLASS ID classT .

    CLASS           reduce using rule 7 (class -> CLASS ID classT .)
    VARS            reduce using rule 7 (class -> CLASS ID classT .)
    MAIN            reduce using rule 7 (class -> CLASS ID classT .)
    INT             reduce using rule 7 (class -> CLASS ID classT .)
    FLOAT           reduce using rule 7 (class -> CLASS ID classT .)
    CHAR            reduce using rule 7 (class -> CLASS ID classT .)
    ID              reduce using rule 7 (class -> CLASS ID classT .)
    VOID            reduce using rule 7 (class -> CLASS ID classT .)


state 36

    (8) classT -> LESS . INHERIT ID GREATER classF

    INHERIT         shift and go to state 45


state 37

    (9) classT -> classF .

    CLASS           reduce using rule 9 (classT -> classF .)
    VARS            reduce using rule 9 (classT -> classF .)
    MAIN            reduce using rule 9 (classT -> classF .)
    INT             reduce using rule 9 (classT -> classF .)
    FLOAT           reduce using rule 9 (classT -> classF .)
    CHAR            reduce using rule 9 (classT -> classF .)
    ID              reduce using rule 9 (classT -> classF .)
    VOID            reduce using rule 9 (classT -> classF .)


state 38

    (10) classF -> SEMICOLON . L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    L_CURPAR        shift and go to state 46


state 39

    (11) vars -> VARS dec np_AddFunc . empty
    (115) empty -> .

    MAIN            reduce using rule 115 (empty -> .)
    INT             reduce using rule 115 (empty -> .)
    FLOAT           reduce using rule 115 (empty -> .)
    CHAR            reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 47

state 40

    (12) dec -> VAR arr . np_getDecArr decF
    (118) np_getDecArr -> .

    COMMA           reduce using rule 118 (np_getDecArr -> .)
    COLON           reduce using rule 118 (np_getDecArr -> .)

    np_getDecArr                   shift and go to state 48

state 41

    (13) dec -> VAR np_getDec . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 50
    COLON           shift and go to state 51

    decF                           shift and go to state 49

state 42

    (21) arr -> L_BREAK . CTE_INT COMMA CTE_INT R_BREAK empty
    (22) arr -> L_BREAK . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 52


state 43

    (23) func -> typeFunc FUNCTION ID . np_getcurrFunc np_AddFunc L_PAR funcF
    (116) np_getcurrFunc -> .

    L_PAR           reduce using rule 116 (np_getcurrFunc -> .)

    np_getcurrFunc                 shift and go to state 53

state 44

    (38) main -> MAIN L_PAR R_PAR . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 54


state 45

    (8) classT -> LESS INHERIT . ID GREATER classF

    ID              shift and go to state 55


state 46

    (10) classF -> SEMICOLON L_CURPAR . ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    ATTRIBUTES      shift and go to state 56


state 47

    (11) vars -> VARS dec np_AddFunc empty .

    MAIN            reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    INT             reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    FLOAT           reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    CHAR            reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    ID              reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    VOID            reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)


state 48

    (12) dec -> VAR arr np_getDecArr . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 50
    COLON           shift and go to state 51

    decF                           shift and go to state 57

state 49

    (13) dec -> VAR np_getDec decF .

    MAIN            reduce using rule 13 (dec -> VAR np_getDec decF .)
    INT             reduce using rule 13 (dec -> VAR np_getDec decF .)
    FLOAT           reduce using rule 13 (dec -> VAR np_getDec decF .)
    CHAR            reduce using rule 13 (dec -> VAR np_getDec decF .)
    ID              reduce using rule 13 (dec -> VAR np_getDec decF .)
    VOID            reduce using rule 13 (dec -> VAR np_getDec decF .)
    METHODS         reduce using rule 13 (dec -> VAR np_getDec decF .)
    L_CURPAR        reduce using rule 13 (dec -> VAR np_getDec decF .)


state 50

    (14) decF -> COMMA . dec
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 26

    dec                            shift and go to state 58

state 51

    (15) decF -> COLON . type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON . type np_getVarType SEMICOLON np_getDec np_addToDic empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . ID empty

    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    CHAR            shift and go to state 62
    ID              shift and go to state 63

    type                           shift and go to state 59

state 52

    (21) arr -> L_BREAK CTE_INT . COMMA CTE_INT R_BREAK empty
    (22) arr -> L_BREAK CTE_INT . R_BREAK empty

    COMMA           shift and go to state 64
    R_BREAK         shift and go to state 65


state 53

    (23) func -> typeFunc FUNCTION ID np_getcurrFunc . np_AddFunc L_PAR funcF
    (120) np_AddFunc -> .

    L_PAR           reduce using rule 120 (np_AddFunc -> .)

    np_AddFunc                     shift and go to state 66

state 54

    (38) main -> MAIN L_PAR R_PAR L_CURPAR . statement R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 67
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 55

    (8) classT -> LESS INHERIT ID . GREATER classF

    GREATER         shift and go to state 86


state 56

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES . dec METHODS func R_CURPAR SEMICOLON empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 26

    dec                            shift and go to state 87

state 57

    (12) dec -> VAR arr np_getDecArr decF .

    MAIN            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    INT             reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    FLOAT           reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    CHAR            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    ID              reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    VOID            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    METHODS         reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    L_CURPAR        reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)


state 58

    (14) decF -> COMMA dec .

    MAIN            reduce using rule 14 (decF -> COMMA dec .)
    INT             reduce using rule 14 (decF -> COMMA dec .)
    FLOAT           reduce using rule 14 (decF -> COMMA dec .)
    CHAR            reduce using rule 14 (decF -> COMMA dec .)
    ID              reduce using rule 14 (decF -> COMMA dec .)
    VOID            reduce using rule 14 (decF -> COMMA dec .)
    METHODS         reduce using rule 14 (decF -> COMMA dec .)
    L_CURPAR        reduce using rule 14 (decF -> COMMA dec .)


state 59

    (15) decF -> COLON type . np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON type . np_getVarType SEMICOLON np_getDec np_addToDic empty
    (119) np_getVarType -> .

    SEMICOLON       reduce using rule 119 (np_getVarType -> .)

    np_getVarType                  shift and go to state 88

state 60

    (17) type -> INT . empty
    (115) empty -> .

    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 89

state 61

    (18) type -> FLOAT . empty
    (115) empty -> .

    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 90

state 62

    (19) type -> CHAR . empty
    (115) empty -> .

    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 91

state 63

    (20) type -> ID . empty
    (115) empty -> .

    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 92

state 64

    (21) arr -> L_BREAK CTE_INT COMMA . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 93


state 65

    (22) arr -> L_BREAK CTE_INT R_BREAK . empty
    (115) empty -> .

    COMMA           reduce using rule 115 (empty -> .)
    COLON           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 94

state 66

    (23) func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc . L_PAR funcF

    L_PAR           shift and go to state 95


state 67

    (38) main -> MAIN L_PAR R_PAR L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 96


state 68

    (39) statement -> assigment . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (115) empty -> .
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    assigment                      shift and go to state 68
    statementF                     shift and go to state 97
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 69

    (40) statement -> void . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (115) empty -> .
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    void                           shift and go to state 69
    statementF                     shift and go to state 100
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 70

    (41) statement -> return . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (115) empty -> .
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    return                         shift and go to state 70
    statementF                     shift and go to state 101
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 71

    (42) statement -> read . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (115) empty -> .
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    read                           shift and go to state 71
    statementF                     shift and go to state 102
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 72

    (43) statement -> write . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (115) empty -> .
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    write                          shift and go to state 72
    statementF                     shift and go to state 103
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 73

    (44) statement -> if . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (115) empty -> .
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    if                             shift and go to state 73
    statementF                     shift and go to state 104
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 74

    (45) statement -> repeat . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (115) empty -> .
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    repeat                         shift and go to state 74
    statementF                     shift and go to state 105
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 75

    (74) assigment -> var . assigmentF
    (75) assigmentF -> . EQUAL exp empty
    (76) assigmentF -> . ope exp empty
    (77) ope -> . PLUS_EQ empty
    (78) ope -> . MIN_EQ empty
    (79) ope -> . MULT_EQ empty
    (80) ope -> . DIV_EQ empty

    EQUAL           shift and go to state 107
    PLUS_EQ         shift and go to state 109
    MIN_EQ          shift and go to state 110
    MULT_EQ         shift and go to state 111
    DIV_EQ          shift and go to state 112

    assigmentF                     shift and go to state 106
    ope                            shift and go to state 108

state 76

    (48) void -> ID . DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> ID . L_PAR param R_PAR SEMICOLON empty
    (50) void -> ID . L_PAR R_PAR SEMICOLON empty
    (58) var -> ID . DOT VAR varF

    DOT             shift and go to state 113
    L_PAR           shift and go to state 114


state 77

    (56) return -> RETURN . L_PAR exp R_PAR SEMICOLON empty

    L_PAR           shift and go to state 115


state 78

    (61) read -> READ . L_PAR readF

    L_PAR           shift and go to state 116


state 79

    (64) write -> WRITE . L_PAR writeT

    L_PAR           shift and go to state 117


state 80

    (71) if -> IF . L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_PAR           shift and go to state 118


state 81

    (69) repeat -> conditional . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 119

state 82

    (70) repeat -> nonconditional . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 120

state 83

    (57) var -> VAR . varF
    (59) varF -> . arrfunc empty
    (60) varF -> . empty
    (51) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (52) arrfunc -> . L_BREAK exp R_BREAK empty
    (115) empty -> .

    L_BREAK         shift and go to state 124
    EQUAL           reduce using rule 115 (empty -> .)
    PLUS_EQ         reduce using rule 115 (empty -> .)
    MIN_EQ          reduce using rule 115 (empty -> .)
    MULT_EQ         reduce using rule 115 (empty -> .)
    DIV_EQ          reduce using rule 115 (empty -> .)
    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    varF                           shift and go to state 121
    arrfunc                        shift and go to state 122
    empty                          shift and go to state 123

state 84

    (81) conditional -> WHILE . L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    L_PAR           shift and go to state 125


state 85

    (82) nonconditional -> FROM . VAR arrfunc nonconditionalF
    (83) nonconditional -> FROM . VAR nonconditionalF

    VAR             shift and go to state 126


state 86

    (8) classT -> LESS INHERIT ID GREATER . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    SEMICOLON       shift and go to state 38

    classF                         shift and go to state 127

state 87

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec . METHODS func R_CURPAR SEMICOLON empty

    METHODS         shift and go to state 128


state 88

    (15) decF -> COLON type np_getVarType . SEMICOLON np_getDec dec
    (16) decF -> COLON type np_getVarType . SEMICOLON np_getDec np_addToDic empty

    SEMICOLON       shift and go to state 129


state 89

    (17) type -> INT empty .

    SEMICOLON       reduce using rule 17 (type -> INT empty .)


state 90

    (18) type -> FLOAT empty .

    SEMICOLON       reduce using rule 18 (type -> FLOAT empty .)


state 91

    (19) type -> CHAR empty .

    SEMICOLON       reduce using rule 19 (type -> CHAR empty .)


state 92

    (20) type -> ID empty .

    SEMICOLON       reduce using rule 20 (type -> ID empty .)


state 93

    (21) arr -> L_BREAK CTE_INT COMMA CTE_INT . R_BREAK empty

    R_BREAK         shift and go to state 130


state 94

    (22) arr -> L_BREAK CTE_INT R_BREAK empty .

    COMMA           reduce using rule 22 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    COLON           reduce using rule 22 (arr -> L_BREAK CTE_INT R_BREAK empty .)


state 95

    (23) func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR . funcF
    (24) funcF -> . parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (25) funcF -> . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (31) parameter -> . VAR COLON typepar SEMICOLON parameterF

    R_PAR           shift and go to state 133
    VAR             shift and go to state 134

    funcF                          shift and go to state 131
    parameter                      shift and go to state 132

state 96

    (38) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR . empty
    (115) empty -> .

    $end            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 135

state 97

    (39) statement -> assigment statementF .

    R_CURPAR        reduce using rule 39 (statement -> assigment statementF .)
    SEMICOLON       reduce using rule 39 (statement -> assigment statementF .)


state 98

    (46) statementF -> statement .

    R_CURPAR        reduce using rule 46 (statementF -> statement .)
    SEMICOLON       reduce using rule 46 (statementF -> statement .)


state 99

    (47) statementF -> empty .

    R_CURPAR        reduce using rule 47 (statementF -> empty .)
    SEMICOLON       reduce using rule 47 (statementF -> empty .)


state 100

    (40) statement -> void statementF .

    R_CURPAR        reduce using rule 40 (statement -> void statementF .)
    SEMICOLON       reduce using rule 40 (statement -> void statementF .)


state 101

    (41) statement -> return statementF .

    R_CURPAR        reduce using rule 41 (statement -> return statementF .)
    SEMICOLON       reduce using rule 41 (statement -> return statementF .)


state 102

    (42) statement -> read statementF .

    R_CURPAR        reduce using rule 42 (statement -> read statementF .)
    SEMICOLON       reduce using rule 42 (statement -> read statementF .)


state 103

    (43) statement -> write statementF .

    R_CURPAR        reduce using rule 43 (statement -> write statementF .)
    SEMICOLON       reduce using rule 43 (statement -> write statementF .)


state 104

    (44) statement -> if statementF .

    R_CURPAR        reduce using rule 44 (statement -> if statementF .)
    SEMICOLON       reduce using rule 44 (statement -> if statementF .)


state 105

    (45) statement -> repeat statementF .

    R_CURPAR        reduce using rule 45 (statement -> repeat statementF .)
    SEMICOLON       reduce using rule 45 (statement -> repeat statementF .)


state 106

    (74) assigment -> var assigmentF .

    ID              reduce using rule 74 (assigment -> var assigmentF .)
    RETURN          reduce using rule 74 (assigment -> var assigmentF .)
    READ            reduce using rule 74 (assigment -> var assigmentF .)
    WRITE           reduce using rule 74 (assigment -> var assigmentF .)
    IF              reduce using rule 74 (assigment -> var assigmentF .)
    VAR             reduce using rule 74 (assigment -> var assigmentF .)
    WHILE           reduce using rule 74 (assigment -> var assigmentF .)
    FROM            reduce using rule 74 (assigment -> var assigmentF .)
    R_CURPAR        reduce using rule 74 (assigment -> var assigmentF .)
    SEMICOLON       reduce using rule 74 (assigment -> var assigmentF .)


state 107

    (75) assigmentF -> EQUAL . exp empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 136
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 108

    (76) assigmentF -> ope . exp empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 151
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 109

    (77) ope -> PLUS_EQ . empty
    (115) empty -> .

    L_PAR           reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    CTE_INT         reduce using rule 115 (empty -> .)
    CTE_FLOAT       reduce using rule 115 (empty -> .)
    CTE_CHAR        reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 152

state 110

    (78) ope -> MIN_EQ . empty
    (115) empty -> .

    L_PAR           reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    CTE_INT         reduce using rule 115 (empty -> .)
    CTE_FLOAT       reduce using rule 115 (empty -> .)
    CTE_CHAR        reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 153

state 111

    (79) ope -> MULT_EQ . empty
    (115) empty -> .

    L_PAR           reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    CTE_INT         reduce using rule 115 (empty -> .)
    CTE_FLOAT       reduce using rule 115 (empty -> .)
    CTE_CHAR        reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 154

state 112

    (80) ope -> DIV_EQ . empty
    (115) empty -> .

    L_PAR           reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    CTE_INT         reduce using rule 115 (empty -> .)
    CTE_FLOAT       reduce using rule 115 (empty -> .)
    CTE_CHAR        reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 155

state 113

    (48) void -> ID DOT . ID L_PAR param R_PAR SEMICOLON empty
    (58) var -> ID DOT . VAR varF

    ID              shift and go to state 156
    VAR             shift and go to state 157


state 114

    (49) void -> ID L_PAR . param R_PAR SEMICOLON empty
    (50) void -> ID L_PAR . R_PAR SEMICOLON empty
    (53) param -> . exp paramF
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 159
    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    param                          shift and go to state 158
    exp                            shift and go to state 160
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 115

    (56) return -> RETURN L_PAR . exp R_PAR SEMICOLON empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 161
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 116

    (61) read -> READ L_PAR . readF
    (62) readF -> . var COMMA readF
    (63) readF -> . var R_PAR SEMICOLON empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    VAR             shift and go to state 83
    ID              shift and go to state 150

    readF                          shift and go to state 162
    var                            shift and go to state 163

state 117

    (64) write -> WRITE L_PAR . writeT
    (65) writeT -> . CTE_CHAR writeF
    (66) writeT -> . exp writeF
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    CTE_CHAR        shift and go to state 165
    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    VAR             shift and go to state 83
    ID              shift and go to state 150

    writeT                         shift and go to state 164
    exp                            shift and go to state 166
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 118

    (71) if -> IF L_PAR . exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 167
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 119

    (69) repeat -> conditional empty .

    ID              reduce using rule 69 (repeat -> conditional empty .)
    RETURN          reduce using rule 69 (repeat -> conditional empty .)
    READ            reduce using rule 69 (repeat -> conditional empty .)
    WRITE           reduce using rule 69 (repeat -> conditional empty .)
    IF              reduce using rule 69 (repeat -> conditional empty .)
    VAR             reduce using rule 69 (repeat -> conditional empty .)
    WHILE           reduce using rule 69 (repeat -> conditional empty .)
    FROM            reduce using rule 69 (repeat -> conditional empty .)
    R_CURPAR        reduce using rule 69 (repeat -> conditional empty .)
    SEMICOLON       reduce using rule 69 (repeat -> conditional empty .)


state 120

    (70) repeat -> nonconditional empty .

    ID              reduce using rule 70 (repeat -> nonconditional empty .)
    RETURN          reduce using rule 70 (repeat -> nonconditional empty .)
    READ            reduce using rule 70 (repeat -> nonconditional empty .)
    WRITE           reduce using rule 70 (repeat -> nonconditional empty .)
    IF              reduce using rule 70 (repeat -> nonconditional empty .)
    VAR             reduce using rule 70 (repeat -> nonconditional empty .)
    WHILE           reduce using rule 70 (repeat -> nonconditional empty .)
    FROM            reduce using rule 70 (repeat -> nonconditional empty .)
    R_CURPAR        reduce using rule 70 (repeat -> nonconditional empty .)
    SEMICOLON       reduce using rule 70 (repeat -> nonconditional empty .)


state 121

    (57) var -> VAR varF .

    EQUAL           reduce using rule 57 (var -> VAR varF .)
    PLUS_EQ         reduce using rule 57 (var -> VAR varF .)
    MIN_EQ          reduce using rule 57 (var -> VAR varF .)
    MULT_EQ         reduce using rule 57 (var -> VAR varF .)
    DIV_EQ          reduce using rule 57 (var -> VAR varF .)
    MULT            reduce using rule 57 (var -> VAR varF .)
    DIV             reduce using rule 57 (var -> VAR varF .)
    PLUS            reduce using rule 57 (var -> VAR varF .)
    MINUS           reduce using rule 57 (var -> VAR varF .)
    LESS            reduce using rule 57 (var -> VAR varF .)
    GREATER         reduce using rule 57 (var -> VAR varF .)
    LESS_TH         reduce using rule 57 (var -> VAR varF .)
    GREAT_TH        reduce using rule 57 (var -> VAR varF .)
    SAME            reduce using rule 57 (var -> VAR varF .)
    DIF             reduce using rule 57 (var -> VAR varF .)
    ID              reduce using rule 57 (var -> VAR varF .)
    RETURN          reduce using rule 57 (var -> VAR varF .)
    READ            reduce using rule 57 (var -> VAR varF .)
    WRITE           reduce using rule 57 (var -> VAR varF .)
    IF              reduce using rule 57 (var -> VAR varF .)
    VAR             reduce using rule 57 (var -> VAR varF .)
    WHILE           reduce using rule 57 (var -> VAR varF .)
    FROM            reduce using rule 57 (var -> VAR varF .)
    R_CURPAR        reduce using rule 57 (var -> VAR varF .)
    SEMICOLON       reduce using rule 57 (var -> VAR varF .)
    COMMA           reduce using rule 57 (var -> VAR varF .)
    R_PAR           reduce using rule 57 (var -> VAR varF .)
    R_BREAK         reduce using rule 57 (var -> VAR varF .)
    TO              reduce using rule 57 (var -> VAR varF .)
    OR              reduce using rule 57 (var -> VAR varF .)
    AND             reduce using rule 57 (var -> VAR varF .)
    DO              reduce using rule 57 (var -> VAR varF .)


state 122

    (59) varF -> arrfunc . empty
    (115) empty -> .

    EQUAL           reduce using rule 115 (empty -> .)
    PLUS_EQ         reduce using rule 115 (empty -> .)
    MIN_EQ          reduce using rule 115 (empty -> .)
    MULT_EQ         reduce using rule 115 (empty -> .)
    DIV_EQ          reduce using rule 115 (empty -> .)
    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 168

state 123

    (60) varF -> empty .

    EQUAL           reduce using rule 60 (varF -> empty .)
    PLUS_EQ         reduce using rule 60 (varF -> empty .)
    MIN_EQ          reduce using rule 60 (varF -> empty .)
    MULT_EQ         reduce using rule 60 (varF -> empty .)
    DIV_EQ          reduce using rule 60 (varF -> empty .)
    MULT            reduce using rule 60 (varF -> empty .)
    DIV             reduce using rule 60 (varF -> empty .)
    PLUS            reduce using rule 60 (varF -> empty .)
    MINUS           reduce using rule 60 (varF -> empty .)
    LESS            reduce using rule 60 (varF -> empty .)
    GREATER         reduce using rule 60 (varF -> empty .)
    LESS_TH         reduce using rule 60 (varF -> empty .)
    GREAT_TH        reduce using rule 60 (varF -> empty .)
    SAME            reduce using rule 60 (varF -> empty .)
    DIF             reduce using rule 60 (varF -> empty .)
    ID              reduce using rule 60 (varF -> empty .)
    RETURN          reduce using rule 60 (varF -> empty .)
    READ            reduce using rule 60 (varF -> empty .)
    WRITE           reduce using rule 60 (varF -> empty .)
    IF              reduce using rule 60 (varF -> empty .)
    VAR             reduce using rule 60 (varF -> empty .)
    WHILE           reduce using rule 60 (varF -> empty .)
    FROM            reduce using rule 60 (varF -> empty .)
    R_CURPAR        reduce using rule 60 (varF -> empty .)
    SEMICOLON       reduce using rule 60 (varF -> empty .)
    COMMA           reduce using rule 60 (varF -> empty .)
    R_PAR           reduce using rule 60 (varF -> empty .)
    R_BREAK         reduce using rule 60 (varF -> empty .)
    TO              reduce using rule 60 (varF -> empty .)
    OR              reduce using rule 60 (varF -> empty .)
    AND             reduce using rule 60 (varF -> empty .)
    DO              reduce using rule 60 (varF -> empty .)


state 124

    (51) arrfunc -> L_BREAK . exp COMMA exp R_BREAK empty
    (52) arrfunc -> L_BREAK . exp R_BREAK empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 169
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 125

    (81) conditional -> WHILE L_PAR . exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 170
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 126

    (82) nonconditional -> FROM VAR . arrfunc nonconditionalF
    (83) nonconditional -> FROM VAR . nonconditionalF
    (51) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (52) arrfunc -> . L_BREAK exp R_BREAK empty
    (84) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_BREAK         shift and go to state 124
    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    arrfunc                        shift and go to state 171
    nonconditionalF                shift and go to state 172
    exp                            shift and go to state 173
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 127

    (8) classT -> LESS INHERIT ID GREATER classF .

    CLASS           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VARS            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    MAIN            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    INT             reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    FLOAT           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    CHAR            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    ID              reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VOID            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)


state 128

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS . func R_CURPAR SEMICOLON empty
    (23) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    ID              shift and go to state 6
    VOID            shift and go to state 20

    func                           shift and go to state 174
    typeFunc                       shift and go to state 15

state 129

    (15) decF -> COLON type np_getVarType SEMICOLON . np_getDec dec
    (16) decF -> COLON type np_getVarType SEMICOLON . np_getDec np_addToDic empty
    (117) np_getDec -> .

    VAR             reduce using rule 117 (np_getDec -> .)
    MAIN            reduce using rule 117 (np_getDec -> .)
    INT             reduce using rule 117 (np_getDec -> .)
    FLOAT           reduce using rule 117 (np_getDec -> .)
    CHAR            reduce using rule 117 (np_getDec -> .)
    ID              reduce using rule 117 (np_getDec -> .)
    VOID            reduce using rule 117 (np_getDec -> .)
    METHODS         reduce using rule 117 (np_getDec -> .)
    L_CURPAR        reduce using rule 117 (np_getDec -> .)

    np_getDec                      shift and go to state 175

state 130

    (21) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK . empty
    (115) empty -> .

    COMMA           reduce using rule 115 (empty -> .)
    COLON           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 176

state 131

    (23) func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .

    MAIN            reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    INT             reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    FLOAT           reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    CHAR            reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    ID              reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    VOID            reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    R_CURPAR        reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)


state 132

    (24) funcF -> parameter . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 177


state 133

    (25) funcF -> R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 178


state 134

    (31) parameter -> VAR . COLON typepar SEMICOLON parameterF

    COLON           shift and go to state 179


state 135

    (38) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .

    $end            reduce using rule 38 (main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .)


state 136

    (75) assigmentF -> EQUAL exp . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 180

state 137

    (87) exp -> ex . expT
    (88) expT -> . LESS expf
    (89) expT -> . GREATER expf
    (90) expT -> . LESS_TH expf
    (91) expT -> . GREAT_TH expf
    (92) expT -> . SAME expf
    (93) expT -> . DIF expf
    (94) expT -> . empty
    (115) empty -> .

    LESS            shift and go to state 182
    GREATER         shift and go to state 183
    LESS_TH         shift and go to state 184
    GREAT_TH        shift and go to state 185
    SAME            shift and go to state 186
    DIF             shift and go to state 187
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    expT                           shift and go to state 181
    empty                          shift and go to state 188

state 138

    (97) ex -> term . np_addEx exF
    (127) np_addEx -> .

    PLUS            reduce using rule 127 (np_addEx -> .)
    MINUS           reduce using rule 127 (np_addEx -> .)
    LESS            reduce using rule 127 (np_addEx -> .)
    GREATER         reduce using rule 127 (np_addEx -> .)
    LESS_TH         reduce using rule 127 (np_addEx -> .)
    GREAT_TH        reduce using rule 127 (np_addEx -> .)
    SAME            reduce using rule 127 (np_addEx -> .)
    DIF             reduce using rule 127 (np_addEx -> .)
    ID              reduce using rule 127 (np_addEx -> .)
    RETURN          reduce using rule 127 (np_addEx -> .)
    READ            reduce using rule 127 (np_addEx -> .)
    WRITE           reduce using rule 127 (np_addEx -> .)
    IF              reduce using rule 127 (np_addEx -> .)
    VAR             reduce using rule 127 (np_addEx -> .)
    WHILE           reduce using rule 127 (np_addEx -> .)
    FROM            reduce using rule 127 (np_addEx -> .)
    R_CURPAR        reduce using rule 127 (np_addEx -> .)
    SEMICOLON       reduce using rule 127 (np_addEx -> .)
    COMMA           reduce using rule 127 (np_addEx -> .)
    R_PAR           reduce using rule 127 (np_addEx -> .)
    R_BREAK         reduce using rule 127 (np_addEx -> .)
    TO              reduce using rule 127 (np_addEx -> .)
    OR              reduce using rule 127 (np_addEx -> .)
    AND             reduce using rule 127 (np_addEx -> .)
    DO              reduce using rule 127 (np_addEx -> .)

    np_addEx                       shift and go to state 189

state 139

    (101) term -> factor . np_addTerm termF
    (126) np_addTerm -> .

    MULT            reduce using rule 126 (np_addTerm -> .)
    DIV             reduce using rule 126 (np_addTerm -> .)
    PLUS            reduce using rule 126 (np_addTerm -> .)
    MINUS           reduce using rule 126 (np_addTerm -> .)
    LESS            reduce using rule 126 (np_addTerm -> .)
    GREATER         reduce using rule 126 (np_addTerm -> .)
    LESS_TH         reduce using rule 126 (np_addTerm -> .)
    GREAT_TH        reduce using rule 126 (np_addTerm -> .)
    SAME            reduce using rule 126 (np_addTerm -> .)
    DIF             reduce using rule 126 (np_addTerm -> .)
    ID              reduce using rule 126 (np_addTerm -> .)
    RETURN          reduce using rule 126 (np_addTerm -> .)
    READ            reduce using rule 126 (np_addTerm -> .)
    WRITE           reduce using rule 126 (np_addTerm -> .)
    IF              reduce using rule 126 (np_addTerm -> .)
    VAR             reduce using rule 126 (np_addTerm -> .)
    WHILE           reduce using rule 126 (np_addTerm -> .)
    FROM            reduce using rule 126 (np_addTerm -> .)
    R_CURPAR        reduce using rule 126 (np_addTerm -> .)
    SEMICOLON       reduce using rule 126 (np_addTerm -> .)
    COMMA           reduce using rule 126 (np_addTerm -> .)
    R_PAR           reduce using rule 126 (np_addTerm -> .)
    R_BREAK         reduce using rule 126 (np_addTerm -> .)
    TO              reduce using rule 126 (np_addTerm -> .)
    OR              reduce using rule 126 (np_addTerm -> .)
    AND             reduce using rule 126 (np_addTerm -> .)
    DO              reduce using rule 126 (np_addTerm -> .)

    np_addTerm                     shift and go to state 190

state 140

    (105) factor -> L_PAR . np_addPar exp R_PAR np_popPar empty
    (124) np_addPar -> .

    L_PAR           reduce using rule 124 (np_addPar -> .)
    PLUS            reduce using rule 124 (np_addPar -> .)
    MINUS           reduce using rule 124 (np_addPar -> .)
    CTE_INT         reduce using rule 124 (np_addPar -> .)
    CTE_FLOAT       reduce using rule 124 (np_addPar -> .)
    CTE_CHAR        reduce using rule 124 (np_addPar -> .)
    VAR             reduce using rule 124 (np_addPar -> .)
    ID              reduce using rule 124 (np_addPar -> .)

    np_addPar                      shift and go to state 191

state 141

    (106) factor -> factorT .

    MULT            reduce using rule 106 (factor -> factorT .)
    DIV             reduce using rule 106 (factor -> factorT .)
    PLUS            reduce using rule 106 (factor -> factorT .)
    MINUS           reduce using rule 106 (factor -> factorT .)
    LESS            reduce using rule 106 (factor -> factorT .)
    GREATER         reduce using rule 106 (factor -> factorT .)
    LESS_TH         reduce using rule 106 (factor -> factorT .)
    GREAT_TH        reduce using rule 106 (factor -> factorT .)
    SAME            reduce using rule 106 (factor -> factorT .)
    DIF             reduce using rule 106 (factor -> factorT .)
    ID              reduce using rule 106 (factor -> factorT .)
    RETURN          reduce using rule 106 (factor -> factorT .)
    READ            reduce using rule 106 (factor -> factorT .)
    WRITE           reduce using rule 106 (factor -> factorT .)
    IF              reduce using rule 106 (factor -> factorT .)
    VAR             reduce using rule 106 (factor -> factorT .)
    WHILE           reduce using rule 106 (factor -> factorT .)
    FROM            reduce using rule 106 (factor -> factorT .)
    R_CURPAR        reduce using rule 106 (factor -> factorT .)
    SEMICOLON       reduce using rule 106 (factor -> factorT .)
    COMMA           reduce using rule 106 (factor -> factorT .)
    R_PAR           reduce using rule 106 (factor -> factorT .)
    R_BREAK         reduce using rule 106 (factor -> factorT .)
    TO              reduce using rule 106 (factor -> factorT .)
    OR              reduce using rule 106 (factor -> factorT .)
    AND             reduce using rule 106 (factor -> factorT .)
    DO              reduce using rule 106 (factor -> factorT .)


state 142

    (107) factorT -> PLUS . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    factorF                        shift and go to state 192
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 143

    (109) factorT -> factorF .

    MULT            reduce using rule 109 (factorT -> factorF .)
    DIV             reduce using rule 109 (factorT -> factorF .)
    PLUS            reduce using rule 109 (factorT -> factorF .)
    MINUS           reduce using rule 109 (factorT -> factorF .)
    LESS            reduce using rule 109 (factorT -> factorF .)
    GREATER         reduce using rule 109 (factorT -> factorF .)
    LESS_TH         reduce using rule 109 (factorT -> factorF .)
    GREAT_TH        reduce using rule 109 (factorT -> factorF .)
    SAME            reduce using rule 109 (factorT -> factorF .)
    DIF             reduce using rule 109 (factorT -> factorF .)
    ID              reduce using rule 109 (factorT -> factorF .)
    RETURN          reduce using rule 109 (factorT -> factorF .)
    READ            reduce using rule 109 (factorT -> factorF .)
    WRITE           reduce using rule 109 (factorT -> factorF .)
    IF              reduce using rule 109 (factorT -> factorF .)
    VAR             reduce using rule 109 (factorT -> factorF .)
    WHILE           reduce using rule 109 (factorT -> factorF .)
    FROM            reduce using rule 109 (factorT -> factorF .)
    R_CURPAR        reduce using rule 109 (factorT -> factorF .)
    SEMICOLON       reduce using rule 109 (factorT -> factorF .)
    COMMA           reduce using rule 109 (factorT -> factorF .)
    R_PAR           reduce using rule 109 (factorT -> factorF .)
    R_BREAK         reduce using rule 109 (factorT -> factorF .)
    TO              reduce using rule 109 (factorT -> factorF .)
    OR              reduce using rule 109 (factorT -> factorF .)
    AND             reduce using rule 109 (factorT -> factorF .)
    DO              reduce using rule 109 (factorT -> factorF .)


state 144

    (108) factorT -> MINUS . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    factorF                        shift and go to state 193
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 145

    (110) factorF -> varcte . empty
    (115) empty -> .

    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 194

state 146

    (111) varcte -> var . np_addId empty
    (122) np_addId -> .

    MULT            reduce using rule 122 (np_addId -> .)
    DIV             reduce using rule 122 (np_addId -> .)
    PLUS            reduce using rule 122 (np_addId -> .)
    MINUS           reduce using rule 122 (np_addId -> .)
    LESS            reduce using rule 122 (np_addId -> .)
    GREATER         reduce using rule 122 (np_addId -> .)
    LESS_TH         reduce using rule 122 (np_addId -> .)
    GREAT_TH        reduce using rule 122 (np_addId -> .)
    SAME            reduce using rule 122 (np_addId -> .)
    DIF             reduce using rule 122 (np_addId -> .)
    ID              reduce using rule 122 (np_addId -> .)
    RETURN          reduce using rule 122 (np_addId -> .)
    READ            reduce using rule 122 (np_addId -> .)
    WRITE           reduce using rule 122 (np_addId -> .)
    IF              reduce using rule 122 (np_addId -> .)
    VAR             reduce using rule 122 (np_addId -> .)
    WHILE           reduce using rule 122 (np_addId -> .)
    FROM            reduce using rule 122 (np_addId -> .)
    R_CURPAR        reduce using rule 122 (np_addId -> .)
    SEMICOLON       reduce using rule 122 (np_addId -> .)
    COMMA           reduce using rule 122 (np_addId -> .)
    R_PAR           reduce using rule 122 (np_addId -> .)
    R_BREAK         reduce using rule 122 (np_addId -> .)
    TO              reduce using rule 122 (np_addId -> .)
    OR              reduce using rule 122 (np_addId -> .)
    AND             reduce using rule 122 (np_addId -> .)
    DO              reduce using rule 122 (np_addId -> .)

    np_addId                       shift and go to state 195

state 147

    (112) varcte -> CTE_INT . empty
    (115) empty -> .

    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 196

state 148

    (113) varcte -> CTE_FLOAT . empty
    (115) empty -> .

    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 197

state 149

    (114) varcte -> CTE_CHAR . empty
    (115) empty -> .

    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 198

state 150

    (58) var -> ID . DOT VAR varF

    DOT             shift and go to state 199


state 151

    (76) assigmentF -> ope exp . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 200

state 152

    (77) ope -> PLUS_EQ empty .

    L_PAR           reduce using rule 77 (ope -> PLUS_EQ empty .)
    PLUS            reduce using rule 77 (ope -> PLUS_EQ empty .)
    MINUS           reduce using rule 77 (ope -> PLUS_EQ empty .)
    CTE_INT         reduce using rule 77 (ope -> PLUS_EQ empty .)
    CTE_FLOAT       reduce using rule 77 (ope -> PLUS_EQ empty .)
    CTE_CHAR        reduce using rule 77 (ope -> PLUS_EQ empty .)
    VAR             reduce using rule 77 (ope -> PLUS_EQ empty .)
    ID              reduce using rule 77 (ope -> PLUS_EQ empty .)


state 153

    (78) ope -> MIN_EQ empty .

    L_PAR           reduce using rule 78 (ope -> MIN_EQ empty .)
    PLUS            reduce using rule 78 (ope -> MIN_EQ empty .)
    MINUS           reduce using rule 78 (ope -> MIN_EQ empty .)
    CTE_INT         reduce using rule 78 (ope -> MIN_EQ empty .)
    CTE_FLOAT       reduce using rule 78 (ope -> MIN_EQ empty .)
    CTE_CHAR        reduce using rule 78 (ope -> MIN_EQ empty .)
    VAR             reduce using rule 78 (ope -> MIN_EQ empty .)
    ID              reduce using rule 78 (ope -> MIN_EQ empty .)


state 154

    (79) ope -> MULT_EQ empty .

    L_PAR           reduce using rule 79 (ope -> MULT_EQ empty .)
    PLUS            reduce using rule 79 (ope -> MULT_EQ empty .)
    MINUS           reduce using rule 79 (ope -> MULT_EQ empty .)
    CTE_INT         reduce using rule 79 (ope -> MULT_EQ empty .)
    CTE_FLOAT       reduce using rule 79 (ope -> MULT_EQ empty .)
    CTE_CHAR        reduce using rule 79 (ope -> MULT_EQ empty .)
    VAR             reduce using rule 79 (ope -> MULT_EQ empty .)
    ID              reduce using rule 79 (ope -> MULT_EQ empty .)


state 155

    (80) ope -> DIV_EQ empty .

    L_PAR           reduce using rule 80 (ope -> DIV_EQ empty .)
    PLUS            reduce using rule 80 (ope -> DIV_EQ empty .)
    MINUS           reduce using rule 80 (ope -> DIV_EQ empty .)
    CTE_INT         reduce using rule 80 (ope -> DIV_EQ empty .)
    CTE_FLOAT       reduce using rule 80 (ope -> DIV_EQ empty .)
    CTE_CHAR        reduce using rule 80 (ope -> DIV_EQ empty .)
    VAR             reduce using rule 80 (ope -> DIV_EQ empty .)
    ID              reduce using rule 80 (ope -> DIV_EQ empty .)


state 156

    (48) void -> ID DOT ID . L_PAR param R_PAR SEMICOLON empty

    L_PAR           shift and go to state 201


state 157

    (58) var -> ID DOT VAR . varF
    (59) varF -> . arrfunc empty
    (60) varF -> . empty
    (51) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (52) arrfunc -> . L_BREAK exp R_BREAK empty
    (115) empty -> .

    L_BREAK         shift and go to state 124
    EQUAL           reduce using rule 115 (empty -> .)
    PLUS_EQ         reduce using rule 115 (empty -> .)
    MIN_EQ          reduce using rule 115 (empty -> .)
    MULT_EQ         reduce using rule 115 (empty -> .)
    DIV_EQ          reduce using rule 115 (empty -> .)
    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    varF                           shift and go to state 202
    arrfunc                        shift and go to state 122
    empty                          shift and go to state 123

state 158

    (49) void -> ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 203


state 159

    (50) void -> ID L_PAR R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 204


state 160

    (53) param -> exp . paramF
    (54) paramF -> . COMMA param
    (55) paramF -> . empty
    (115) empty -> .

    COMMA           shift and go to state 206
    R_PAR           reduce using rule 115 (empty -> .)

    paramF                         shift and go to state 205
    empty                          shift and go to state 207

state 161

    (56) return -> RETURN L_PAR exp . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 208


state 162

    (61) read -> READ L_PAR readF .

    ID              reduce using rule 61 (read -> READ L_PAR readF .)
    RETURN          reduce using rule 61 (read -> READ L_PAR readF .)
    READ            reduce using rule 61 (read -> READ L_PAR readF .)
    WRITE           reduce using rule 61 (read -> READ L_PAR readF .)
    IF              reduce using rule 61 (read -> READ L_PAR readF .)
    VAR             reduce using rule 61 (read -> READ L_PAR readF .)
    WHILE           reduce using rule 61 (read -> READ L_PAR readF .)
    FROM            reduce using rule 61 (read -> READ L_PAR readF .)
    R_CURPAR        reduce using rule 61 (read -> READ L_PAR readF .)
    SEMICOLON       reduce using rule 61 (read -> READ L_PAR readF .)


state 163

    (62) readF -> var . COMMA readF
    (63) readF -> var . R_PAR SEMICOLON empty

    COMMA           shift and go to state 209
    R_PAR           shift and go to state 210


state 164

    (64) write -> WRITE L_PAR writeT .

    ID              reduce using rule 64 (write -> WRITE L_PAR writeT .)
    RETURN          reduce using rule 64 (write -> WRITE L_PAR writeT .)
    READ            reduce using rule 64 (write -> WRITE L_PAR writeT .)
    WRITE           reduce using rule 64 (write -> WRITE L_PAR writeT .)
    IF              reduce using rule 64 (write -> WRITE L_PAR writeT .)
    VAR             reduce using rule 64 (write -> WRITE L_PAR writeT .)
    WHILE           reduce using rule 64 (write -> WRITE L_PAR writeT .)
    FROM            reduce using rule 64 (write -> WRITE L_PAR writeT .)
    R_CURPAR        reduce using rule 64 (write -> WRITE L_PAR writeT .)
    SEMICOLON       reduce using rule 64 (write -> WRITE L_PAR writeT .)


state 165

    (65) writeT -> CTE_CHAR . writeF
    (114) varcte -> CTE_CHAR . empty
    (67) writeF -> . COMMA writeT
    (68) writeF -> . R_PAR SEMICOLON empty
    (115) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for R_PAR resolved as shift
    COMMA           shift and go to state 212
    R_PAR           shift and go to state 213
    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)

  ! COMMA           [ reduce using rule 115 (empty -> .) ]
  ! R_PAR           [ reduce using rule 115 (empty -> .) ]

    writeF                         shift and go to state 211
    empty                          shift and go to state 198

state 166

    (66) writeT -> exp . writeF
    (67) writeF -> . COMMA writeT
    (68) writeF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 212
    R_PAR           shift and go to state 213

    writeF                         shift and go to state 214

state 167

    (71) if -> IF L_PAR exp . R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    R_PAR           shift and go to state 215


state 168

    (59) varF -> arrfunc empty .

    EQUAL           reduce using rule 59 (varF -> arrfunc empty .)
    PLUS_EQ         reduce using rule 59 (varF -> arrfunc empty .)
    MIN_EQ          reduce using rule 59 (varF -> arrfunc empty .)
    MULT_EQ         reduce using rule 59 (varF -> arrfunc empty .)
    DIV_EQ          reduce using rule 59 (varF -> arrfunc empty .)
    MULT            reduce using rule 59 (varF -> arrfunc empty .)
    DIV             reduce using rule 59 (varF -> arrfunc empty .)
    PLUS            reduce using rule 59 (varF -> arrfunc empty .)
    MINUS           reduce using rule 59 (varF -> arrfunc empty .)
    LESS            reduce using rule 59 (varF -> arrfunc empty .)
    GREATER         reduce using rule 59 (varF -> arrfunc empty .)
    LESS_TH         reduce using rule 59 (varF -> arrfunc empty .)
    GREAT_TH        reduce using rule 59 (varF -> arrfunc empty .)
    SAME            reduce using rule 59 (varF -> arrfunc empty .)
    DIF             reduce using rule 59 (varF -> arrfunc empty .)
    ID              reduce using rule 59 (varF -> arrfunc empty .)
    RETURN          reduce using rule 59 (varF -> arrfunc empty .)
    READ            reduce using rule 59 (varF -> arrfunc empty .)
    WRITE           reduce using rule 59 (varF -> arrfunc empty .)
    IF              reduce using rule 59 (varF -> arrfunc empty .)
    VAR             reduce using rule 59 (varF -> arrfunc empty .)
    WHILE           reduce using rule 59 (varF -> arrfunc empty .)
    FROM            reduce using rule 59 (varF -> arrfunc empty .)
    R_CURPAR        reduce using rule 59 (varF -> arrfunc empty .)
    SEMICOLON       reduce using rule 59 (varF -> arrfunc empty .)
    COMMA           reduce using rule 59 (varF -> arrfunc empty .)
    R_PAR           reduce using rule 59 (varF -> arrfunc empty .)
    R_BREAK         reduce using rule 59 (varF -> arrfunc empty .)
    TO              reduce using rule 59 (varF -> arrfunc empty .)
    OR              reduce using rule 59 (varF -> arrfunc empty .)
    AND             reduce using rule 59 (varF -> arrfunc empty .)
    DO              reduce using rule 59 (varF -> arrfunc empty .)


state 169

    (51) arrfunc -> L_BREAK exp . COMMA exp R_BREAK empty
    (52) arrfunc -> L_BREAK exp . R_BREAK empty

    COMMA           shift and go to state 216
    R_BREAK         shift and go to state 217


state 170

    (81) conditional -> WHILE L_PAR exp . R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    R_PAR           shift and go to state 218


state 171

    (82) nonconditional -> FROM VAR arrfunc . nonconditionalF
    (84) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    nonconditionalF                shift and go to state 219
    exp                            shift and go to state 173
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 172

    (83) nonconditional -> FROM VAR nonconditionalF .

    ID              reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    RETURN          reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    READ            reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    WRITE           reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    IF              reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    VAR             reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    WHILE           reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    FROM            reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    R_CURPAR        reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    SEMICOLON       reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)


state 173

    (84) nonconditionalF -> exp . TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty

    TO              shift and go to state 220


state 174

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func . R_CURPAR SEMICOLON empty

    R_CURPAR        shift and go to state 221


state 175

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec . dec
    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec . np_addToDic empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF
    (121) np_addToDic -> .

    VAR             shift and go to state 26
    MAIN            reduce using rule 121 (np_addToDic -> .)
    INT             reduce using rule 121 (np_addToDic -> .)
    FLOAT           reduce using rule 121 (np_addToDic -> .)
    CHAR            reduce using rule 121 (np_addToDic -> .)
    ID              reduce using rule 121 (np_addToDic -> .)
    VOID            reduce using rule 121 (np_addToDic -> .)
    METHODS         reduce using rule 121 (np_addToDic -> .)
    L_CURPAR        reduce using rule 121 (np_addToDic -> .)

    dec                            shift and go to state 222
    np_addToDic                    shift and go to state 223

state 176

    (21) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .

    COMMA           reduce using rule 21 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    COLON           reduce using rule 21 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)


state 177

    (24) funcF -> parameter R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 224


state 178

    (25) funcF -> R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 26

    dec                            shift and go to state 225

state 179

    (31) parameter -> VAR COLON . typepar SEMICOLON parameterF
    (34) typepar -> . INT empty
    (35) typepar -> . FLOAT empty
    (36) typepar -> . CHAR empty
    (37) typepar -> . ID empty

    INT             shift and go to state 227
    FLOAT           shift and go to state 228
    CHAR            shift and go to state 229
    ID              shift and go to state 230

    typepar                        shift and go to state 226

state 180

    (75) assigmentF -> EQUAL exp empty .

    ID              reduce using rule 75 (assigmentF -> EQUAL exp empty .)
    RETURN          reduce using rule 75 (assigmentF -> EQUAL exp empty .)
    READ            reduce using rule 75 (assigmentF -> EQUAL exp empty .)
    WRITE           reduce using rule 75 (assigmentF -> EQUAL exp empty .)
    IF              reduce using rule 75 (assigmentF -> EQUAL exp empty .)
    VAR             reduce using rule 75 (assigmentF -> EQUAL exp empty .)
    WHILE           reduce using rule 75 (assigmentF -> EQUAL exp empty .)
    FROM            reduce using rule 75 (assigmentF -> EQUAL exp empty .)
    R_CURPAR        reduce using rule 75 (assigmentF -> EQUAL exp empty .)
    SEMICOLON       reduce using rule 75 (assigmentF -> EQUAL exp empty .)


state 181

    (87) exp -> ex expT .

    ID              reduce using rule 87 (exp -> ex expT .)
    RETURN          reduce using rule 87 (exp -> ex expT .)
    READ            reduce using rule 87 (exp -> ex expT .)
    WRITE           reduce using rule 87 (exp -> ex expT .)
    IF              reduce using rule 87 (exp -> ex expT .)
    VAR             reduce using rule 87 (exp -> ex expT .)
    WHILE           reduce using rule 87 (exp -> ex expT .)
    FROM            reduce using rule 87 (exp -> ex expT .)
    R_CURPAR        reduce using rule 87 (exp -> ex expT .)
    SEMICOLON       reduce using rule 87 (exp -> ex expT .)
    COMMA           reduce using rule 87 (exp -> ex expT .)
    R_PAR           reduce using rule 87 (exp -> ex expT .)
    R_BREAK         reduce using rule 87 (exp -> ex expT .)
    TO              reduce using rule 87 (exp -> ex expT .)
    DO              reduce using rule 87 (exp -> ex expT .)


state 182

    (88) expT -> LESS . expf
    (95) expf -> . ex empty
    (96) expf -> . ex bool empty
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    expf                           shift and go to state 231
    ex                             shift and go to state 232
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 183

    (89) expT -> GREATER . expf
    (95) expf -> . ex empty
    (96) expf -> . ex bool empty
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    expf                           shift and go to state 233
    ex                             shift and go to state 232
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 184

    (90) expT -> LESS_TH . expf
    (95) expf -> . ex empty
    (96) expf -> . ex bool empty
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    expf                           shift and go to state 234
    ex                             shift and go to state 232
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 185

    (91) expT -> GREAT_TH . expf
    (95) expf -> . ex empty
    (96) expf -> . ex bool empty
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    expf                           shift and go to state 235
    ex                             shift and go to state 232
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 186

    (92) expT -> SAME . expf
    (95) expf -> . ex empty
    (96) expf -> . ex bool empty
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    expf                           shift and go to state 236
    ex                             shift and go to state 232
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 187

    (93) expT -> DIF . expf
    (95) expf -> . ex empty
    (96) expf -> . ex bool empty
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    expf                           shift and go to state 237
    ex                             shift and go to state 232
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 188

    (94) expT -> empty .

    ID              reduce using rule 94 (expT -> empty .)
    RETURN          reduce using rule 94 (expT -> empty .)
    READ            reduce using rule 94 (expT -> empty .)
    WRITE           reduce using rule 94 (expT -> empty .)
    IF              reduce using rule 94 (expT -> empty .)
    VAR             reduce using rule 94 (expT -> empty .)
    WHILE           reduce using rule 94 (expT -> empty .)
    FROM            reduce using rule 94 (expT -> empty .)
    R_CURPAR        reduce using rule 94 (expT -> empty .)
    SEMICOLON       reduce using rule 94 (expT -> empty .)
    COMMA           reduce using rule 94 (expT -> empty .)
    R_PAR           reduce using rule 94 (expT -> empty .)
    R_BREAK         reduce using rule 94 (expT -> empty .)
    TO              reduce using rule 94 (expT -> empty .)
    DO              reduce using rule 94 (expT -> empty .)


state 189

    (97) ex -> term np_addEx . exF
    (98) exF -> . PLUS np_addOp ex
    (99) exF -> . MINUS np_addOp ex
    (100) exF -> . empty
    (115) empty -> .

    PLUS            shift and go to state 239
    MINUS           shift and go to state 240
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    exF                            shift and go to state 238
    empty                          shift and go to state 241

state 190

    (101) term -> factor np_addTerm . termF
    (102) termF -> . MULT np_addOp term
    (103) termF -> . DIV np_addOp term
    (104) termF -> . empty
    (115) empty -> .

    MULT            shift and go to state 243
    DIV             shift and go to state 244
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    termF                          shift and go to state 242
    empty                          shift and go to state 245

state 191

    (105) factor -> L_PAR np_addPar . exp R_PAR np_popPar empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 246
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 192

    (107) factorT -> PLUS factorF .

    MULT            reduce using rule 107 (factorT -> PLUS factorF .)
    DIV             reduce using rule 107 (factorT -> PLUS factorF .)
    PLUS            reduce using rule 107 (factorT -> PLUS factorF .)
    MINUS           reduce using rule 107 (factorT -> PLUS factorF .)
    LESS            reduce using rule 107 (factorT -> PLUS factorF .)
    GREATER         reduce using rule 107 (factorT -> PLUS factorF .)
    LESS_TH         reduce using rule 107 (factorT -> PLUS factorF .)
    GREAT_TH        reduce using rule 107 (factorT -> PLUS factorF .)
    SAME            reduce using rule 107 (factorT -> PLUS factorF .)
    DIF             reduce using rule 107 (factorT -> PLUS factorF .)
    ID              reduce using rule 107 (factorT -> PLUS factorF .)
    RETURN          reduce using rule 107 (factorT -> PLUS factorF .)
    READ            reduce using rule 107 (factorT -> PLUS factorF .)
    WRITE           reduce using rule 107 (factorT -> PLUS factorF .)
    IF              reduce using rule 107 (factorT -> PLUS factorF .)
    VAR             reduce using rule 107 (factorT -> PLUS factorF .)
    WHILE           reduce using rule 107 (factorT -> PLUS factorF .)
    FROM            reduce using rule 107 (factorT -> PLUS factorF .)
    R_CURPAR        reduce using rule 107 (factorT -> PLUS factorF .)
    SEMICOLON       reduce using rule 107 (factorT -> PLUS factorF .)
    COMMA           reduce using rule 107 (factorT -> PLUS factorF .)
    R_PAR           reduce using rule 107 (factorT -> PLUS factorF .)
    R_BREAK         reduce using rule 107 (factorT -> PLUS factorF .)
    TO              reduce using rule 107 (factorT -> PLUS factorF .)
    OR              reduce using rule 107 (factorT -> PLUS factorF .)
    AND             reduce using rule 107 (factorT -> PLUS factorF .)
    DO              reduce using rule 107 (factorT -> PLUS factorF .)


state 193

    (108) factorT -> MINUS factorF .

    MULT            reduce using rule 108 (factorT -> MINUS factorF .)
    DIV             reduce using rule 108 (factorT -> MINUS factorF .)
    PLUS            reduce using rule 108 (factorT -> MINUS factorF .)
    MINUS           reduce using rule 108 (factorT -> MINUS factorF .)
    LESS            reduce using rule 108 (factorT -> MINUS factorF .)
    GREATER         reduce using rule 108 (factorT -> MINUS factorF .)
    LESS_TH         reduce using rule 108 (factorT -> MINUS factorF .)
    GREAT_TH        reduce using rule 108 (factorT -> MINUS factorF .)
    SAME            reduce using rule 108 (factorT -> MINUS factorF .)
    DIF             reduce using rule 108 (factorT -> MINUS factorF .)
    ID              reduce using rule 108 (factorT -> MINUS factorF .)
    RETURN          reduce using rule 108 (factorT -> MINUS factorF .)
    READ            reduce using rule 108 (factorT -> MINUS factorF .)
    WRITE           reduce using rule 108 (factorT -> MINUS factorF .)
    IF              reduce using rule 108 (factorT -> MINUS factorF .)
    VAR             reduce using rule 108 (factorT -> MINUS factorF .)
    WHILE           reduce using rule 108 (factorT -> MINUS factorF .)
    FROM            reduce using rule 108 (factorT -> MINUS factorF .)
    R_CURPAR        reduce using rule 108 (factorT -> MINUS factorF .)
    SEMICOLON       reduce using rule 108 (factorT -> MINUS factorF .)
    COMMA           reduce using rule 108 (factorT -> MINUS factorF .)
    R_PAR           reduce using rule 108 (factorT -> MINUS factorF .)
    R_BREAK         reduce using rule 108 (factorT -> MINUS factorF .)
    TO              reduce using rule 108 (factorT -> MINUS factorF .)
    OR              reduce using rule 108 (factorT -> MINUS factorF .)
    AND             reduce using rule 108 (factorT -> MINUS factorF .)
    DO              reduce using rule 108 (factorT -> MINUS factorF .)


state 194

    (110) factorF -> varcte empty .

    MULT            reduce using rule 110 (factorF -> varcte empty .)
    DIV             reduce using rule 110 (factorF -> varcte empty .)
    PLUS            reduce using rule 110 (factorF -> varcte empty .)
    MINUS           reduce using rule 110 (factorF -> varcte empty .)
    LESS            reduce using rule 110 (factorF -> varcte empty .)
    GREATER         reduce using rule 110 (factorF -> varcte empty .)
    LESS_TH         reduce using rule 110 (factorF -> varcte empty .)
    GREAT_TH        reduce using rule 110 (factorF -> varcte empty .)
    SAME            reduce using rule 110 (factorF -> varcte empty .)
    DIF             reduce using rule 110 (factorF -> varcte empty .)
    ID              reduce using rule 110 (factorF -> varcte empty .)
    RETURN          reduce using rule 110 (factorF -> varcte empty .)
    READ            reduce using rule 110 (factorF -> varcte empty .)
    WRITE           reduce using rule 110 (factorF -> varcte empty .)
    IF              reduce using rule 110 (factorF -> varcte empty .)
    VAR             reduce using rule 110 (factorF -> varcte empty .)
    WHILE           reduce using rule 110 (factorF -> varcte empty .)
    FROM            reduce using rule 110 (factorF -> varcte empty .)
    R_CURPAR        reduce using rule 110 (factorF -> varcte empty .)
    SEMICOLON       reduce using rule 110 (factorF -> varcte empty .)
    COMMA           reduce using rule 110 (factorF -> varcte empty .)
    R_PAR           reduce using rule 110 (factorF -> varcte empty .)
    R_BREAK         reduce using rule 110 (factorF -> varcte empty .)
    TO              reduce using rule 110 (factorF -> varcte empty .)
    OR              reduce using rule 110 (factorF -> varcte empty .)
    AND             reduce using rule 110 (factorF -> varcte empty .)
    DO              reduce using rule 110 (factorF -> varcte empty .)


state 195

    (111) varcte -> var np_addId . empty
    (115) empty -> .

    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 247

state 196

    (112) varcte -> CTE_INT empty .

    MULT            reduce using rule 112 (varcte -> CTE_INT empty .)
    DIV             reduce using rule 112 (varcte -> CTE_INT empty .)
    PLUS            reduce using rule 112 (varcte -> CTE_INT empty .)
    MINUS           reduce using rule 112 (varcte -> CTE_INT empty .)
    LESS            reduce using rule 112 (varcte -> CTE_INT empty .)
    GREATER         reduce using rule 112 (varcte -> CTE_INT empty .)
    LESS_TH         reduce using rule 112 (varcte -> CTE_INT empty .)
    GREAT_TH        reduce using rule 112 (varcte -> CTE_INT empty .)
    SAME            reduce using rule 112 (varcte -> CTE_INT empty .)
    DIF             reduce using rule 112 (varcte -> CTE_INT empty .)
    ID              reduce using rule 112 (varcte -> CTE_INT empty .)
    RETURN          reduce using rule 112 (varcte -> CTE_INT empty .)
    READ            reduce using rule 112 (varcte -> CTE_INT empty .)
    WRITE           reduce using rule 112 (varcte -> CTE_INT empty .)
    IF              reduce using rule 112 (varcte -> CTE_INT empty .)
    VAR             reduce using rule 112 (varcte -> CTE_INT empty .)
    WHILE           reduce using rule 112 (varcte -> CTE_INT empty .)
    FROM            reduce using rule 112 (varcte -> CTE_INT empty .)
    R_CURPAR        reduce using rule 112 (varcte -> CTE_INT empty .)
    SEMICOLON       reduce using rule 112 (varcte -> CTE_INT empty .)
    COMMA           reduce using rule 112 (varcte -> CTE_INT empty .)
    R_PAR           reduce using rule 112 (varcte -> CTE_INT empty .)
    R_BREAK         reduce using rule 112 (varcte -> CTE_INT empty .)
    TO              reduce using rule 112 (varcte -> CTE_INT empty .)
    OR              reduce using rule 112 (varcte -> CTE_INT empty .)
    AND             reduce using rule 112 (varcte -> CTE_INT empty .)
    DO              reduce using rule 112 (varcte -> CTE_INT empty .)


state 197

    (113) varcte -> CTE_FLOAT empty .

    MULT            reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    DIV             reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    PLUS            reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    MINUS           reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    LESS            reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    GREATER         reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    LESS_TH         reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    GREAT_TH        reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    SAME            reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    DIF             reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    ID              reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    RETURN          reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    READ            reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    WRITE           reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    IF              reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    VAR             reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    WHILE           reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    FROM            reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    R_CURPAR        reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    SEMICOLON       reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    COMMA           reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    R_PAR           reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    R_BREAK         reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    TO              reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    OR              reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    AND             reduce using rule 113 (varcte -> CTE_FLOAT empty .)
    DO              reduce using rule 113 (varcte -> CTE_FLOAT empty .)


state 198

    (114) varcte -> CTE_CHAR empty .

    MULT            reduce using rule 114 (varcte -> CTE_CHAR empty .)
    DIV             reduce using rule 114 (varcte -> CTE_CHAR empty .)
    PLUS            reduce using rule 114 (varcte -> CTE_CHAR empty .)
    MINUS           reduce using rule 114 (varcte -> CTE_CHAR empty .)
    LESS            reduce using rule 114 (varcte -> CTE_CHAR empty .)
    GREATER         reduce using rule 114 (varcte -> CTE_CHAR empty .)
    LESS_TH         reduce using rule 114 (varcte -> CTE_CHAR empty .)
    GREAT_TH        reduce using rule 114 (varcte -> CTE_CHAR empty .)
    SAME            reduce using rule 114 (varcte -> CTE_CHAR empty .)
    DIF             reduce using rule 114 (varcte -> CTE_CHAR empty .)
    ID              reduce using rule 114 (varcte -> CTE_CHAR empty .)
    RETURN          reduce using rule 114 (varcte -> CTE_CHAR empty .)
    READ            reduce using rule 114 (varcte -> CTE_CHAR empty .)
    WRITE           reduce using rule 114 (varcte -> CTE_CHAR empty .)
    IF              reduce using rule 114 (varcte -> CTE_CHAR empty .)
    VAR             reduce using rule 114 (varcte -> CTE_CHAR empty .)
    WHILE           reduce using rule 114 (varcte -> CTE_CHAR empty .)
    FROM            reduce using rule 114 (varcte -> CTE_CHAR empty .)
    R_CURPAR        reduce using rule 114 (varcte -> CTE_CHAR empty .)
    SEMICOLON       reduce using rule 114 (varcte -> CTE_CHAR empty .)
    COMMA           reduce using rule 114 (varcte -> CTE_CHAR empty .)
    R_PAR           reduce using rule 114 (varcte -> CTE_CHAR empty .)
    R_BREAK         reduce using rule 114 (varcte -> CTE_CHAR empty .)
    TO              reduce using rule 114 (varcte -> CTE_CHAR empty .)
    OR              reduce using rule 114 (varcte -> CTE_CHAR empty .)
    AND             reduce using rule 114 (varcte -> CTE_CHAR empty .)
    DO              reduce using rule 114 (varcte -> CTE_CHAR empty .)


state 199

    (58) var -> ID DOT . VAR varF

    VAR             shift and go to state 157


state 200

    (76) assigmentF -> ope exp empty .

    ID              reduce using rule 76 (assigmentF -> ope exp empty .)
    RETURN          reduce using rule 76 (assigmentF -> ope exp empty .)
    READ            reduce using rule 76 (assigmentF -> ope exp empty .)
    WRITE           reduce using rule 76 (assigmentF -> ope exp empty .)
    IF              reduce using rule 76 (assigmentF -> ope exp empty .)
    VAR             reduce using rule 76 (assigmentF -> ope exp empty .)
    WHILE           reduce using rule 76 (assigmentF -> ope exp empty .)
    FROM            reduce using rule 76 (assigmentF -> ope exp empty .)
    R_CURPAR        reduce using rule 76 (assigmentF -> ope exp empty .)
    SEMICOLON       reduce using rule 76 (assigmentF -> ope exp empty .)


state 201

    (48) void -> ID DOT ID L_PAR . param R_PAR SEMICOLON empty
    (53) param -> . exp paramF
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    param                          shift and go to state 248
    exp                            shift and go to state 160
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 202

    (58) var -> ID DOT VAR varF .

    EQUAL           reduce using rule 58 (var -> ID DOT VAR varF .)
    PLUS_EQ         reduce using rule 58 (var -> ID DOT VAR varF .)
    MIN_EQ          reduce using rule 58 (var -> ID DOT VAR varF .)
    MULT_EQ         reduce using rule 58 (var -> ID DOT VAR varF .)
    DIV_EQ          reduce using rule 58 (var -> ID DOT VAR varF .)
    MULT            reduce using rule 58 (var -> ID DOT VAR varF .)
    DIV             reduce using rule 58 (var -> ID DOT VAR varF .)
    PLUS            reduce using rule 58 (var -> ID DOT VAR varF .)
    MINUS           reduce using rule 58 (var -> ID DOT VAR varF .)
    LESS            reduce using rule 58 (var -> ID DOT VAR varF .)
    GREATER         reduce using rule 58 (var -> ID DOT VAR varF .)
    LESS_TH         reduce using rule 58 (var -> ID DOT VAR varF .)
    GREAT_TH        reduce using rule 58 (var -> ID DOT VAR varF .)
    SAME            reduce using rule 58 (var -> ID DOT VAR varF .)
    DIF             reduce using rule 58 (var -> ID DOT VAR varF .)
    ID              reduce using rule 58 (var -> ID DOT VAR varF .)
    RETURN          reduce using rule 58 (var -> ID DOT VAR varF .)
    READ            reduce using rule 58 (var -> ID DOT VAR varF .)
    WRITE           reduce using rule 58 (var -> ID DOT VAR varF .)
    IF              reduce using rule 58 (var -> ID DOT VAR varF .)
    VAR             reduce using rule 58 (var -> ID DOT VAR varF .)
    WHILE           reduce using rule 58 (var -> ID DOT VAR varF .)
    FROM            reduce using rule 58 (var -> ID DOT VAR varF .)
    R_CURPAR        reduce using rule 58 (var -> ID DOT VAR varF .)
    SEMICOLON       reduce using rule 58 (var -> ID DOT VAR varF .)
    COMMA           reduce using rule 58 (var -> ID DOT VAR varF .)
    R_PAR           reduce using rule 58 (var -> ID DOT VAR varF .)
    R_BREAK         reduce using rule 58 (var -> ID DOT VAR varF .)
    TO              reduce using rule 58 (var -> ID DOT VAR varF .)
    OR              reduce using rule 58 (var -> ID DOT VAR varF .)
    AND             reduce using rule 58 (var -> ID DOT VAR varF .)
    DO              reduce using rule 58 (var -> ID DOT VAR varF .)


state 203

    (49) void -> ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 249


state 204

    (50) void -> ID L_PAR R_PAR SEMICOLON . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 250

state 205

    (53) param -> exp paramF .

    R_PAR           reduce using rule 53 (param -> exp paramF .)


state 206

    (54) paramF -> COMMA . param
    (53) param -> . exp paramF
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    param                          shift and go to state 251
    exp                            shift and go to state 160
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 207

    (55) paramF -> empty .

    R_PAR           reduce using rule 55 (paramF -> empty .)


state 208

    (56) return -> RETURN L_PAR exp R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 252


state 209

    (62) readF -> var COMMA . readF
    (62) readF -> . var COMMA readF
    (63) readF -> . var R_PAR SEMICOLON empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    VAR             shift and go to state 83
    ID              shift and go to state 150

    var                            shift and go to state 163
    readF                          shift and go to state 253

state 210

    (63) readF -> var R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 254


state 211

    (65) writeT -> CTE_CHAR writeF .

    ID              reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    RETURN          reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    READ            reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    WRITE           reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    IF              reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    VAR             reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    WHILE           reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    FROM            reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    R_CURPAR        reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    SEMICOLON       reduce using rule 65 (writeT -> CTE_CHAR writeF .)


state 212

    (67) writeF -> COMMA . writeT
    (65) writeT -> . CTE_CHAR writeF
    (66) writeT -> . exp writeF
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    CTE_CHAR        shift and go to state 165
    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    VAR             shift and go to state 83
    ID              shift and go to state 150

    writeT                         shift and go to state 255
    exp                            shift and go to state 166
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 213

    (68) writeF -> R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 256


state 214

    (66) writeT -> exp writeF .

    ID              reduce using rule 66 (writeT -> exp writeF .)
    RETURN          reduce using rule 66 (writeT -> exp writeF .)
    READ            reduce using rule 66 (writeT -> exp writeF .)
    WRITE           reduce using rule 66 (writeT -> exp writeF .)
    IF              reduce using rule 66 (writeT -> exp writeF .)
    VAR             reduce using rule 66 (writeT -> exp writeF .)
    WHILE           reduce using rule 66 (writeT -> exp writeF .)
    FROM            reduce using rule 66 (writeT -> exp writeF .)
    R_CURPAR        reduce using rule 66 (writeT -> exp writeF .)
    SEMICOLON       reduce using rule 66 (writeT -> exp writeF .)


state 215

    (71) if -> IF L_PAR exp R_PAR . THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    THEN            shift and go to state 257


state 216

    (51) arrfunc -> L_BREAK exp COMMA . exp R_BREAK empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 258
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 217

    (52) arrfunc -> L_BREAK exp R_BREAK . empty
    (115) empty -> .

    EQUAL           reduce using rule 115 (empty -> .)
    PLUS_EQ         reduce using rule 115 (empty -> .)
    MIN_EQ          reduce using rule 115 (empty -> .)
    MULT_EQ         reduce using rule 115 (empty -> .)
    DIV_EQ          reduce using rule 115 (empty -> .)
    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    L_PAR           reduce using rule 115 (empty -> .)
    CTE_INT         reduce using rule 115 (empty -> .)
    CTE_FLOAT       reduce using rule 115 (empty -> .)
    CTE_CHAR        reduce using rule 115 (empty -> .)

    empty                          shift and go to state 259

state 218

    (81) conditional -> WHILE L_PAR exp R_PAR . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 260


state 219

    (82) nonconditional -> FROM VAR arrfunc nonconditionalF .

    ID              reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    RETURN          reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    READ            reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WRITE           reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    IF              reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    VAR             reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WHILE           reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    FROM            reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    R_CURPAR        reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    SEMICOLON       reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)


state 220

    (84) nonconditionalF -> exp TO . exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 261
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 221

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR . SEMICOLON empty

    SEMICOLON       shift and go to state 262


state 222

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec dec .

    MAIN            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    INT             reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    FLOAT           reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    CHAR            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    ID              reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    VOID            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    METHODS         reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    L_CURPAR        reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)


state 223

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic . empty
    (115) empty -> .

    MAIN            reduce using rule 115 (empty -> .)
    INT             reduce using rule 115 (empty -> .)
    FLOAT           reduce using rule 115 (empty -> .)
    CHAR            reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    METHODS         reduce using rule 115 (empty -> .)
    L_CURPAR        reduce using rule 115 (empty -> .)

    empty                          shift and go to state 263

state 224

    (24) funcF -> parameter R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 26

    dec                            shift and go to state 264

state 225

    (25) funcF -> R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 265


state 226

    (31) parameter -> VAR COLON typepar . SEMICOLON parameterF

    SEMICOLON       shift and go to state 266


state 227

    (34) typepar -> INT . empty
    (115) empty -> .

    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 267

state 228

    (35) typepar -> FLOAT . empty
    (115) empty -> .

    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 268

state 229

    (36) typepar -> CHAR . empty
    (115) empty -> .

    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 269

state 230

    (37) typepar -> ID . empty
    (115) empty -> .

    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 270

state 231

    (88) expT -> LESS expf .

    ID              reduce using rule 88 (expT -> LESS expf .)
    RETURN          reduce using rule 88 (expT -> LESS expf .)
    READ            reduce using rule 88 (expT -> LESS expf .)
    WRITE           reduce using rule 88 (expT -> LESS expf .)
    IF              reduce using rule 88 (expT -> LESS expf .)
    VAR             reduce using rule 88 (expT -> LESS expf .)
    WHILE           reduce using rule 88 (expT -> LESS expf .)
    FROM            reduce using rule 88 (expT -> LESS expf .)
    R_CURPAR        reduce using rule 88 (expT -> LESS expf .)
    SEMICOLON       reduce using rule 88 (expT -> LESS expf .)
    COMMA           reduce using rule 88 (expT -> LESS expf .)
    R_PAR           reduce using rule 88 (expT -> LESS expf .)
    R_BREAK         reduce using rule 88 (expT -> LESS expf .)
    TO              reduce using rule 88 (expT -> LESS expf .)
    DO              reduce using rule 88 (expT -> LESS expf .)


state 232

    (95) expf -> ex . empty
    (96) expf -> ex . bool empty
    (115) empty -> .
    (85) bool -> . OR exp empty
    (86) bool -> . AND exp empty

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    OR              shift and go to state 273
    AND             shift and go to state 274

    empty                          shift and go to state 271
    bool                           shift and go to state 272

state 233

    (89) expT -> GREATER expf .

    ID              reduce using rule 89 (expT -> GREATER expf .)
    RETURN          reduce using rule 89 (expT -> GREATER expf .)
    READ            reduce using rule 89 (expT -> GREATER expf .)
    WRITE           reduce using rule 89 (expT -> GREATER expf .)
    IF              reduce using rule 89 (expT -> GREATER expf .)
    VAR             reduce using rule 89 (expT -> GREATER expf .)
    WHILE           reduce using rule 89 (expT -> GREATER expf .)
    FROM            reduce using rule 89 (expT -> GREATER expf .)
    R_CURPAR        reduce using rule 89 (expT -> GREATER expf .)
    SEMICOLON       reduce using rule 89 (expT -> GREATER expf .)
    COMMA           reduce using rule 89 (expT -> GREATER expf .)
    R_PAR           reduce using rule 89 (expT -> GREATER expf .)
    R_BREAK         reduce using rule 89 (expT -> GREATER expf .)
    TO              reduce using rule 89 (expT -> GREATER expf .)
    DO              reduce using rule 89 (expT -> GREATER expf .)


state 234

    (90) expT -> LESS_TH expf .

    ID              reduce using rule 90 (expT -> LESS_TH expf .)
    RETURN          reduce using rule 90 (expT -> LESS_TH expf .)
    READ            reduce using rule 90 (expT -> LESS_TH expf .)
    WRITE           reduce using rule 90 (expT -> LESS_TH expf .)
    IF              reduce using rule 90 (expT -> LESS_TH expf .)
    VAR             reduce using rule 90 (expT -> LESS_TH expf .)
    WHILE           reduce using rule 90 (expT -> LESS_TH expf .)
    FROM            reduce using rule 90 (expT -> LESS_TH expf .)
    R_CURPAR        reduce using rule 90 (expT -> LESS_TH expf .)
    SEMICOLON       reduce using rule 90 (expT -> LESS_TH expf .)
    COMMA           reduce using rule 90 (expT -> LESS_TH expf .)
    R_PAR           reduce using rule 90 (expT -> LESS_TH expf .)
    R_BREAK         reduce using rule 90 (expT -> LESS_TH expf .)
    TO              reduce using rule 90 (expT -> LESS_TH expf .)
    DO              reduce using rule 90 (expT -> LESS_TH expf .)


state 235

    (91) expT -> GREAT_TH expf .

    ID              reduce using rule 91 (expT -> GREAT_TH expf .)
    RETURN          reduce using rule 91 (expT -> GREAT_TH expf .)
    READ            reduce using rule 91 (expT -> GREAT_TH expf .)
    WRITE           reduce using rule 91 (expT -> GREAT_TH expf .)
    IF              reduce using rule 91 (expT -> GREAT_TH expf .)
    VAR             reduce using rule 91 (expT -> GREAT_TH expf .)
    WHILE           reduce using rule 91 (expT -> GREAT_TH expf .)
    FROM            reduce using rule 91 (expT -> GREAT_TH expf .)
    R_CURPAR        reduce using rule 91 (expT -> GREAT_TH expf .)
    SEMICOLON       reduce using rule 91 (expT -> GREAT_TH expf .)
    COMMA           reduce using rule 91 (expT -> GREAT_TH expf .)
    R_PAR           reduce using rule 91 (expT -> GREAT_TH expf .)
    R_BREAK         reduce using rule 91 (expT -> GREAT_TH expf .)
    TO              reduce using rule 91 (expT -> GREAT_TH expf .)
    DO              reduce using rule 91 (expT -> GREAT_TH expf .)


state 236

    (92) expT -> SAME expf .

    ID              reduce using rule 92 (expT -> SAME expf .)
    RETURN          reduce using rule 92 (expT -> SAME expf .)
    READ            reduce using rule 92 (expT -> SAME expf .)
    WRITE           reduce using rule 92 (expT -> SAME expf .)
    IF              reduce using rule 92 (expT -> SAME expf .)
    VAR             reduce using rule 92 (expT -> SAME expf .)
    WHILE           reduce using rule 92 (expT -> SAME expf .)
    FROM            reduce using rule 92 (expT -> SAME expf .)
    R_CURPAR        reduce using rule 92 (expT -> SAME expf .)
    SEMICOLON       reduce using rule 92 (expT -> SAME expf .)
    COMMA           reduce using rule 92 (expT -> SAME expf .)
    R_PAR           reduce using rule 92 (expT -> SAME expf .)
    R_BREAK         reduce using rule 92 (expT -> SAME expf .)
    TO              reduce using rule 92 (expT -> SAME expf .)
    DO              reduce using rule 92 (expT -> SAME expf .)


state 237

    (93) expT -> DIF expf .

    ID              reduce using rule 93 (expT -> DIF expf .)
    RETURN          reduce using rule 93 (expT -> DIF expf .)
    READ            reduce using rule 93 (expT -> DIF expf .)
    WRITE           reduce using rule 93 (expT -> DIF expf .)
    IF              reduce using rule 93 (expT -> DIF expf .)
    VAR             reduce using rule 93 (expT -> DIF expf .)
    WHILE           reduce using rule 93 (expT -> DIF expf .)
    FROM            reduce using rule 93 (expT -> DIF expf .)
    R_CURPAR        reduce using rule 93 (expT -> DIF expf .)
    SEMICOLON       reduce using rule 93 (expT -> DIF expf .)
    COMMA           reduce using rule 93 (expT -> DIF expf .)
    R_PAR           reduce using rule 93 (expT -> DIF expf .)
    R_BREAK         reduce using rule 93 (expT -> DIF expf .)
    TO              reduce using rule 93 (expT -> DIF expf .)
    DO              reduce using rule 93 (expT -> DIF expf .)


state 238

    (97) ex -> term np_addEx exF .

    LESS            reduce using rule 97 (ex -> term np_addEx exF .)
    GREATER         reduce using rule 97 (ex -> term np_addEx exF .)
    LESS_TH         reduce using rule 97 (ex -> term np_addEx exF .)
    GREAT_TH        reduce using rule 97 (ex -> term np_addEx exF .)
    SAME            reduce using rule 97 (ex -> term np_addEx exF .)
    DIF             reduce using rule 97 (ex -> term np_addEx exF .)
    ID              reduce using rule 97 (ex -> term np_addEx exF .)
    RETURN          reduce using rule 97 (ex -> term np_addEx exF .)
    READ            reduce using rule 97 (ex -> term np_addEx exF .)
    WRITE           reduce using rule 97 (ex -> term np_addEx exF .)
    IF              reduce using rule 97 (ex -> term np_addEx exF .)
    VAR             reduce using rule 97 (ex -> term np_addEx exF .)
    WHILE           reduce using rule 97 (ex -> term np_addEx exF .)
    FROM            reduce using rule 97 (ex -> term np_addEx exF .)
    R_CURPAR        reduce using rule 97 (ex -> term np_addEx exF .)
    SEMICOLON       reduce using rule 97 (ex -> term np_addEx exF .)
    COMMA           reduce using rule 97 (ex -> term np_addEx exF .)
    R_PAR           reduce using rule 97 (ex -> term np_addEx exF .)
    R_BREAK         reduce using rule 97 (ex -> term np_addEx exF .)
    TO              reduce using rule 97 (ex -> term np_addEx exF .)
    OR              reduce using rule 97 (ex -> term np_addEx exF .)
    AND             reduce using rule 97 (ex -> term np_addEx exF .)
    DO              reduce using rule 97 (ex -> term np_addEx exF .)


state 239

    (98) exF -> PLUS . np_addOp ex
    (123) np_addOp -> .

    L_PAR           reduce using rule 123 (np_addOp -> .)
    PLUS            reduce using rule 123 (np_addOp -> .)
    MINUS           reduce using rule 123 (np_addOp -> .)
    CTE_INT         reduce using rule 123 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 123 (np_addOp -> .)
    CTE_CHAR        reduce using rule 123 (np_addOp -> .)
    VAR             reduce using rule 123 (np_addOp -> .)
    ID              reduce using rule 123 (np_addOp -> .)

    np_addOp                       shift and go to state 275

state 240

    (99) exF -> MINUS . np_addOp ex
    (123) np_addOp -> .

    L_PAR           reduce using rule 123 (np_addOp -> .)
    PLUS            reduce using rule 123 (np_addOp -> .)
    MINUS           reduce using rule 123 (np_addOp -> .)
    CTE_INT         reduce using rule 123 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 123 (np_addOp -> .)
    CTE_CHAR        reduce using rule 123 (np_addOp -> .)
    VAR             reduce using rule 123 (np_addOp -> .)
    ID              reduce using rule 123 (np_addOp -> .)

    np_addOp                       shift and go to state 276

state 241

    (100) exF -> empty .

    LESS            reduce using rule 100 (exF -> empty .)
    GREATER         reduce using rule 100 (exF -> empty .)
    LESS_TH         reduce using rule 100 (exF -> empty .)
    GREAT_TH        reduce using rule 100 (exF -> empty .)
    SAME            reduce using rule 100 (exF -> empty .)
    DIF             reduce using rule 100 (exF -> empty .)
    ID              reduce using rule 100 (exF -> empty .)
    RETURN          reduce using rule 100 (exF -> empty .)
    READ            reduce using rule 100 (exF -> empty .)
    WRITE           reduce using rule 100 (exF -> empty .)
    IF              reduce using rule 100 (exF -> empty .)
    VAR             reduce using rule 100 (exF -> empty .)
    WHILE           reduce using rule 100 (exF -> empty .)
    FROM            reduce using rule 100 (exF -> empty .)
    R_CURPAR        reduce using rule 100 (exF -> empty .)
    SEMICOLON       reduce using rule 100 (exF -> empty .)
    COMMA           reduce using rule 100 (exF -> empty .)
    R_PAR           reduce using rule 100 (exF -> empty .)
    R_BREAK         reduce using rule 100 (exF -> empty .)
    TO              reduce using rule 100 (exF -> empty .)
    OR              reduce using rule 100 (exF -> empty .)
    AND             reduce using rule 100 (exF -> empty .)
    DO              reduce using rule 100 (exF -> empty .)


state 242

    (101) term -> factor np_addTerm termF .

    PLUS            reduce using rule 101 (term -> factor np_addTerm termF .)
    MINUS           reduce using rule 101 (term -> factor np_addTerm termF .)
    LESS            reduce using rule 101 (term -> factor np_addTerm termF .)
    GREATER         reduce using rule 101 (term -> factor np_addTerm termF .)
    LESS_TH         reduce using rule 101 (term -> factor np_addTerm termF .)
    GREAT_TH        reduce using rule 101 (term -> factor np_addTerm termF .)
    SAME            reduce using rule 101 (term -> factor np_addTerm termF .)
    DIF             reduce using rule 101 (term -> factor np_addTerm termF .)
    ID              reduce using rule 101 (term -> factor np_addTerm termF .)
    RETURN          reduce using rule 101 (term -> factor np_addTerm termF .)
    READ            reduce using rule 101 (term -> factor np_addTerm termF .)
    WRITE           reduce using rule 101 (term -> factor np_addTerm termF .)
    IF              reduce using rule 101 (term -> factor np_addTerm termF .)
    VAR             reduce using rule 101 (term -> factor np_addTerm termF .)
    WHILE           reduce using rule 101 (term -> factor np_addTerm termF .)
    FROM            reduce using rule 101 (term -> factor np_addTerm termF .)
    R_CURPAR        reduce using rule 101 (term -> factor np_addTerm termF .)
    SEMICOLON       reduce using rule 101 (term -> factor np_addTerm termF .)
    COMMA           reduce using rule 101 (term -> factor np_addTerm termF .)
    R_PAR           reduce using rule 101 (term -> factor np_addTerm termF .)
    R_BREAK         reduce using rule 101 (term -> factor np_addTerm termF .)
    TO              reduce using rule 101 (term -> factor np_addTerm termF .)
    OR              reduce using rule 101 (term -> factor np_addTerm termF .)
    AND             reduce using rule 101 (term -> factor np_addTerm termF .)
    DO              reduce using rule 101 (term -> factor np_addTerm termF .)


state 243

    (102) termF -> MULT . np_addOp term
    (123) np_addOp -> .

    L_PAR           reduce using rule 123 (np_addOp -> .)
    PLUS            reduce using rule 123 (np_addOp -> .)
    MINUS           reduce using rule 123 (np_addOp -> .)
    CTE_INT         reduce using rule 123 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 123 (np_addOp -> .)
    CTE_CHAR        reduce using rule 123 (np_addOp -> .)
    VAR             reduce using rule 123 (np_addOp -> .)
    ID              reduce using rule 123 (np_addOp -> .)

    np_addOp                       shift and go to state 277

state 244

    (103) termF -> DIV . np_addOp term
    (123) np_addOp -> .

    L_PAR           reduce using rule 123 (np_addOp -> .)
    PLUS            reduce using rule 123 (np_addOp -> .)
    MINUS           reduce using rule 123 (np_addOp -> .)
    CTE_INT         reduce using rule 123 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 123 (np_addOp -> .)
    CTE_CHAR        reduce using rule 123 (np_addOp -> .)
    VAR             reduce using rule 123 (np_addOp -> .)
    ID              reduce using rule 123 (np_addOp -> .)

    np_addOp                       shift and go to state 278

state 245

    (104) termF -> empty .

    PLUS            reduce using rule 104 (termF -> empty .)
    MINUS           reduce using rule 104 (termF -> empty .)
    LESS            reduce using rule 104 (termF -> empty .)
    GREATER         reduce using rule 104 (termF -> empty .)
    LESS_TH         reduce using rule 104 (termF -> empty .)
    GREAT_TH        reduce using rule 104 (termF -> empty .)
    SAME            reduce using rule 104 (termF -> empty .)
    DIF             reduce using rule 104 (termF -> empty .)
    ID              reduce using rule 104 (termF -> empty .)
    RETURN          reduce using rule 104 (termF -> empty .)
    READ            reduce using rule 104 (termF -> empty .)
    WRITE           reduce using rule 104 (termF -> empty .)
    IF              reduce using rule 104 (termF -> empty .)
    VAR             reduce using rule 104 (termF -> empty .)
    WHILE           reduce using rule 104 (termF -> empty .)
    FROM            reduce using rule 104 (termF -> empty .)
    R_CURPAR        reduce using rule 104 (termF -> empty .)
    SEMICOLON       reduce using rule 104 (termF -> empty .)
    COMMA           reduce using rule 104 (termF -> empty .)
    R_PAR           reduce using rule 104 (termF -> empty .)
    R_BREAK         reduce using rule 104 (termF -> empty .)
    TO              reduce using rule 104 (termF -> empty .)
    OR              reduce using rule 104 (termF -> empty .)
    AND             reduce using rule 104 (termF -> empty .)
    DO              reduce using rule 104 (termF -> empty .)


state 246

    (105) factor -> L_PAR np_addPar exp . R_PAR np_popPar empty

    R_PAR           shift and go to state 279


state 247

    (111) varcte -> var np_addId empty .

    MULT            reduce using rule 111 (varcte -> var np_addId empty .)
    DIV             reduce using rule 111 (varcte -> var np_addId empty .)
    PLUS            reduce using rule 111 (varcte -> var np_addId empty .)
    MINUS           reduce using rule 111 (varcte -> var np_addId empty .)
    LESS            reduce using rule 111 (varcte -> var np_addId empty .)
    GREATER         reduce using rule 111 (varcte -> var np_addId empty .)
    LESS_TH         reduce using rule 111 (varcte -> var np_addId empty .)
    GREAT_TH        reduce using rule 111 (varcte -> var np_addId empty .)
    SAME            reduce using rule 111 (varcte -> var np_addId empty .)
    DIF             reduce using rule 111 (varcte -> var np_addId empty .)
    ID              reduce using rule 111 (varcte -> var np_addId empty .)
    RETURN          reduce using rule 111 (varcte -> var np_addId empty .)
    READ            reduce using rule 111 (varcte -> var np_addId empty .)
    WRITE           reduce using rule 111 (varcte -> var np_addId empty .)
    IF              reduce using rule 111 (varcte -> var np_addId empty .)
    VAR             reduce using rule 111 (varcte -> var np_addId empty .)
    WHILE           reduce using rule 111 (varcte -> var np_addId empty .)
    FROM            reduce using rule 111 (varcte -> var np_addId empty .)
    R_CURPAR        reduce using rule 111 (varcte -> var np_addId empty .)
    SEMICOLON       reduce using rule 111 (varcte -> var np_addId empty .)
    COMMA           reduce using rule 111 (varcte -> var np_addId empty .)
    R_PAR           reduce using rule 111 (varcte -> var np_addId empty .)
    R_BREAK         reduce using rule 111 (varcte -> var np_addId empty .)
    TO              reduce using rule 111 (varcte -> var np_addId empty .)
    OR              reduce using rule 111 (varcte -> var np_addId empty .)
    AND             reduce using rule 111 (varcte -> var np_addId empty .)
    DO              reduce using rule 111 (varcte -> var np_addId empty .)


state 248

    (48) void -> ID DOT ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 280


state 249

    (49) void -> ID L_PAR param R_PAR SEMICOLON . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 281

state 250

    (50) void -> ID L_PAR R_PAR SEMICOLON empty .

    ID              reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    READ            reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    IF              reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    VAR             reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    FROM            reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)


state 251

    (54) paramF -> COMMA param .

    R_PAR           reduce using rule 54 (paramF -> COMMA param .)


state 252

    (56) return -> RETURN L_PAR exp R_PAR SEMICOLON . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 282

state 253

    (62) readF -> var COMMA readF .

    ID              reduce using rule 62 (readF -> var COMMA readF .)
    RETURN          reduce using rule 62 (readF -> var COMMA readF .)
    READ            reduce using rule 62 (readF -> var COMMA readF .)
    WRITE           reduce using rule 62 (readF -> var COMMA readF .)
    IF              reduce using rule 62 (readF -> var COMMA readF .)
    VAR             reduce using rule 62 (readF -> var COMMA readF .)
    WHILE           reduce using rule 62 (readF -> var COMMA readF .)
    FROM            reduce using rule 62 (readF -> var COMMA readF .)
    R_CURPAR        reduce using rule 62 (readF -> var COMMA readF .)
    SEMICOLON       reduce using rule 62 (readF -> var COMMA readF .)


state 254

    (63) readF -> var R_PAR SEMICOLON . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 283

state 255

    (67) writeF -> COMMA writeT .

    ID              reduce using rule 67 (writeF -> COMMA writeT .)
    RETURN          reduce using rule 67 (writeF -> COMMA writeT .)
    READ            reduce using rule 67 (writeF -> COMMA writeT .)
    WRITE           reduce using rule 67 (writeF -> COMMA writeT .)
    IF              reduce using rule 67 (writeF -> COMMA writeT .)
    VAR             reduce using rule 67 (writeF -> COMMA writeT .)
    WHILE           reduce using rule 67 (writeF -> COMMA writeT .)
    FROM            reduce using rule 67 (writeF -> COMMA writeT .)
    R_CURPAR        reduce using rule 67 (writeF -> COMMA writeT .)
    SEMICOLON       reduce using rule 67 (writeF -> COMMA writeT .)


state 256

    (68) writeF -> R_PAR SEMICOLON . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 284

state 257

    (71) if -> IF L_PAR exp R_PAR THEN . L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_CURPAR        shift and go to state 285


state 258

    (51) arrfunc -> L_BREAK exp COMMA exp . R_BREAK empty

    R_BREAK         shift and go to state 286


state 259

    (52) arrfunc -> L_BREAK exp R_BREAK empty .

    EQUAL           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MIN_EQ          reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT_EQ         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV_EQ          reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV             reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MINUS           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREATER         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS_TH         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREAT_TH        reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SAME            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIF             reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    ID              reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    RETURN          reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    READ            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WRITE           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    IF              reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    VAR             reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WHILE           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    FROM            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_CURPAR        reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SEMICOLON       reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    COMMA           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_PAR           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_BREAK         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    TO              reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    OR              reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    AND             reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DO              reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    L_PAR           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_INT         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)


state 260

    (81) conditional -> WHILE L_PAR exp R_PAR DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 287


state 261

    (84) nonconditionalF -> exp TO exp . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 288


state 262

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON . empty
    (115) empty -> .

    CLASS           reduce using rule 115 (empty -> .)
    VARS            reduce using rule 115 (empty -> .)
    MAIN            reduce using rule 115 (empty -> .)
    INT             reduce using rule 115 (empty -> .)
    FLOAT           reduce using rule 115 (empty -> .)
    CHAR            reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 289

state 263

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .

    MAIN            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    INT             reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    FLOAT           reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    CHAR            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    ID              reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    VOID            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    METHODS         reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    L_CURPAR        reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)


state 264

    (24) funcF -> parameter R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 290


state 265

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 291
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 266

    (31) parameter -> VAR COLON typepar SEMICOLON . parameterF
    (32) parameterF -> . parameter
    (33) parameterF -> . empty
    (31) parameter -> . VAR COLON typepar SEMICOLON parameterF
    (115) empty -> .

    VAR             shift and go to state 134
    R_PAR           reduce using rule 115 (empty -> .)

    parameterF                     shift and go to state 292
    parameter                      shift and go to state 293
    empty                          shift and go to state 294

state 267

    (34) typepar -> INT empty .

    SEMICOLON       reduce using rule 34 (typepar -> INT empty .)


state 268

    (35) typepar -> FLOAT empty .

    SEMICOLON       reduce using rule 35 (typepar -> FLOAT empty .)


state 269

    (36) typepar -> CHAR empty .

    SEMICOLON       reduce using rule 36 (typepar -> CHAR empty .)


state 270

    (37) typepar -> ID empty .

    SEMICOLON       reduce using rule 37 (typepar -> ID empty .)


state 271

    (95) expf -> ex empty .

    ID              reduce using rule 95 (expf -> ex empty .)
    RETURN          reduce using rule 95 (expf -> ex empty .)
    READ            reduce using rule 95 (expf -> ex empty .)
    WRITE           reduce using rule 95 (expf -> ex empty .)
    IF              reduce using rule 95 (expf -> ex empty .)
    VAR             reduce using rule 95 (expf -> ex empty .)
    WHILE           reduce using rule 95 (expf -> ex empty .)
    FROM            reduce using rule 95 (expf -> ex empty .)
    R_CURPAR        reduce using rule 95 (expf -> ex empty .)
    SEMICOLON       reduce using rule 95 (expf -> ex empty .)
    COMMA           reduce using rule 95 (expf -> ex empty .)
    R_PAR           reduce using rule 95 (expf -> ex empty .)
    R_BREAK         reduce using rule 95 (expf -> ex empty .)
    TO              reduce using rule 95 (expf -> ex empty .)
    DO              reduce using rule 95 (expf -> ex empty .)


state 272

    (96) expf -> ex bool . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 295

state 273

    (85) bool -> OR . exp empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 296
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 274

    (86) bool -> AND . exp empty
    (87) exp -> . ex expT
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    exp                            shift and go to state 297
    ex                             shift and go to state 137
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 275

    (98) exF -> PLUS np_addOp . ex
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    ex                             shift and go to state 298
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 276

    (99) exF -> MINUS np_addOp . ex
    (97) ex -> . term np_addEx exF
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    ex                             shift and go to state 299
    term                           shift and go to state 138
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 277

    (102) termF -> MULT np_addOp . term
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    term                           shift and go to state 300
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 278

    (103) termF -> DIV np_addOp . term
    (101) term -> . factor np_addTerm termF
    (105) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (106) factor -> . factorT
    (107) factorT -> . PLUS factorF
    (108) factorT -> . MINUS factorF
    (109) factorT -> . factorF
    (110) factorF -> . varcte empty
    (111) varcte -> . var np_addId empty
    (112) varcte -> . CTE_INT empty
    (113) varcte -> . CTE_FLOAT empty
    (114) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 142
    MINUS           shift and go to state 144
    CTE_INT         shift and go to state 147
    CTE_FLOAT       shift and go to state 148
    CTE_CHAR        shift and go to state 149
    VAR             shift and go to state 83
    ID              shift and go to state 150

    term                           shift and go to state 301
    factor                         shift and go to state 139
    factorT                        shift and go to state 141
    factorF                        shift and go to state 143
    varcte                         shift and go to state 145
    var                            shift and go to state 146

state 279

    (105) factor -> L_PAR np_addPar exp R_PAR . np_popPar empty
    (125) np_popPar -> .

    MULT            reduce using rule 125 (np_popPar -> .)
    DIV             reduce using rule 125 (np_popPar -> .)
    PLUS            reduce using rule 125 (np_popPar -> .)
    MINUS           reduce using rule 125 (np_popPar -> .)
    LESS            reduce using rule 125 (np_popPar -> .)
    GREATER         reduce using rule 125 (np_popPar -> .)
    LESS_TH         reduce using rule 125 (np_popPar -> .)
    GREAT_TH        reduce using rule 125 (np_popPar -> .)
    SAME            reduce using rule 125 (np_popPar -> .)
    DIF             reduce using rule 125 (np_popPar -> .)
    ID              reduce using rule 125 (np_popPar -> .)
    RETURN          reduce using rule 125 (np_popPar -> .)
    READ            reduce using rule 125 (np_popPar -> .)
    WRITE           reduce using rule 125 (np_popPar -> .)
    IF              reduce using rule 125 (np_popPar -> .)
    VAR             reduce using rule 125 (np_popPar -> .)
    WHILE           reduce using rule 125 (np_popPar -> .)
    FROM            reduce using rule 125 (np_popPar -> .)
    R_CURPAR        reduce using rule 125 (np_popPar -> .)
    SEMICOLON       reduce using rule 125 (np_popPar -> .)
    COMMA           reduce using rule 125 (np_popPar -> .)
    R_PAR           reduce using rule 125 (np_popPar -> .)
    R_BREAK         reduce using rule 125 (np_popPar -> .)
    TO              reduce using rule 125 (np_popPar -> .)
    OR              reduce using rule 125 (np_popPar -> .)
    AND             reduce using rule 125 (np_popPar -> .)
    DO              reduce using rule 125 (np_popPar -> .)

    np_popPar                      shift and go to state 302

state 280

    (48) void -> ID DOT ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 303


state 281

    (49) void -> ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)


state 282

    (56) return -> RETURN L_PAR exp R_PAR SEMICOLON empty .

    ID              reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    READ            reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    IF              reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    VAR             reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    FROM            reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)


state 283

    (63) readF -> var R_PAR SEMICOLON empty .

    ID              reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    READ            reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    IF              reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    VAR             reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    FROM            reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)


state 284

    (68) writeF -> R_PAR SEMICOLON empty .

    ID              reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    READ            reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    IF              reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    VAR             reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    FROM            reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)


state 285

    (71) if -> IF L_PAR exp R_PAR THEN L_CURPAR . statement SEMICOLON R_CURPAR ifF
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 304
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 286

    (51) arrfunc -> L_BREAK exp COMMA exp R_BREAK . empty
    (115) empty -> .

    EQUAL           reduce using rule 115 (empty -> .)
    PLUS_EQ         reduce using rule 115 (empty -> .)
    MIN_EQ          reduce using rule 115 (empty -> .)
    MULT_EQ         reduce using rule 115 (empty -> .)
    DIV_EQ          reduce using rule 115 (empty -> .)
    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    L_PAR           reduce using rule 115 (empty -> .)
    CTE_INT         reduce using rule 115 (empty -> .)
    CTE_FLOAT       reduce using rule 115 (empty -> .)
    CTE_CHAR        reduce using rule 115 (empty -> .)

    empty                          shift and go to state 305

state 287

    (81) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 306
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 288

    (84) nonconditionalF -> exp TO exp DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 307


state 289

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .

    CLASS           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VARS            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    MAIN            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    INT             reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    FLOAT           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    CHAR            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    ID              reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VOID            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)


state 290

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 308
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 291

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 309


state 292

    (31) parameter -> VAR COLON typepar SEMICOLON parameterF .

    R_PAR           reduce using rule 31 (parameter -> VAR COLON typepar SEMICOLON parameterF .)


state 293

    (32) parameterF -> parameter .

    R_PAR           reduce using rule 32 (parameterF -> parameter .)


state 294

    (33) parameterF -> empty .

    R_PAR           reduce using rule 33 (parameterF -> empty .)


state 295

    (96) expf -> ex bool empty .

    ID              reduce using rule 96 (expf -> ex bool empty .)
    RETURN          reduce using rule 96 (expf -> ex bool empty .)
    READ            reduce using rule 96 (expf -> ex bool empty .)
    WRITE           reduce using rule 96 (expf -> ex bool empty .)
    IF              reduce using rule 96 (expf -> ex bool empty .)
    VAR             reduce using rule 96 (expf -> ex bool empty .)
    WHILE           reduce using rule 96 (expf -> ex bool empty .)
    FROM            reduce using rule 96 (expf -> ex bool empty .)
    R_CURPAR        reduce using rule 96 (expf -> ex bool empty .)
    SEMICOLON       reduce using rule 96 (expf -> ex bool empty .)
    COMMA           reduce using rule 96 (expf -> ex bool empty .)
    R_PAR           reduce using rule 96 (expf -> ex bool empty .)
    R_BREAK         reduce using rule 96 (expf -> ex bool empty .)
    TO              reduce using rule 96 (expf -> ex bool empty .)
    DO              reduce using rule 96 (expf -> ex bool empty .)


state 296

    (85) bool -> OR exp . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 310

state 297

    (86) bool -> AND exp . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 311

state 298

    (98) exF -> PLUS np_addOp ex .

    LESS            reduce using rule 98 (exF -> PLUS np_addOp ex .)
    GREATER         reduce using rule 98 (exF -> PLUS np_addOp ex .)
    LESS_TH         reduce using rule 98 (exF -> PLUS np_addOp ex .)
    GREAT_TH        reduce using rule 98 (exF -> PLUS np_addOp ex .)
    SAME            reduce using rule 98 (exF -> PLUS np_addOp ex .)
    DIF             reduce using rule 98 (exF -> PLUS np_addOp ex .)
    ID              reduce using rule 98 (exF -> PLUS np_addOp ex .)
    RETURN          reduce using rule 98 (exF -> PLUS np_addOp ex .)
    READ            reduce using rule 98 (exF -> PLUS np_addOp ex .)
    WRITE           reduce using rule 98 (exF -> PLUS np_addOp ex .)
    IF              reduce using rule 98 (exF -> PLUS np_addOp ex .)
    VAR             reduce using rule 98 (exF -> PLUS np_addOp ex .)
    WHILE           reduce using rule 98 (exF -> PLUS np_addOp ex .)
    FROM            reduce using rule 98 (exF -> PLUS np_addOp ex .)
    R_CURPAR        reduce using rule 98 (exF -> PLUS np_addOp ex .)
    SEMICOLON       reduce using rule 98 (exF -> PLUS np_addOp ex .)
    COMMA           reduce using rule 98 (exF -> PLUS np_addOp ex .)
    R_PAR           reduce using rule 98 (exF -> PLUS np_addOp ex .)
    R_BREAK         reduce using rule 98 (exF -> PLUS np_addOp ex .)
    TO              reduce using rule 98 (exF -> PLUS np_addOp ex .)
    OR              reduce using rule 98 (exF -> PLUS np_addOp ex .)
    AND             reduce using rule 98 (exF -> PLUS np_addOp ex .)
    DO              reduce using rule 98 (exF -> PLUS np_addOp ex .)


state 299

    (99) exF -> MINUS np_addOp ex .

    LESS            reduce using rule 99 (exF -> MINUS np_addOp ex .)
    GREATER         reduce using rule 99 (exF -> MINUS np_addOp ex .)
    LESS_TH         reduce using rule 99 (exF -> MINUS np_addOp ex .)
    GREAT_TH        reduce using rule 99 (exF -> MINUS np_addOp ex .)
    SAME            reduce using rule 99 (exF -> MINUS np_addOp ex .)
    DIF             reduce using rule 99 (exF -> MINUS np_addOp ex .)
    ID              reduce using rule 99 (exF -> MINUS np_addOp ex .)
    RETURN          reduce using rule 99 (exF -> MINUS np_addOp ex .)
    READ            reduce using rule 99 (exF -> MINUS np_addOp ex .)
    WRITE           reduce using rule 99 (exF -> MINUS np_addOp ex .)
    IF              reduce using rule 99 (exF -> MINUS np_addOp ex .)
    VAR             reduce using rule 99 (exF -> MINUS np_addOp ex .)
    WHILE           reduce using rule 99 (exF -> MINUS np_addOp ex .)
    FROM            reduce using rule 99 (exF -> MINUS np_addOp ex .)
    R_CURPAR        reduce using rule 99 (exF -> MINUS np_addOp ex .)
    SEMICOLON       reduce using rule 99 (exF -> MINUS np_addOp ex .)
    COMMA           reduce using rule 99 (exF -> MINUS np_addOp ex .)
    R_PAR           reduce using rule 99 (exF -> MINUS np_addOp ex .)
    R_BREAK         reduce using rule 99 (exF -> MINUS np_addOp ex .)
    TO              reduce using rule 99 (exF -> MINUS np_addOp ex .)
    OR              reduce using rule 99 (exF -> MINUS np_addOp ex .)
    AND             reduce using rule 99 (exF -> MINUS np_addOp ex .)
    DO              reduce using rule 99 (exF -> MINUS np_addOp ex .)


state 300

    (102) termF -> MULT np_addOp term .

    PLUS            reduce using rule 102 (termF -> MULT np_addOp term .)
    MINUS           reduce using rule 102 (termF -> MULT np_addOp term .)
    LESS            reduce using rule 102 (termF -> MULT np_addOp term .)
    GREATER         reduce using rule 102 (termF -> MULT np_addOp term .)
    LESS_TH         reduce using rule 102 (termF -> MULT np_addOp term .)
    GREAT_TH        reduce using rule 102 (termF -> MULT np_addOp term .)
    SAME            reduce using rule 102 (termF -> MULT np_addOp term .)
    DIF             reduce using rule 102 (termF -> MULT np_addOp term .)
    ID              reduce using rule 102 (termF -> MULT np_addOp term .)
    RETURN          reduce using rule 102 (termF -> MULT np_addOp term .)
    READ            reduce using rule 102 (termF -> MULT np_addOp term .)
    WRITE           reduce using rule 102 (termF -> MULT np_addOp term .)
    IF              reduce using rule 102 (termF -> MULT np_addOp term .)
    VAR             reduce using rule 102 (termF -> MULT np_addOp term .)
    WHILE           reduce using rule 102 (termF -> MULT np_addOp term .)
    FROM            reduce using rule 102 (termF -> MULT np_addOp term .)
    R_CURPAR        reduce using rule 102 (termF -> MULT np_addOp term .)
    SEMICOLON       reduce using rule 102 (termF -> MULT np_addOp term .)
    COMMA           reduce using rule 102 (termF -> MULT np_addOp term .)
    R_PAR           reduce using rule 102 (termF -> MULT np_addOp term .)
    R_BREAK         reduce using rule 102 (termF -> MULT np_addOp term .)
    TO              reduce using rule 102 (termF -> MULT np_addOp term .)
    OR              reduce using rule 102 (termF -> MULT np_addOp term .)
    AND             reduce using rule 102 (termF -> MULT np_addOp term .)
    DO              reduce using rule 102 (termF -> MULT np_addOp term .)


state 301

    (103) termF -> DIV np_addOp term .

    PLUS            reduce using rule 103 (termF -> DIV np_addOp term .)
    MINUS           reduce using rule 103 (termF -> DIV np_addOp term .)
    LESS            reduce using rule 103 (termF -> DIV np_addOp term .)
    GREATER         reduce using rule 103 (termF -> DIV np_addOp term .)
    LESS_TH         reduce using rule 103 (termF -> DIV np_addOp term .)
    GREAT_TH        reduce using rule 103 (termF -> DIV np_addOp term .)
    SAME            reduce using rule 103 (termF -> DIV np_addOp term .)
    DIF             reduce using rule 103 (termF -> DIV np_addOp term .)
    ID              reduce using rule 103 (termF -> DIV np_addOp term .)
    RETURN          reduce using rule 103 (termF -> DIV np_addOp term .)
    READ            reduce using rule 103 (termF -> DIV np_addOp term .)
    WRITE           reduce using rule 103 (termF -> DIV np_addOp term .)
    IF              reduce using rule 103 (termF -> DIV np_addOp term .)
    VAR             reduce using rule 103 (termF -> DIV np_addOp term .)
    WHILE           reduce using rule 103 (termF -> DIV np_addOp term .)
    FROM            reduce using rule 103 (termF -> DIV np_addOp term .)
    R_CURPAR        reduce using rule 103 (termF -> DIV np_addOp term .)
    SEMICOLON       reduce using rule 103 (termF -> DIV np_addOp term .)
    COMMA           reduce using rule 103 (termF -> DIV np_addOp term .)
    R_PAR           reduce using rule 103 (termF -> DIV np_addOp term .)
    R_BREAK         reduce using rule 103 (termF -> DIV np_addOp term .)
    TO              reduce using rule 103 (termF -> DIV np_addOp term .)
    OR              reduce using rule 103 (termF -> DIV np_addOp term .)
    AND             reduce using rule 103 (termF -> DIV np_addOp term .)
    DO              reduce using rule 103 (termF -> DIV np_addOp term .)


state 302

    (105) factor -> L_PAR np_addPar exp R_PAR np_popPar . empty
    (115) empty -> .

    MULT            reduce using rule 115 (empty -> .)
    DIV             reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    LESS            reduce using rule 115 (empty -> .)
    GREATER         reduce using rule 115 (empty -> .)
    LESS_TH         reduce using rule 115 (empty -> .)
    GREAT_TH        reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    R_PAR           reduce using rule 115 (empty -> .)
    R_BREAK         reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 312

state 303

    (48) void -> ID DOT ID L_PAR param R_PAR SEMICOLON . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 313

state 304

    (71) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement . SEMICOLON R_CURPAR ifF

    SEMICOLON       shift and go to state 314


state 305

    (51) arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .

    EQUAL           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MIN_EQ          reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT_EQ         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV_EQ          reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV             reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MINUS           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREATER         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS_TH         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREAT_TH        reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SAME            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIF             reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    ID              reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    RETURN          reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    READ            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WRITE           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    IF              reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    VAR             reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WHILE           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    FROM            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_CURPAR        reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SEMICOLON       reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    COMMA           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_PAR           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_BREAK         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    TO              reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    OR              reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    AND             reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DO              reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    L_PAR           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_INT         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)


state 306

    (81) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 315


state 307

    (84) nonconditionalF -> exp TO exp DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 316
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 308

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 317


state 309

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (115) empty -> .

    MAIN            reduce using rule 115 (empty -> .)
    INT             reduce using rule 115 (empty -> .)
    FLOAT           reduce using rule 115 (empty -> .)
    CHAR            reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)

    empty                          shift and go to state 318

state 310

    (85) bool -> OR exp empty .

    ID              reduce using rule 85 (bool -> OR exp empty .)
    RETURN          reduce using rule 85 (bool -> OR exp empty .)
    READ            reduce using rule 85 (bool -> OR exp empty .)
    WRITE           reduce using rule 85 (bool -> OR exp empty .)
    IF              reduce using rule 85 (bool -> OR exp empty .)
    VAR             reduce using rule 85 (bool -> OR exp empty .)
    WHILE           reduce using rule 85 (bool -> OR exp empty .)
    FROM            reduce using rule 85 (bool -> OR exp empty .)
    R_CURPAR        reduce using rule 85 (bool -> OR exp empty .)
    SEMICOLON       reduce using rule 85 (bool -> OR exp empty .)
    COMMA           reduce using rule 85 (bool -> OR exp empty .)
    R_PAR           reduce using rule 85 (bool -> OR exp empty .)
    R_BREAK         reduce using rule 85 (bool -> OR exp empty .)
    TO              reduce using rule 85 (bool -> OR exp empty .)
    DO              reduce using rule 85 (bool -> OR exp empty .)


state 311

    (86) bool -> AND exp empty .

    ID              reduce using rule 86 (bool -> AND exp empty .)
    RETURN          reduce using rule 86 (bool -> AND exp empty .)
    READ            reduce using rule 86 (bool -> AND exp empty .)
    WRITE           reduce using rule 86 (bool -> AND exp empty .)
    IF              reduce using rule 86 (bool -> AND exp empty .)
    VAR             reduce using rule 86 (bool -> AND exp empty .)
    WHILE           reduce using rule 86 (bool -> AND exp empty .)
    FROM            reduce using rule 86 (bool -> AND exp empty .)
    R_CURPAR        reduce using rule 86 (bool -> AND exp empty .)
    SEMICOLON       reduce using rule 86 (bool -> AND exp empty .)
    COMMA           reduce using rule 86 (bool -> AND exp empty .)
    R_PAR           reduce using rule 86 (bool -> AND exp empty .)
    R_BREAK         reduce using rule 86 (bool -> AND exp empty .)
    TO              reduce using rule 86 (bool -> AND exp empty .)
    DO              reduce using rule 86 (bool -> AND exp empty .)


state 312

    (105) factor -> L_PAR np_addPar exp R_PAR np_popPar empty .

    MULT            reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIV             reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    PLUS            reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    MINUS           reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS            reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREATER         reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS_TH         reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREAT_TH        reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SAME            reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIF             reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    ID              reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    RETURN          reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    READ            reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    WRITE           reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    IF              reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    VAR             reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    WHILE           reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    FROM            reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_CURPAR        reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SEMICOLON       reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    COMMA           reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_PAR           reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_BREAK         reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    TO              reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    OR              reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    AND             reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DO              reduce using rule 105 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)


state 313

    (48) void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)


state 314

    (71) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON . R_CURPAR ifF

    R_CURPAR        shift and go to state 319


state 315

    (81) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 320


state 316

    (84) nonconditionalF -> exp TO exp DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 321


state 317

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (115) empty -> .

    MAIN            reduce using rule 115 (empty -> .)
    INT             reduce using rule 115 (empty -> .)
    FLOAT           reduce using rule 115 (empty -> .)
    CHAR            reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)

    empty                          shift and go to state 322

state 318

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 319

    (71) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR . ifF
    (72) ifF -> . ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
    (73) ifF -> . empty
    (115) empty -> .

    ELSE            shift and go to state 324
    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    ifF                            shift and go to state 323
    empty                          shift and go to state 325

state 320

    (81) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 326

state 321

    (84) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 327


state 322

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 323

    (71) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .

    ID              reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    RETURN          reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    READ            reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WRITE           reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    IF              reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    VAR             reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WHILE           reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    FROM            reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    R_CURPAR        reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    SEMICOLON       reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)


state 324

    (72) ifF -> ELSE . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 328


state 325

    (73) ifF -> empty .

    ID              reduce using rule 73 (ifF -> empty .)
    RETURN          reduce using rule 73 (ifF -> empty .)
    READ            reduce using rule 73 (ifF -> empty .)
    WRITE           reduce using rule 73 (ifF -> empty .)
    IF              reduce using rule 73 (ifF -> empty .)
    VAR             reduce using rule 73 (ifF -> empty .)
    WHILE           reduce using rule 73 (ifF -> empty .)
    FROM            reduce using rule 73 (ifF -> empty .)
    R_CURPAR        reduce using rule 73 (ifF -> empty .)
    SEMICOLON       reduce using rule 73 (ifF -> empty .)


state 326

    (81) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 327

    (84) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 329

state 328

    (72) ifF -> ELSE L_CURPAR . statement SEMICOLON R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 330
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 329

    (84) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 330

    (72) ifF -> ELSE L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 331


state 331

    (72) ifF -> ELSE L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 332


state 332

    (72) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR . empty
    (115) empty -> .

    ID              reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    READ            reduce using rule 115 (empty -> .)
    WRITE           reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    VAR             reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FROM            reduce using rule 115 (empty -> .)
    R_CURPAR        reduce using rule 115 (empty -> .)
    SEMICOLON       reduce using rule 115 (empty -> .)

    empty                          shift and go to state 333

state 333

    (72) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 165 resolved as shift
WARNING: shift/reduce conflict for R_PAR in state 165 resolved as shift
