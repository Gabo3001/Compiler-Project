Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID np_addFunc SEMICOLON programT
Rule 2     programT -> class programT
Rule 3     programT -> vars programF
Rule 4     programT -> programF
Rule 5     programF -> func programF
Rule 6     programF -> main empty
Rule 7     class -> CLASS ID classT
Rule 8     classT -> LESS INHERIT ID GREATER classF
Rule 9     classT -> classF
Rule 10    classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty
Rule 11    vars -> VARS dec empty
Rule 12    dec -> VAR arr np_getDecArr decF
Rule 13    dec -> VAR np_getDec decF
Rule 14    decF -> COMMA dec
Rule 15    decF -> COLON type np_getVarType SEMICOLON np_getDec dec
Rule 16    decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty
Rule 17    type -> INT empty
Rule 18    type -> FLOAT empty
Rule 19    type -> CHAR empty
Rule 20    type -> BOOL empty
Rule 21    type -> ID empty
Rule 22    arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
Rule 23    arr -> L_BREAK CTE_INT R_BREAK empty
Rule 24    func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF
Rule 25    funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 26    funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 27    typeFunc -> INT empty
Rule 28    typeFunc -> FLOAT empty
Rule 29    typeFunc -> CHAR empty
Rule 30    typeFunc -> BOOL empty
Rule 31    typeFunc -> ID empty
Rule 32    typeFunc -> VOID empty
Rule 33    parameter -> VAR COLON typepar SEMICOLON parameterF
Rule 34    parameterF -> parameter
Rule 35    parameterF -> empty
Rule 36    typepar -> INT empty
Rule 37    typepar -> FLOAT empty
Rule 38    typepar -> CHAR empty
Rule 39    typepar -> BOOL empty
Rule 40    typepar -> ID empty
Rule 41    main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
Rule 42    statement -> assigment SEMICOLON statementF
Rule 43    statement -> void SEMICOLON statementF
Rule 44    statement -> return SEMICOLON statementF
Rule 45    statement -> read SEMICOLON statementF
Rule 46    statement -> write SEMICOLON statementF
Rule 47    statement -> if statementF
Rule 48    statement -> repeat statementF
Rule 49    statementF -> statement
Rule 50    statementF -> empty
Rule 51    void -> ID DOT ID L_PAR param R_PAR empty
Rule 52    void -> ID L_PAR param R_PAR empty
Rule 53    void -> ID L_PAR R_PAR empty
Rule 54    arrfunc -> L_BREAK exp COMMA exp R_BREAK empty
Rule 55    arrfunc -> L_BREAK exp R_BREAK empty
Rule 56    param -> exp paramF
Rule 57    paramF -> COMMA param
Rule 58    paramF -> empty
Rule 59    return -> RETURN L_PAR exp np_addReturn R_PAR empty
Rule 60    var -> VAR varF
Rule 61    var -> ID DOT VAR varF
Rule 62    varF -> arrfunc empty
Rule 63    varF -> empty
Rule 64    read -> READ L_PAR readF
Rule 65    readF -> var np_addRead COMMA readF
Rule 66    readF -> var np_addRead R_PAR empty
Rule 67    write -> WRITE L_PAR writeT
Rule 68    writeT -> CTE_STRING np_addConstString writeF
Rule 69    writeT -> exp writeF
Rule 70    writeF -> COMMA np_addWrite writeT
Rule 71    writeF -> R_PAR np_addWrite empty
Rule 72    repeat -> conditional empty
Rule 73    repeat -> nonconditional empty
Rule 74    if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
Rule 75    ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty
Rule 76    ifF -> np_endIf empty
Rule 77    assigment -> var np_addId assigmentF
Rule 78    assigmentF -> EQUAL np_addOp exp np_doAssign empty
Rule 79    assigmentF -> ope np_addOp exp np_doAssign empty
Rule 80    ope -> PLUS_EQ empty
Rule 81    ope -> MIN_EQ empty
Rule 82    ope -> MULT_EQ empty
Rule 83    ope -> DIV_EQ empty
Rule 84    conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
Rule 85    nonconditional -> FROM VAR arrfunc nonconditionalF
Rule 86    nonconditional -> FROM VAR nonconditionalF
Rule 87    nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty
Rule 88    bool -> logical np_addBool boolF
Rule 89    boolF -> OR np_addOp bool
Rule 90    boolF -> AND np_addOp bool
Rule 91    boolF -> empty
Rule 92    logical -> ex np_addLogical logicalF
Rule 93    logicalF -> LESS np_addOp logical
Rule 94    logicalF -> GREATER np_addOp logical
Rule 95    logicalF -> LESS_TH np_addOp logical
Rule 96    logicalF -> GREAT_TH np_addOp logical
Rule 97    logicalF -> SAME np_addOp logical
Rule 98    logicalF -> DIF np_addOp logical
Rule 99    logicalF -> empty
Rule 100   exp -> bool empty
Rule 101   ex -> term np_addEx exF
Rule 102   exF -> PLUS np_addOp ex
Rule 103   exF -> MINUS np_addOp ex
Rule 104   exF -> empty
Rule 105   term -> factor np_addTerm termF
Rule 106   termF -> MULT np_addOp term
Rule 107   termF -> DIV np_addOp term
Rule 108   termF -> empty
Rule 109   factor -> L_PAR np_addPar exp R_PAR np_popPar empty
Rule 110   factor -> factorT
Rule 111   factorT -> PLUS factorF
Rule 112   factorT -> MINUS factorF
Rule 113   factorT -> factorF
Rule 114   factorF -> varcte empty
Rule 115   varcte -> var np_addId empty
Rule 116   varcte -> CTE_INT np_addConstInt empty
Rule 117   varcte -> CTE_FLOAT np_addConstFloat empty
Rule 118   varcte -> CTE_CHAR np_addConstChar empty
Rule 119   varcte -> CTE_BOOL np_addConstBool empty
Rule 120   empty -> <empty>
Rule 121   np_getMainFunc -> <empty>
Rule 122   np_addFunc -> <empty>
Rule 123   np_getDec -> <empty>
Rule 124   np_getDecArr -> <empty>
Rule 125   np_getVarType -> <empty>
Rule 126   np_addToDic -> <empty>
Rule 127   np_addId -> <empty>
Rule 128   np_addConstInt -> <empty>
Rule 129   np_addConstFloat -> <empty>
Rule 130   np_addConstChar -> <empty>
Rule 131   np_addConstBool -> <empty>
Rule 132   np_addConstString -> <empty>
Rule 133   np_addOp -> <empty>
Rule 134   np_addPar -> <empty>
Rule 135   np_popPar -> <empty>
Rule 136   np_addTerm -> <empty>
Rule 137   np_addEx -> <empty>
Rule 138   np_addLogical -> <empty>
Rule 139   np_addBool -> <empty>
Rule 140   np_doAssign -> <empty>
Rule 141   np_addRead -> <empty>
Rule 142   np_addWrite -> <empty>
Rule 143   np_addReturn -> <empty>
Rule 144   np_checkBool -> <empty>
Rule 145   np_endIf -> <empty>
Rule 146   np_else -> <empty>
Rule 147   np_addWhile -> <empty>
Rule 148   np_endWhile -> <empty>

Terminals, with rules where they appear

AND                  : 90
ATTRIBUTES           : 10
BOOL                 : 20 30 39
CHAR                 : 19 29 38
CLASS                : 7
COLON                : 15 16 33
COMMA                : 14 22 54 57 65 70
CTE_BOOL             : 119
CTE_CHAR             : 118
CTE_FLOAT            : 117
CTE_INT              : 22 22 23 116
CTE_STRING           : 68
DIF                  : 98
DIV                  : 107
DIV_EQ               : 83
DO                   : 84 87
DOT                  : 51 61
ELSE                 : 75
EQUAL                : 78
FLOAT                : 18 28 37
FROM                 : 85 86
FUNCTION             : 24
GREATER              : 8 94
GREAT_TH             : 96
ID                   : 1 7 8 21 24 31 40 51 51 52 53 61
IF                   : 74
INHERIT              : 8
INT                  : 17 27 36
LESS                 : 8 93
LESS_TH              : 95
L_BREAK              : 22 23 54 55
L_CURPAR             : 10 25 26 41 74 75 84 87
L_PAR                : 24 41 51 52 53 59 64 67 74 84 109
MAIN                 : 41
METHODS              : 10
MINUS                : 103 112
MIN_EQ               : 81
MULT                 : 106
MULT_EQ              : 82
OR                   : 89
PLUS                 : 102 111
PLUS_EQ              : 80
PROGRAM              : 1
READ                 : 64
RETURN               : 59
R_BREAK              : 22 23 54 55
R_CURPAR             : 10 25 26 41 74 75 84 87
R_PAR                : 25 26 41 51 52 53 59 66 71 74 84 109
SAME                 : 97
SEMICOLON            : 1 10 10 15 16 25 26 33 42 43 44 45 46
THEN                 : 74
TO                   : 87
VAR                  : 12 13 33 60 61 85 86
VARS                 : 11
VOID                 : 32
WHILE                : 84
WRITE                : 67
error                : 

Nonterminals, with rules where they appear

arr                  : 12
arrfunc              : 62 85
assigment            : 42
assigmentF           : 77
bool                 : 89 90 100
boolF                : 88
class                : 2
classF               : 8 9
classT               : 7
conditional          : 72
dec                  : 10 11 14 15 25 26
decF                 : 12 13
empty                : 6 10 11 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 35 36 37 38 39 40 41 50 51 52 53 54 55 58 59 62 63 66 71 72 73 75 76 78 79 80 81 82 83 84 87 91 99 100 104 108 109 114 115 116 117 118 119
ex                   : 92 102 103
exF                  : 101
exp                  : 54 54 55 56 59 69 74 78 79 84 87 87 109
factor               : 105
factorF              : 111 112 113
factorT              : 110
func                 : 5 10
funcF                : 24
if                   : 47
ifF                  : 74
logical              : 88 93 94 95 96 97 98
logicalF             : 92
main                 : 6
nonconditional       : 73
nonconditionalF      : 85 86
np_addBool           : 88
np_addConstBool      : 119
np_addConstChar      : 118
np_addConstFloat     : 117
np_addConstInt       : 116
np_addConstString    : 68
np_addEx             : 101
np_addFunc           : 1 24
np_addId             : 77 115
np_addLogical        : 92
np_addOp             : 78 79 89 90 93 94 95 96 97 98 102 103 106 107
np_addPar            : 109
np_addRead           : 65 66
np_addReturn         : 59
np_addTerm           : 105
np_addToDic          : 16
np_addWhile          : 84
np_addWrite          : 70 71
np_checkBool         : 74 84
np_doAssign          : 78 79
np_else              : 75
np_endIf             : 75 76
np_endWhile          : 84
np_getDec            : 13 15 16
np_getDecArr         : 12
np_getMainFunc       : 41
np_getVarType        : 15 16
np_popPar            : 109
ope                  : 79
param                : 51 52 57
paramF               : 56
parameter            : 25 34
parameterF           : 33
program              : 0
programF             : 3 4 5
programT             : 1 2
read                 : 45
readF                : 64 65
repeat               : 48
return               : 44
statement            : 25 26 41 49 74 75 84 87
statementF           : 42 43 44 45 46 47 48
term                 : 101 106 107
termF                : 105
type                 : 15 16
typeFunc             : 24
typepar              : 33
var                  : 65 66 77 115
varF                 : 60 61
varcte               : 114
vars                 : 3
void                 : 43
write                : 46
writeF               : 68 69
writeT               : 67 70

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID np_addFunc SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID np_addFunc SEMICOLON programT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . np_addFunc SEMICOLON programT
    (122) np_addFunc -> .

    SEMICOLON       reduce using rule 122 (np_addFunc -> .)

    np_addFunc                     shift and go to state 4

state 4

    (1) program -> PROGRAM ID np_addFunc . SEMICOLON programT

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID np_addFunc SEMICOLON . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 11
    VARS            shift and go to state 12
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    programT                       shift and go to state 7
    class                          shift and go to state 8
    vars                           shift and go to state 9
    programF                       shift and go to state 10
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 6

    (31) typeFunc -> ID . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 22

state 7

    (1) program -> PROGRAM ID np_addFunc SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM ID np_addFunc SEMICOLON programT .)


state 8

    (2) programT -> class . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 11
    VARS            shift and go to state 12
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    class                          shift and go to state 8
    programT                       shift and go to state 23
    vars                           shift and go to state 9
    programF                       shift and go to state 10
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 9

    (3) programT -> vars . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    programF                       shift and go to state 24
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 10

    (4) programT -> programF .

    $end            reduce using rule 4 (programT -> programF .)


state 11

    (7) class -> CLASS . ID classT

    ID              shift and go to state 25


state 12

    (11) vars -> VARS . dec empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 26

state 13

    (5) programF -> func . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (41) main -> . MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    func                           shift and go to state 13
    programF                       shift and go to state 28
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 14

    (6) programF -> main . empty
    (120) empty -> .

    $end            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 29

state 15

    (24) func -> typeFunc . FUNCTION ID np_addFunc L_PAR funcF

    FUNCTION        shift and go to state 30


state 16

    (41) main -> MAIN . np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (121) np_getMainFunc -> .

    L_PAR           reduce using rule 121 (np_getMainFunc -> .)

    np_getMainFunc                 shift and go to state 31

state 17

    (27) typeFunc -> INT . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 32

state 18

    (28) typeFunc -> FLOAT . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 33

state 19

    (29) typeFunc -> CHAR . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 34

state 20

    (30) typeFunc -> BOOL . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 35

state 21

    (32) typeFunc -> VOID . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 36

state 22

    (31) typeFunc -> ID empty .

    FUNCTION        reduce using rule 31 (typeFunc -> ID empty .)


state 23

    (2) programT -> class programT .

    $end            reduce using rule 2 (programT -> class programT .)


state 24

    (3) programT -> vars programF .

    $end            reduce using rule 3 (programT -> vars programF .)


state 25

    (7) class -> CLASS ID . classT
    (8) classT -> . LESS INHERIT ID GREATER classF
    (9) classT -> . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    LESS            shift and go to state 38
    SEMICOLON       shift and go to state 40

    classT                         shift and go to state 37
    classF                         shift and go to state 39

state 26

    (11) vars -> VARS dec . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 41

state 27

    (12) dec -> VAR . arr np_getDecArr decF
    (13) dec -> VAR . np_getDec decF
    (22) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> . L_BREAK CTE_INT R_BREAK empty
    (123) np_getDec -> .

    L_BREAK         shift and go to state 44
    COMMA           reduce using rule 123 (np_getDec -> .)
    COLON           reduce using rule 123 (np_getDec -> .)

    arr                            shift and go to state 42
    np_getDec                      shift and go to state 43

state 28

    (5) programF -> func programF .

    $end            reduce using rule 5 (programF -> func programF .)


state 29

    (6) programF -> main empty .

    $end            reduce using rule 6 (programF -> main empty .)


state 30

    (24) func -> typeFunc FUNCTION . ID np_addFunc L_PAR funcF

    ID              shift and go to state 45


state 31

    (41) main -> MAIN np_getMainFunc . L_PAR R_PAR L_CURPAR statement R_CURPAR empty

    L_PAR           shift and go to state 46


state 32

    (27) typeFunc -> INT empty .

    FUNCTION        reduce using rule 27 (typeFunc -> INT empty .)


state 33

    (28) typeFunc -> FLOAT empty .

    FUNCTION        reduce using rule 28 (typeFunc -> FLOAT empty .)


state 34

    (29) typeFunc -> CHAR empty .

    FUNCTION        reduce using rule 29 (typeFunc -> CHAR empty .)


state 35

    (30) typeFunc -> BOOL empty .

    FUNCTION        reduce using rule 30 (typeFunc -> BOOL empty .)


state 36

    (32) typeFunc -> VOID empty .

    FUNCTION        reduce using rule 32 (typeFunc -> VOID empty .)


state 37

    (7) class -> CLASS ID classT .

    CLASS           reduce using rule 7 (class -> CLASS ID classT .)
    VARS            reduce using rule 7 (class -> CLASS ID classT .)
    MAIN            reduce using rule 7 (class -> CLASS ID classT .)
    INT             reduce using rule 7 (class -> CLASS ID classT .)
    FLOAT           reduce using rule 7 (class -> CLASS ID classT .)
    CHAR            reduce using rule 7 (class -> CLASS ID classT .)
    BOOL            reduce using rule 7 (class -> CLASS ID classT .)
    ID              reduce using rule 7 (class -> CLASS ID classT .)
    VOID            reduce using rule 7 (class -> CLASS ID classT .)


state 38

    (8) classT -> LESS . INHERIT ID GREATER classF

    INHERIT         shift and go to state 47


state 39

    (9) classT -> classF .

    CLASS           reduce using rule 9 (classT -> classF .)
    VARS            reduce using rule 9 (classT -> classF .)
    MAIN            reduce using rule 9 (classT -> classF .)
    INT             reduce using rule 9 (classT -> classF .)
    FLOAT           reduce using rule 9 (classT -> classF .)
    CHAR            reduce using rule 9 (classT -> classF .)
    BOOL            reduce using rule 9 (classT -> classF .)
    ID              reduce using rule 9 (classT -> classF .)
    VOID            reduce using rule 9 (classT -> classF .)


state 40

    (10) classF -> SEMICOLON . L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    L_CURPAR        shift and go to state 48


state 41

    (11) vars -> VARS dec empty .

    MAIN            reduce using rule 11 (vars -> VARS dec empty .)
    INT             reduce using rule 11 (vars -> VARS dec empty .)
    FLOAT           reduce using rule 11 (vars -> VARS dec empty .)
    CHAR            reduce using rule 11 (vars -> VARS dec empty .)
    BOOL            reduce using rule 11 (vars -> VARS dec empty .)
    ID              reduce using rule 11 (vars -> VARS dec empty .)
    VOID            reduce using rule 11 (vars -> VARS dec empty .)


state 42

    (12) dec -> VAR arr . np_getDecArr decF
    (124) np_getDecArr -> .

    COMMA           reduce using rule 124 (np_getDecArr -> .)
    COLON           reduce using rule 124 (np_getDecArr -> .)

    np_getDecArr                   shift and go to state 49

state 43

    (13) dec -> VAR np_getDec . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 51
    COLON           shift and go to state 52

    decF                           shift and go to state 50

state 44

    (22) arr -> L_BREAK . CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 53


state 45

    (24) func -> typeFunc FUNCTION ID . np_addFunc L_PAR funcF
    (122) np_addFunc -> .

    L_PAR           reduce using rule 122 (np_addFunc -> .)

    np_addFunc                     shift and go to state 54

state 46

    (41) main -> MAIN np_getMainFunc L_PAR . R_PAR L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 55


state 47

    (8) classT -> LESS INHERIT . ID GREATER classF

    ID              shift and go to state 56


state 48

    (10) classF -> SEMICOLON L_CURPAR . ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    ATTRIBUTES      shift and go to state 57


state 49

    (12) dec -> VAR arr np_getDecArr . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 51
    COLON           shift and go to state 52

    decF                           shift and go to state 58

state 50

    (13) dec -> VAR np_getDec decF .

    MAIN            reduce using rule 13 (dec -> VAR np_getDec decF .)
    INT             reduce using rule 13 (dec -> VAR np_getDec decF .)
    FLOAT           reduce using rule 13 (dec -> VAR np_getDec decF .)
    CHAR            reduce using rule 13 (dec -> VAR np_getDec decF .)
    BOOL            reduce using rule 13 (dec -> VAR np_getDec decF .)
    ID              reduce using rule 13 (dec -> VAR np_getDec decF .)
    VOID            reduce using rule 13 (dec -> VAR np_getDec decF .)
    METHODS         reduce using rule 13 (dec -> VAR np_getDec decF .)
    L_CURPAR        reduce using rule 13 (dec -> VAR np_getDec decF .)


state 51

    (14) decF -> COMMA . dec
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 59

state 52

    (15) decF -> COLON . type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON . type np_getVarType SEMICOLON np_getDec np_addToDic empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . BOOL empty
    (21) type -> . ID empty

    INT             shift and go to state 61
    FLOAT           shift and go to state 62
    CHAR            shift and go to state 63
    BOOL            shift and go to state 64
    ID              shift and go to state 65

    type                           shift and go to state 60

state 53

    (22) arr -> L_BREAK CTE_INT . COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK CTE_INT . R_BREAK empty

    COMMA           shift and go to state 66
    R_BREAK         shift and go to state 67


state 54

    (24) func -> typeFunc FUNCTION ID np_addFunc . L_PAR funcF

    L_PAR           shift and go to state 68


state 55

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 69


state 56

    (8) classT -> LESS INHERIT ID . GREATER classF

    GREATER         shift and go to state 70


state 57

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES . dec METHODS func R_CURPAR SEMICOLON empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 71

state 58

    (12) dec -> VAR arr np_getDecArr decF .

    MAIN            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    INT             reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    FLOAT           reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    CHAR            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    BOOL            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    ID              reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    VOID            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    METHODS         reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    L_CURPAR        reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)


state 59

    (14) decF -> COMMA dec .

    MAIN            reduce using rule 14 (decF -> COMMA dec .)
    INT             reduce using rule 14 (decF -> COMMA dec .)
    FLOAT           reduce using rule 14 (decF -> COMMA dec .)
    CHAR            reduce using rule 14 (decF -> COMMA dec .)
    BOOL            reduce using rule 14 (decF -> COMMA dec .)
    ID              reduce using rule 14 (decF -> COMMA dec .)
    VOID            reduce using rule 14 (decF -> COMMA dec .)
    METHODS         reduce using rule 14 (decF -> COMMA dec .)
    L_CURPAR        reduce using rule 14 (decF -> COMMA dec .)


state 60

    (15) decF -> COLON type . np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON type . np_getVarType SEMICOLON np_getDec np_addToDic empty
    (125) np_getVarType -> .

    SEMICOLON       reduce using rule 125 (np_getVarType -> .)

    np_getVarType                  shift and go to state 72

state 61

    (17) type -> INT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 73

state 62

    (18) type -> FLOAT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 74

state 63

    (19) type -> CHAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 75

state 64

    (20) type -> BOOL . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 76

state 65

    (21) type -> ID . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 77

state 66

    (22) arr -> L_BREAK CTE_INT COMMA . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 78


state 67

    (23) arr -> L_BREAK CTE_INT R_BREAK . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    COLON           reduce using rule 120 (empty -> .)

    empty                          shift and go to state 79

state 68

    (24) func -> typeFunc FUNCTION ID np_addFunc L_PAR . funcF
    (25) funcF -> . parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (26) funcF -> . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (33) parameter -> . VAR COLON typepar SEMICOLON parameterF

    R_PAR           shift and go to state 82
    VAR             shift and go to state 83

    funcF                          shift and go to state 80
    parameter                      shift and go to state 81

state 69

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 84
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 70

    (8) classT -> LESS INHERIT ID GREATER . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    SEMICOLON       shift and go to state 40

    classF                         shift and go to state 103

state 71

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec . METHODS func R_CURPAR SEMICOLON empty

    METHODS         shift and go to state 104


state 72

    (15) decF -> COLON type np_getVarType . SEMICOLON np_getDec dec
    (16) decF -> COLON type np_getVarType . SEMICOLON np_getDec np_addToDic empty

    SEMICOLON       shift and go to state 105


state 73

    (17) type -> INT empty .

    SEMICOLON       reduce using rule 17 (type -> INT empty .)


state 74

    (18) type -> FLOAT empty .

    SEMICOLON       reduce using rule 18 (type -> FLOAT empty .)


state 75

    (19) type -> CHAR empty .

    SEMICOLON       reduce using rule 19 (type -> CHAR empty .)


state 76

    (20) type -> BOOL empty .

    SEMICOLON       reduce using rule 20 (type -> BOOL empty .)


state 77

    (21) type -> ID empty .

    SEMICOLON       reduce using rule 21 (type -> ID empty .)


state 78

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT . R_BREAK empty

    R_BREAK         shift and go to state 106


state 79

    (23) arr -> L_BREAK CTE_INT R_BREAK empty .

    COMMA           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    COLON           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)


state 80

    (24) func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .

    MAIN            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    INT             reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    FLOAT           reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    CHAR            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    BOOL            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    ID              reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    VOID            reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)
    R_CURPAR        reduce using rule 24 (func -> typeFunc FUNCTION ID np_addFunc L_PAR funcF .)


state 81

    (25) funcF -> parameter . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 107


state 82

    (26) funcF -> R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 108


state 83

    (33) parameter -> VAR . COLON typepar SEMICOLON parameterF

    COLON           shift and go to state 109


state 84

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 110


state 85

    (42) statement -> assigment . SEMICOLON statementF

    SEMICOLON       shift and go to state 111


state 86

    (43) statement -> void . SEMICOLON statementF

    SEMICOLON       shift and go to state 112


state 87

    (44) statement -> return . SEMICOLON statementF

    SEMICOLON       shift and go to state 113


state 88

    (45) statement -> read . SEMICOLON statementF

    SEMICOLON       shift and go to state 114


state 89

    (46) statement -> write . SEMICOLON statementF

    SEMICOLON       shift and go to state 115


state 90

    (47) statement -> if . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    if                             shift and go to state 90
    statementF                     shift and go to state 116
    statement                      shift and go to state 117
    empty                          shift and go to state 118
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 91

    (48) statement -> repeat . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    repeat                         shift and go to state 91
    statementF                     shift and go to state 119
    statement                      shift and go to state 117
    empty                          shift and go to state 118
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 92

    (77) assigment -> var . np_addId assigmentF
    (127) np_addId -> .

    EQUAL           reduce using rule 127 (np_addId -> .)
    PLUS_EQ         reduce using rule 127 (np_addId -> .)
    MIN_EQ          reduce using rule 127 (np_addId -> .)
    MULT_EQ         reduce using rule 127 (np_addId -> .)
    DIV_EQ          reduce using rule 127 (np_addId -> .)

    np_addId                       shift and go to state 120

state 93

    (51) void -> ID . DOT ID L_PAR param R_PAR empty
    (52) void -> ID . L_PAR param R_PAR empty
    (53) void -> ID . L_PAR R_PAR empty
    (61) var -> ID . DOT VAR varF

    DOT             shift and go to state 121
    L_PAR           shift and go to state 122


state 94

    (59) return -> RETURN . L_PAR exp np_addReturn R_PAR empty

    L_PAR           shift and go to state 123


state 95

    (64) read -> READ . L_PAR readF

    L_PAR           shift and go to state 124


state 96

    (67) write -> WRITE . L_PAR writeT

    L_PAR           shift and go to state 125


state 97

    (74) if -> IF . L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF

    L_PAR           shift and go to state 126


state 98

    (72) repeat -> conditional . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 127

state 99

    (73) repeat -> nonconditional . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 128

state 100

    (60) var -> VAR . varF
    (62) varF -> . arrfunc empty
    (63) varF -> . empty
    (54) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (55) arrfunc -> . L_BREAK exp R_BREAK empty
    (120) empty -> .

    L_BREAK         shift and go to state 132
    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    varF                           shift and go to state 129
    arrfunc                        shift and go to state 130
    empty                          shift and go to state 131

state 101

    (84) conditional -> WHILE . np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (147) np_addWhile -> .

    L_PAR           reduce using rule 147 (np_addWhile -> .)

    np_addWhile                    shift and go to state 133

state 102

    (85) nonconditional -> FROM . VAR arrfunc nonconditionalF
    (86) nonconditional -> FROM . VAR nonconditionalF

    VAR             shift and go to state 134


state 103

    (8) classT -> LESS INHERIT ID GREATER classF .

    CLASS           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VARS            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    MAIN            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    INT             reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    FLOAT           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    CHAR            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    BOOL            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    ID              reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VOID            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)


state 104

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS . func R_CURPAR SEMICOLON empty
    (24) func -> . typeFunc FUNCTION ID np_addFunc L_PAR funcF
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    func                           shift and go to state 135
    typeFunc                       shift and go to state 15

state 105

    (15) decF -> COLON type np_getVarType SEMICOLON . np_getDec dec
    (16) decF -> COLON type np_getVarType SEMICOLON . np_getDec np_addToDic empty
    (123) np_getDec -> .

    VAR             reduce using rule 123 (np_getDec -> .)
    MAIN            reduce using rule 123 (np_getDec -> .)
    INT             reduce using rule 123 (np_getDec -> .)
    FLOAT           reduce using rule 123 (np_getDec -> .)
    CHAR            reduce using rule 123 (np_getDec -> .)
    BOOL            reduce using rule 123 (np_getDec -> .)
    ID              reduce using rule 123 (np_getDec -> .)
    VOID            reduce using rule 123 (np_getDec -> .)
    METHODS         reduce using rule 123 (np_getDec -> .)
    L_CURPAR        reduce using rule 123 (np_getDec -> .)

    np_getDec                      shift and go to state 136

state 106

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    COLON           reduce using rule 120 (empty -> .)

    empty                          shift and go to state 137

state 107

    (25) funcF -> parameter R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 138


state 108

    (26) funcF -> R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 139

state 109

    (33) parameter -> VAR COLON . typepar SEMICOLON parameterF
    (36) typepar -> . INT empty
    (37) typepar -> . FLOAT empty
    (38) typepar -> . CHAR empty
    (39) typepar -> . BOOL empty
    (40) typepar -> . ID empty

    INT             shift and go to state 141
    FLOAT           shift and go to state 142
    CHAR            shift and go to state 143
    BOOL            shift and go to state 144
    ID              shift and go to state 145

    typepar                        shift and go to state 140

state 110

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    $end            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 146

state 111

    (42) statement -> assigment SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    assigment                      shift and go to state 85
    statementF                     shift and go to state 147
    statement                      shift and go to state 117
    empty                          shift and go to state 118
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 112

    (43) statement -> void SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    void                           shift and go to state 86
    statementF                     shift and go to state 148
    statement                      shift and go to state 117
    empty                          shift and go to state 118
    assigment                      shift and go to state 85
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 113

    (44) statement -> return SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    return                         shift and go to state 87
    statementF                     shift and go to state 149
    statement                      shift and go to state 117
    empty                          shift and go to state 118
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 114

    (45) statement -> read SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    read                           shift and go to state 88
    statementF                     shift and go to state 150
    statement                      shift and go to state 117
    empty                          shift and go to state 118
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 115

    (46) statement -> write SEMICOLON . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    write                          shift and go to state 89
    statementF                     shift and go to state 151
    statement                      shift and go to state 117
    empty                          shift and go to state 118
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 116

    (47) statement -> if statementF .

    R_CURPAR        reduce using rule 47 (statement -> if statementF .)


state 117

    (49) statementF -> statement .

    R_CURPAR        reduce using rule 49 (statementF -> statement .)


state 118

    (50) statementF -> empty .

    R_CURPAR        reduce using rule 50 (statementF -> empty .)


state 119

    (48) statement -> repeat statementF .

    R_CURPAR        reduce using rule 48 (statement -> repeat statementF .)


state 120

    (77) assigment -> var np_addId . assigmentF
    (78) assigmentF -> . EQUAL np_addOp exp np_doAssign empty
    (79) assigmentF -> . ope np_addOp exp np_doAssign empty
    (80) ope -> . PLUS_EQ empty
    (81) ope -> . MIN_EQ empty
    (82) ope -> . MULT_EQ empty
    (83) ope -> . DIV_EQ empty

    EQUAL           shift and go to state 153
    PLUS_EQ         shift and go to state 155
    MIN_EQ          shift and go to state 156
    MULT_EQ         shift and go to state 157
    DIV_EQ          shift and go to state 158

    assigmentF                     shift and go to state 152
    ope                            shift and go to state 154

state 121

    (51) void -> ID DOT . ID L_PAR param R_PAR empty
    (61) var -> ID DOT . VAR varF

    ID              shift and go to state 159
    VAR             shift and go to state 160


state 122

    (52) void -> ID L_PAR . param R_PAR empty
    (53) void -> ID L_PAR . R_PAR empty
    (56) param -> . exp paramF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 164
    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    param                          shift and go to state 163
    exp                            shift and go to state 165
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 123

    (59) return -> RETURN L_PAR . exp np_addReturn R_PAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    exp                            shift and go to state 181
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 124

    (64) read -> READ L_PAR . readF
    (65) readF -> . var np_addRead COMMA readF
    (66) readF -> . var np_addRead R_PAR empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 100
    ID              shift and go to state 161

    readF                          shift and go to state 182
    var                            shift and go to state 183

state 125

    (67) write -> WRITE L_PAR . writeT
    (68) writeT -> . CTE_STRING np_addConstString writeF
    (69) writeT -> . exp writeF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 185
    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    writeT                         shift and go to state 184
    exp                            shift and go to state 186
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 126

    (74) if -> IF L_PAR . exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    exp                            shift and go to state 187
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 127

    (72) repeat -> conditional empty .

    ID              reduce using rule 72 (repeat -> conditional empty .)
    RETURN          reduce using rule 72 (repeat -> conditional empty .)
    READ            reduce using rule 72 (repeat -> conditional empty .)
    WRITE           reduce using rule 72 (repeat -> conditional empty .)
    IF              reduce using rule 72 (repeat -> conditional empty .)
    VAR             reduce using rule 72 (repeat -> conditional empty .)
    WHILE           reduce using rule 72 (repeat -> conditional empty .)
    FROM            reduce using rule 72 (repeat -> conditional empty .)
    R_CURPAR        reduce using rule 72 (repeat -> conditional empty .)


state 128

    (73) repeat -> nonconditional empty .

    ID              reduce using rule 73 (repeat -> nonconditional empty .)
    RETURN          reduce using rule 73 (repeat -> nonconditional empty .)
    READ            reduce using rule 73 (repeat -> nonconditional empty .)
    WRITE           reduce using rule 73 (repeat -> nonconditional empty .)
    IF              reduce using rule 73 (repeat -> nonconditional empty .)
    VAR             reduce using rule 73 (repeat -> nonconditional empty .)
    WHILE           reduce using rule 73 (repeat -> nonconditional empty .)
    FROM            reduce using rule 73 (repeat -> nonconditional empty .)
    R_CURPAR        reduce using rule 73 (repeat -> nonconditional empty .)


state 129

    (60) var -> VAR varF .

    EQUAL           reduce using rule 60 (var -> VAR varF .)
    PLUS_EQ         reduce using rule 60 (var -> VAR varF .)
    MIN_EQ          reduce using rule 60 (var -> VAR varF .)
    MULT_EQ         reduce using rule 60 (var -> VAR varF .)
    DIV_EQ          reduce using rule 60 (var -> VAR varF .)
    MULT            reduce using rule 60 (var -> VAR varF .)
    DIV             reduce using rule 60 (var -> VAR varF .)
    PLUS            reduce using rule 60 (var -> VAR varF .)
    MINUS           reduce using rule 60 (var -> VAR varF .)
    LESS            reduce using rule 60 (var -> VAR varF .)
    GREATER         reduce using rule 60 (var -> VAR varF .)
    LESS_TH         reduce using rule 60 (var -> VAR varF .)
    GREAT_TH        reduce using rule 60 (var -> VAR varF .)
    SAME            reduce using rule 60 (var -> VAR varF .)
    DIF             reduce using rule 60 (var -> VAR varF .)
    OR              reduce using rule 60 (var -> VAR varF .)
    AND             reduce using rule 60 (var -> VAR varF .)
    COMMA           reduce using rule 60 (var -> VAR varF .)
    R_PAR           reduce using rule 60 (var -> VAR varF .)
    R_BREAK         reduce using rule 60 (var -> VAR varF .)
    TO              reduce using rule 60 (var -> VAR varF .)
    SEMICOLON       reduce using rule 60 (var -> VAR varF .)
    DO              reduce using rule 60 (var -> VAR varF .)


state 130

    (62) varF -> arrfunc . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 188

state 131

    (63) varF -> empty .

    EQUAL           reduce using rule 63 (varF -> empty .)
    PLUS_EQ         reduce using rule 63 (varF -> empty .)
    MIN_EQ          reduce using rule 63 (varF -> empty .)
    MULT_EQ         reduce using rule 63 (varF -> empty .)
    DIV_EQ          reduce using rule 63 (varF -> empty .)
    MULT            reduce using rule 63 (varF -> empty .)
    DIV             reduce using rule 63 (varF -> empty .)
    PLUS            reduce using rule 63 (varF -> empty .)
    MINUS           reduce using rule 63 (varF -> empty .)
    LESS            reduce using rule 63 (varF -> empty .)
    GREATER         reduce using rule 63 (varF -> empty .)
    LESS_TH         reduce using rule 63 (varF -> empty .)
    GREAT_TH        reduce using rule 63 (varF -> empty .)
    SAME            reduce using rule 63 (varF -> empty .)
    DIF             reduce using rule 63 (varF -> empty .)
    OR              reduce using rule 63 (varF -> empty .)
    AND             reduce using rule 63 (varF -> empty .)
    COMMA           reduce using rule 63 (varF -> empty .)
    R_PAR           reduce using rule 63 (varF -> empty .)
    R_BREAK         reduce using rule 63 (varF -> empty .)
    TO              reduce using rule 63 (varF -> empty .)
    SEMICOLON       reduce using rule 63 (varF -> empty .)
    DO              reduce using rule 63 (varF -> empty .)


state 132

    (54) arrfunc -> L_BREAK . exp COMMA exp R_BREAK empty
    (55) arrfunc -> L_BREAK . exp R_BREAK empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    exp                            shift and go to state 189
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 133

    (84) conditional -> WHILE np_addWhile . L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty

    L_PAR           shift and go to state 190


state 134

    (85) nonconditional -> FROM VAR . arrfunc nonconditionalF
    (86) nonconditional -> FROM VAR . nonconditionalF
    (54) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (55) arrfunc -> . L_BREAK exp R_BREAK empty
    (87) nonconditionalF -> . exp TO exp DO L_CURPAR statement R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_BREAK         shift and go to state 132
    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    arrfunc                        shift and go to state 191
    nonconditionalF                shift and go to state 192
    exp                            shift and go to state 193
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 135

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func . R_CURPAR SEMICOLON empty

    R_CURPAR        shift and go to state 194


state 136

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec . dec
    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec . np_addToDic empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF
    (126) np_addToDic -> .

    VAR             shift and go to state 27
    MAIN            reduce using rule 126 (np_addToDic -> .)
    INT             reduce using rule 126 (np_addToDic -> .)
    FLOAT           reduce using rule 126 (np_addToDic -> .)
    CHAR            reduce using rule 126 (np_addToDic -> .)
    BOOL            reduce using rule 126 (np_addToDic -> .)
    ID              reduce using rule 126 (np_addToDic -> .)
    VOID            reduce using rule 126 (np_addToDic -> .)
    METHODS         reduce using rule 126 (np_addToDic -> .)
    L_CURPAR        reduce using rule 126 (np_addToDic -> .)

    dec                            shift and go to state 195
    np_addToDic                    shift and go to state 196

state 137

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .

    COMMA           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    COLON           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)


state 138

    (25) funcF -> parameter R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 197

state 139

    (26) funcF -> R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 198


state 140

    (33) parameter -> VAR COLON typepar . SEMICOLON parameterF

    SEMICOLON       shift and go to state 199


state 141

    (36) typepar -> INT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 200

state 142

    (37) typepar -> FLOAT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 201

state 143

    (38) typepar -> CHAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 202

state 144

    (39) typepar -> BOOL . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 203

state 145

    (40) typepar -> ID . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 204

state 146

    (41) main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty .

    $end            reduce using rule 41 (main -> MAIN np_getMainFunc L_PAR R_PAR L_CURPAR statement R_CURPAR empty .)


state 147

    (42) statement -> assigment SEMICOLON statementF .

    R_CURPAR        reduce using rule 42 (statement -> assigment SEMICOLON statementF .)


state 148

    (43) statement -> void SEMICOLON statementF .

    R_CURPAR        reduce using rule 43 (statement -> void SEMICOLON statementF .)


state 149

    (44) statement -> return SEMICOLON statementF .

    R_CURPAR        reduce using rule 44 (statement -> return SEMICOLON statementF .)


state 150

    (45) statement -> read SEMICOLON statementF .

    R_CURPAR        reduce using rule 45 (statement -> read SEMICOLON statementF .)


state 151

    (46) statement -> write SEMICOLON statementF .

    R_CURPAR        reduce using rule 46 (statement -> write SEMICOLON statementF .)


state 152

    (77) assigment -> var np_addId assigmentF .

    SEMICOLON       reduce using rule 77 (assigment -> var np_addId assigmentF .)


state 153

    (78) assigmentF -> EQUAL . np_addOp exp np_doAssign empty
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 205

state 154

    (79) assigmentF -> ope . np_addOp exp np_doAssign empty
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 206

state 155

    (80) ope -> PLUS_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 207

state 156

    (81) ope -> MIN_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 208

state 157

    (82) ope -> MULT_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 209

state 158

    (83) ope -> DIV_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 210

state 159

    (51) void -> ID DOT ID . L_PAR param R_PAR empty

    L_PAR           shift and go to state 211


state 160

    (61) var -> ID DOT VAR . varF
    (62) varF -> . arrfunc empty
    (63) varF -> . empty
    (54) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (55) arrfunc -> . L_BREAK exp R_BREAK empty
    (120) empty -> .

    L_BREAK         shift and go to state 132
    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    varF                           shift and go to state 212
    arrfunc                        shift and go to state 130
    empty                          shift and go to state 131

state 161

    (61) var -> ID . DOT VAR varF

    DOT             shift and go to state 213


state 162

    (109) factor -> L_PAR . np_addPar exp R_PAR np_popPar empty
    (134) np_addPar -> .

    L_PAR           reduce using rule 134 (np_addPar -> .)
    PLUS            reduce using rule 134 (np_addPar -> .)
    MINUS           reduce using rule 134 (np_addPar -> .)
    CTE_INT         reduce using rule 134 (np_addPar -> .)
    CTE_FLOAT       reduce using rule 134 (np_addPar -> .)
    CTE_CHAR        reduce using rule 134 (np_addPar -> .)
    CTE_BOOL        reduce using rule 134 (np_addPar -> .)
    VAR             reduce using rule 134 (np_addPar -> .)
    ID              reduce using rule 134 (np_addPar -> .)

    np_addPar                      shift and go to state 214

state 163

    (52) void -> ID L_PAR param . R_PAR empty

    R_PAR           shift and go to state 215


state 164

    (53) void -> ID L_PAR R_PAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 216

state 165

    (56) param -> exp . paramF
    (57) paramF -> . COMMA param
    (58) paramF -> . empty
    (120) empty -> .

    COMMA           shift and go to state 218
    R_PAR           reduce using rule 120 (empty -> .)

    paramF                         shift and go to state 217
    empty                          shift and go to state 219

state 166

    (100) exp -> bool . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 220

state 167

    (88) bool -> logical . np_addBool boolF
    (139) np_addBool -> .

    OR              reduce using rule 139 (np_addBool -> .)
    AND             reduce using rule 139 (np_addBool -> .)
    COMMA           reduce using rule 139 (np_addBool -> .)
    R_PAR           reduce using rule 139 (np_addBool -> .)
    R_BREAK         reduce using rule 139 (np_addBool -> .)
    TO              reduce using rule 139 (np_addBool -> .)
    SEMICOLON       reduce using rule 139 (np_addBool -> .)
    DO              reduce using rule 139 (np_addBool -> .)

    np_addBool                     shift and go to state 221

state 168

    (92) logical -> ex . np_addLogical logicalF
    (138) np_addLogical -> .

    LESS            reduce using rule 138 (np_addLogical -> .)
    GREATER         reduce using rule 138 (np_addLogical -> .)
    LESS_TH         reduce using rule 138 (np_addLogical -> .)
    GREAT_TH        reduce using rule 138 (np_addLogical -> .)
    SAME            reduce using rule 138 (np_addLogical -> .)
    DIF             reduce using rule 138 (np_addLogical -> .)
    OR              reduce using rule 138 (np_addLogical -> .)
    AND             reduce using rule 138 (np_addLogical -> .)
    COMMA           reduce using rule 138 (np_addLogical -> .)
    R_PAR           reduce using rule 138 (np_addLogical -> .)
    R_BREAK         reduce using rule 138 (np_addLogical -> .)
    TO              reduce using rule 138 (np_addLogical -> .)
    SEMICOLON       reduce using rule 138 (np_addLogical -> .)
    DO              reduce using rule 138 (np_addLogical -> .)

    np_addLogical                  shift and go to state 222

state 169

    (101) ex -> term . np_addEx exF
    (137) np_addEx -> .

    PLUS            reduce using rule 137 (np_addEx -> .)
    MINUS           reduce using rule 137 (np_addEx -> .)
    LESS            reduce using rule 137 (np_addEx -> .)
    GREATER         reduce using rule 137 (np_addEx -> .)
    LESS_TH         reduce using rule 137 (np_addEx -> .)
    GREAT_TH        reduce using rule 137 (np_addEx -> .)
    SAME            reduce using rule 137 (np_addEx -> .)
    DIF             reduce using rule 137 (np_addEx -> .)
    OR              reduce using rule 137 (np_addEx -> .)
    AND             reduce using rule 137 (np_addEx -> .)
    COMMA           reduce using rule 137 (np_addEx -> .)
    R_PAR           reduce using rule 137 (np_addEx -> .)
    R_BREAK         reduce using rule 137 (np_addEx -> .)
    TO              reduce using rule 137 (np_addEx -> .)
    SEMICOLON       reduce using rule 137 (np_addEx -> .)
    DO              reduce using rule 137 (np_addEx -> .)

    np_addEx                       shift and go to state 223

state 170

    (105) term -> factor . np_addTerm termF
    (136) np_addTerm -> .

    MULT            reduce using rule 136 (np_addTerm -> .)
    DIV             reduce using rule 136 (np_addTerm -> .)
    PLUS            reduce using rule 136 (np_addTerm -> .)
    MINUS           reduce using rule 136 (np_addTerm -> .)
    LESS            reduce using rule 136 (np_addTerm -> .)
    GREATER         reduce using rule 136 (np_addTerm -> .)
    LESS_TH         reduce using rule 136 (np_addTerm -> .)
    GREAT_TH        reduce using rule 136 (np_addTerm -> .)
    SAME            reduce using rule 136 (np_addTerm -> .)
    DIF             reduce using rule 136 (np_addTerm -> .)
    OR              reduce using rule 136 (np_addTerm -> .)
    AND             reduce using rule 136 (np_addTerm -> .)
    COMMA           reduce using rule 136 (np_addTerm -> .)
    R_PAR           reduce using rule 136 (np_addTerm -> .)
    R_BREAK         reduce using rule 136 (np_addTerm -> .)
    TO              reduce using rule 136 (np_addTerm -> .)
    SEMICOLON       reduce using rule 136 (np_addTerm -> .)
    DO              reduce using rule 136 (np_addTerm -> .)

    np_addTerm                     shift and go to state 224

state 171

    (110) factor -> factorT .

    MULT            reduce using rule 110 (factor -> factorT .)
    DIV             reduce using rule 110 (factor -> factorT .)
    PLUS            reduce using rule 110 (factor -> factorT .)
    MINUS           reduce using rule 110 (factor -> factorT .)
    LESS            reduce using rule 110 (factor -> factorT .)
    GREATER         reduce using rule 110 (factor -> factorT .)
    LESS_TH         reduce using rule 110 (factor -> factorT .)
    GREAT_TH        reduce using rule 110 (factor -> factorT .)
    SAME            reduce using rule 110 (factor -> factorT .)
    DIF             reduce using rule 110 (factor -> factorT .)
    OR              reduce using rule 110 (factor -> factorT .)
    AND             reduce using rule 110 (factor -> factorT .)
    COMMA           reduce using rule 110 (factor -> factorT .)
    R_PAR           reduce using rule 110 (factor -> factorT .)
    R_BREAK         reduce using rule 110 (factor -> factorT .)
    TO              reduce using rule 110 (factor -> factorT .)
    SEMICOLON       reduce using rule 110 (factor -> factorT .)
    DO              reduce using rule 110 (factor -> factorT .)


state 172

    (111) factorT -> PLUS . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    factorF                        shift and go to state 225
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 173

    (113) factorT -> factorF .

    MULT            reduce using rule 113 (factorT -> factorF .)
    DIV             reduce using rule 113 (factorT -> factorF .)
    PLUS            reduce using rule 113 (factorT -> factorF .)
    MINUS           reduce using rule 113 (factorT -> factorF .)
    LESS            reduce using rule 113 (factorT -> factorF .)
    GREATER         reduce using rule 113 (factorT -> factorF .)
    LESS_TH         reduce using rule 113 (factorT -> factorF .)
    GREAT_TH        reduce using rule 113 (factorT -> factorF .)
    SAME            reduce using rule 113 (factorT -> factorF .)
    DIF             reduce using rule 113 (factorT -> factorF .)
    OR              reduce using rule 113 (factorT -> factorF .)
    AND             reduce using rule 113 (factorT -> factorF .)
    COMMA           reduce using rule 113 (factorT -> factorF .)
    R_PAR           reduce using rule 113 (factorT -> factorF .)
    R_BREAK         reduce using rule 113 (factorT -> factorF .)
    TO              reduce using rule 113 (factorT -> factorF .)
    SEMICOLON       reduce using rule 113 (factorT -> factorF .)
    DO              reduce using rule 113 (factorT -> factorF .)


state 174

    (112) factorT -> MINUS . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    factorF                        shift and go to state 226
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 175

    (114) factorF -> varcte . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 227

state 176

    (115) varcte -> var . np_addId empty
    (127) np_addId -> .

    MULT            reduce using rule 127 (np_addId -> .)
    DIV             reduce using rule 127 (np_addId -> .)
    PLUS            reduce using rule 127 (np_addId -> .)
    MINUS           reduce using rule 127 (np_addId -> .)
    LESS            reduce using rule 127 (np_addId -> .)
    GREATER         reduce using rule 127 (np_addId -> .)
    LESS_TH         reduce using rule 127 (np_addId -> .)
    GREAT_TH        reduce using rule 127 (np_addId -> .)
    SAME            reduce using rule 127 (np_addId -> .)
    DIF             reduce using rule 127 (np_addId -> .)
    OR              reduce using rule 127 (np_addId -> .)
    AND             reduce using rule 127 (np_addId -> .)
    COMMA           reduce using rule 127 (np_addId -> .)
    R_PAR           reduce using rule 127 (np_addId -> .)
    R_BREAK         reduce using rule 127 (np_addId -> .)
    TO              reduce using rule 127 (np_addId -> .)
    SEMICOLON       reduce using rule 127 (np_addId -> .)
    DO              reduce using rule 127 (np_addId -> .)

    np_addId                       shift and go to state 228

state 177

    (116) varcte -> CTE_INT . np_addConstInt empty
    (128) np_addConstInt -> .

    MULT            reduce using rule 128 (np_addConstInt -> .)
    DIV             reduce using rule 128 (np_addConstInt -> .)
    PLUS            reduce using rule 128 (np_addConstInt -> .)
    MINUS           reduce using rule 128 (np_addConstInt -> .)
    LESS            reduce using rule 128 (np_addConstInt -> .)
    GREATER         reduce using rule 128 (np_addConstInt -> .)
    LESS_TH         reduce using rule 128 (np_addConstInt -> .)
    GREAT_TH        reduce using rule 128 (np_addConstInt -> .)
    SAME            reduce using rule 128 (np_addConstInt -> .)
    DIF             reduce using rule 128 (np_addConstInt -> .)
    OR              reduce using rule 128 (np_addConstInt -> .)
    AND             reduce using rule 128 (np_addConstInt -> .)
    COMMA           reduce using rule 128 (np_addConstInt -> .)
    R_PAR           reduce using rule 128 (np_addConstInt -> .)
    R_BREAK         reduce using rule 128 (np_addConstInt -> .)
    TO              reduce using rule 128 (np_addConstInt -> .)
    SEMICOLON       reduce using rule 128 (np_addConstInt -> .)
    DO              reduce using rule 128 (np_addConstInt -> .)

    np_addConstInt                 shift and go to state 229

state 178

    (117) varcte -> CTE_FLOAT . np_addConstFloat empty
    (129) np_addConstFloat -> .

    MULT            reduce using rule 129 (np_addConstFloat -> .)
    DIV             reduce using rule 129 (np_addConstFloat -> .)
    PLUS            reduce using rule 129 (np_addConstFloat -> .)
    MINUS           reduce using rule 129 (np_addConstFloat -> .)
    LESS            reduce using rule 129 (np_addConstFloat -> .)
    GREATER         reduce using rule 129 (np_addConstFloat -> .)
    LESS_TH         reduce using rule 129 (np_addConstFloat -> .)
    GREAT_TH        reduce using rule 129 (np_addConstFloat -> .)
    SAME            reduce using rule 129 (np_addConstFloat -> .)
    DIF             reduce using rule 129 (np_addConstFloat -> .)
    OR              reduce using rule 129 (np_addConstFloat -> .)
    AND             reduce using rule 129 (np_addConstFloat -> .)
    COMMA           reduce using rule 129 (np_addConstFloat -> .)
    R_PAR           reduce using rule 129 (np_addConstFloat -> .)
    R_BREAK         reduce using rule 129 (np_addConstFloat -> .)
    TO              reduce using rule 129 (np_addConstFloat -> .)
    SEMICOLON       reduce using rule 129 (np_addConstFloat -> .)
    DO              reduce using rule 129 (np_addConstFloat -> .)

    np_addConstFloat               shift and go to state 230

state 179

    (118) varcte -> CTE_CHAR . np_addConstChar empty
    (130) np_addConstChar -> .

    MULT            reduce using rule 130 (np_addConstChar -> .)
    DIV             reduce using rule 130 (np_addConstChar -> .)
    PLUS            reduce using rule 130 (np_addConstChar -> .)
    MINUS           reduce using rule 130 (np_addConstChar -> .)
    LESS            reduce using rule 130 (np_addConstChar -> .)
    GREATER         reduce using rule 130 (np_addConstChar -> .)
    LESS_TH         reduce using rule 130 (np_addConstChar -> .)
    GREAT_TH        reduce using rule 130 (np_addConstChar -> .)
    SAME            reduce using rule 130 (np_addConstChar -> .)
    DIF             reduce using rule 130 (np_addConstChar -> .)
    OR              reduce using rule 130 (np_addConstChar -> .)
    AND             reduce using rule 130 (np_addConstChar -> .)
    COMMA           reduce using rule 130 (np_addConstChar -> .)
    R_PAR           reduce using rule 130 (np_addConstChar -> .)
    R_BREAK         reduce using rule 130 (np_addConstChar -> .)
    TO              reduce using rule 130 (np_addConstChar -> .)
    SEMICOLON       reduce using rule 130 (np_addConstChar -> .)
    DO              reduce using rule 130 (np_addConstChar -> .)

    np_addConstChar                shift and go to state 231

state 180

    (119) varcte -> CTE_BOOL . np_addConstBool empty
    (131) np_addConstBool -> .

    MULT            reduce using rule 131 (np_addConstBool -> .)
    DIV             reduce using rule 131 (np_addConstBool -> .)
    PLUS            reduce using rule 131 (np_addConstBool -> .)
    MINUS           reduce using rule 131 (np_addConstBool -> .)
    LESS            reduce using rule 131 (np_addConstBool -> .)
    GREATER         reduce using rule 131 (np_addConstBool -> .)
    LESS_TH         reduce using rule 131 (np_addConstBool -> .)
    GREAT_TH        reduce using rule 131 (np_addConstBool -> .)
    SAME            reduce using rule 131 (np_addConstBool -> .)
    DIF             reduce using rule 131 (np_addConstBool -> .)
    OR              reduce using rule 131 (np_addConstBool -> .)
    AND             reduce using rule 131 (np_addConstBool -> .)
    COMMA           reduce using rule 131 (np_addConstBool -> .)
    R_PAR           reduce using rule 131 (np_addConstBool -> .)
    R_BREAK         reduce using rule 131 (np_addConstBool -> .)
    TO              reduce using rule 131 (np_addConstBool -> .)
    SEMICOLON       reduce using rule 131 (np_addConstBool -> .)
    DO              reduce using rule 131 (np_addConstBool -> .)

    np_addConstBool                shift and go to state 232

state 181

    (59) return -> RETURN L_PAR exp . np_addReturn R_PAR empty
    (143) np_addReturn -> .

    R_PAR           reduce using rule 143 (np_addReturn -> .)

    np_addReturn                   shift and go to state 233

state 182

    (64) read -> READ L_PAR readF .

    SEMICOLON       reduce using rule 64 (read -> READ L_PAR readF .)


state 183

    (65) readF -> var . np_addRead COMMA readF
    (66) readF -> var . np_addRead R_PAR empty
    (141) np_addRead -> .

    COMMA           reduce using rule 141 (np_addRead -> .)
    R_PAR           reduce using rule 141 (np_addRead -> .)

    np_addRead                     shift and go to state 234

state 184

    (67) write -> WRITE L_PAR writeT .

    SEMICOLON       reduce using rule 67 (write -> WRITE L_PAR writeT .)


state 185

    (68) writeT -> CTE_STRING . np_addConstString writeF
    (132) np_addConstString -> .

    COMMA           reduce using rule 132 (np_addConstString -> .)
    R_PAR           reduce using rule 132 (np_addConstString -> .)

    np_addConstString              shift and go to state 235

state 186

    (69) writeT -> exp . writeF
    (70) writeF -> . COMMA np_addWrite writeT
    (71) writeF -> . R_PAR np_addWrite empty

    COMMA           shift and go to state 237
    R_PAR           shift and go to state 238

    writeF                         shift and go to state 236

state 187

    (74) if -> IF L_PAR exp . np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (144) np_checkBool -> .

    R_PAR           reduce using rule 144 (np_checkBool -> .)

    np_checkBool                   shift and go to state 239

state 188

    (62) varF -> arrfunc empty .

    EQUAL           reduce using rule 62 (varF -> arrfunc empty .)
    PLUS_EQ         reduce using rule 62 (varF -> arrfunc empty .)
    MIN_EQ          reduce using rule 62 (varF -> arrfunc empty .)
    MULT_EQ         reduce using rule 62 (varF -> arrfunc empty .)
    DIV_EQ          reduce using rule 62 (varF -> arrfunc empty .)
    MULT            reduce using rule 62 (varF -> arrfunc empty .)
    DIV             reduce using rule 62 (varF -> arrfunc empty .)
    PLUS            reduce using rule 62 (varF -> arrfunc empty .)
    MINUS           reduce using rule 62 (varF -> arrfunc empty .)
    LESS            reduce using rule 62 (varF -> arrfunc empty .)
    GREATER         reduce using rule 62 (varF -> arrfunc empty .)
    LESS_TH         reduce using rule 62 (varF -> arrfunc empty .)
    GREAT_TH        reduce using rule 62 (varF -> arrfunc empty .)
    SAME            reduce using rule 62 (varF -> arrfunc empty .)
    DIF             reduce using rule 62 (varF -> arrfunc empty .)
    OR              reduce using rule 62 (varF -> arrfunc empty .)
    AND             reduce using rule 62 (varF -> arrfunc empty .)
    COMMA           reduce using rule 62 (varF -> arrfunc empty .)
    R_PAR           reduce using rule 62 (varF -> arrfunc empty .)
    R_BREAK         reduce using rule 62 (varF -> arrfunc empty .)
    TO              reduce using rule 62 (varF -> arrfunc empty .)
    SEMICOLON       reduce using rule 62 (varF -> arrfunc empty .)
    DO              reduce using rule 62 (varF -> arrfunc empty .)


state 189

    (54) arrfunc -> L_BREAK exp . COMMA exp R_BREAK empty
    (55) arrfunc -> L_BREAK exp . R_BREAK empty

    COMMA           shift and go to state 240
    R_BREAK         shift and go to state 241


state 190

    (84) conditional -> WHILE np_addWhile L_PAR . exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    exp                            shift and go to state 242
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 191

    (85) nonconditional -> FROM VAR arrfunc . nonconditionalF
    (87) nonconditionalF -> . exp TO exp DO L_CURPAR statement R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    nonconditionalF                shift and go to state 243
    exp                            shift and go to state 193
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 192

    (86) nonconditional -> FROM VAR nonconditionalF .

    ID              reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    RETURN          reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    READ            reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    WRITE           reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    IF              reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    VAR             reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    WHILE           reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    FROM            reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    R_CURPAR        reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)


state 193

    (87) nonconditionalF -> exp . TO exp DO L_CURPAR statement R_CURPAR empty

    TO              shift and go to state 244


state 194

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR . SEMICOLON empty

    SEMICOLON       shift and go to state 245


state 195

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec dec .

    MAIN            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    INT             reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    FLOAT           reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    CHAR            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    BOOL            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    ID              reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    VOID            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    METHODS         reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    L_CURPAR        reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)


state 196

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    METHODS         reduce using rule 120 (empty -> .)
    L_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 246

state 197

    (25) funcF -> parameter R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 247


state 198

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 248
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 199

    (33) parameter -> VAR COLON typepar SEMICOLON . parameterF
    (34) parameterF -> . parameter
    (35) parameterF -> . empty
    (33) parameter -> . VAR COLON typepar SEMICOLON parameterF
    (120) empty -> .

    VAR             shift and go to state 83
    R_PAR           reduce using rule 120 (empty -> .)

    parameterF                     shift and go to state 249
    parameter                      shift and go to state 250
    empty                          shift and go to state 251

state 200

    (36) typepar -> INT empty .

    SEMICOLON       reduce using rule 36 (typepar -> INT empty .)


state 201

    (37) typepar -> FLOAT empty .

    SEMICOLON       reduce using rule 37 (typepar -> FLOAT empty .)


state 202

    (38) typepar -> CHAR empty .

    SEMICOLON       reduce using rule 38 (typepar -> CHAR empty .)


state 203

    (39) typepar -> BOOL empty .

    SEMICOLON       reduce using rule 39 (typepar -> BOOL empty .)


state 204

    (40) typepar -> ID empty .

    SEMICOLON       reduce using rule 40 (typepar -> ID empty .)


state 205

    (78) assigmentF -> EQUAL np_addOp . exp np_doAssign empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    exp                            shift and go to state 252
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 206

    (79) assigmentF -> ope np_addOp . exp np_doAssign empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    exp                            shift and go to state 253
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 207

    (80) ope -> PLUS_EQ empty .

    L_PAR           reduce using rule 80 (ope -> PLUS_EQ empty .)
    PLUS            reduce using rule 80 (ope -> PLUS_EQ empty .)
    MINUS           reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_INT         reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_FLOAT       reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_CHAR        reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_BOOL        reduce using rule 80 (ope -> PLUS_EQ empty .)
    VAR             reduce using rule 80 (ope -> PLUS_EQ empty .)
    ID              reduce using rule 80 (ope -> PLUS_EQ empty .)


state 208

    (81) ope -> MIN_EQ empty .

    L_PAR           reduce using rule 81 (ope -> MIN_EQ empty .)
    PLUS            reduce using rule 81 (ope -> MIN_EQ empty .)
    MINUS           reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_INT         reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_FLOAT       reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_CHAR        reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_BOOL        reduce using rule 81 (ope -> MIN_EQ empty .)
    VAR             reduce using rule 81 (ope -> MIN_EQ empty .)
    ID              reduce using rule 81 (ope -> MIN_EQ empty .)


state 209

    (82) ope -> MULT_EQ empty .

    L_PAR           reduce using rule 82 (ope -> MULT_EQ empty .)
    PLUS            reduce using rule 82 (ope -> MULT_EQ empty .)
    MINUS           reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_INT         reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_FLOAT       reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_CHAR        reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_BOOL        reduce using rule 82 (ope -> MULT_EQ empty .)
    VAR             reduce using rule 82 (ope -> MULT_EQ empty .)
    ID              reduce using rule 82 (ope -> MULT_EQ empty .)


state 210

    (83) ope -> DIV_EQ empty .

    L_PAR           reduce using rule 83 (ope -> DIV_EQ empty .)
    PLUS            reduce using rule 83 (ope -> DIV_EQ empty .)
    MINUS           reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_INT         reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_FLOAT       reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_CHAR        reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_BOOL        reduce using rule 83 (ope -> DIV_EQ empty .)
    VAR             reduce using rule 83 (ope -> DIV_EQ empty .)
    ID              reduce using rule 83 (ope -> DIV_EQ empty .)


state 211

    (51) void -> ID DOT ID L_PAR . param R_PAR empty
    (56) param -> . exp paramF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    param                          shift and go to state 254
    exp                            shift and go to state 165
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 212

    (61) var -> ID DOT VAR varF .

    EQUAL           reduce using rule 61 (var -> ID DOT VAR varF .)
    PLUS_EQ         reduce using rule 61 (var -> ID DOT VAR varF .)
    MIN_EQ          reduce using rule 61 (var -> ID DOT VAR varF .)
    MULT_EQ         reduce using rule 61 (var -> ID DOT VAR varF .)
    DIV_EQ          reduce using rule 61 (var -> ID DOT VAR varF .)
    MULT            reduce using rule 61 (var -> ID DOT VAR varF .)
    DIV             reduce using rule 61 (var -> ID DOT VAR varF .)
    PLUS            reduce using rule 61 (var -> ID DOT VAR varF .)
    MINUS           reduce using rule 61 (var -> ID DOT VAR varF .)
    LESS            reduce using rule 61 (var -> ID DOT VAR varF .)
    GREATER         reduce using rule 61 (var -> ID DOT VAR varF .)
    LESS_TH         reduce using rule 61 (var -> ID DOT VAR varF .)
    GREAT_TH        reduce using rule 61 (var -> ID DOT VAR varF .)
    SAME            reduce using rule 61 (var -> ID DOT VAR varF .)
    DIF             reduce using rule 61 (var -> ID DOT VAR varF .)
    OR              reduce using rule 61 (var -> ID DOT VAR varF .)
    AND             reduce using rule 61 (var -> ID DOT VAR varF .)
    COMMA           reduce using rule 61 (var -> ID DOT VAR varF .)
    R_PAR           reduce using rule 61 (var -> ID DOT VAR varF .)
    R_BREAK         reduce using rule 61 (var -> ID DOT VAR varF .)
    TO              reduce using rule 61 (var -> ID DOT VAR varF .)
    SEMICOLON       reduce using rule 61 (var -> ID DOT VAR varF .)
    DO              reduce using rule 61 (var -> ID DOT VAR varF .)


state 213

    (61) var -> ID DOT . VAR varF

    VAR             shift and go to state 160


state 214

    (109) factor -> L_PAR np_addPar . exp R_PAR np_popPar empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    exp                            shift and go to state 255
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 215

    (52) void -> ID L_PAR param R_PAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 256

state 216

    (53) void -> ID L_PAR R_PAR empty .

    SEMICOLON       reduce using rule 53 (void -> ID L_PAR R_PAR empty .)


state 217

    (56) param -> exp paramF .

    R_PAR           reduce using rule 56 (param -> exp paramF .)


state 218

    (57) paramF -> COMMA . param
    (56) param -> . exp paramF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    param                          shift and go to state 257
    exp                            shift and go to state 165
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 219

    (58) paramF -> empty .

    R_PAR           reduce using rule 58 (paramF -> empty .)


state 220

    (100) exp -> bool empty .

    COMMA           reduce using rule 100 (exp -> bool empty .)
    R_PAR           reduce using rule 100 (exp -> bool empty .)
    R_BREAK         reduce using rule 100 (exp -> bool empty .)
    TO              reduce using rule 100 (exp -> bool empty .)
    SEMICOLON       reduce using rule 100 (exp -> bool empty .)
    DO              reduce using rule 100 (exp -> bool empty .)


state 221

    (88) bool -> logical np_addBool . boolF
    (89) boolF -> . OR np_addOp bool
    (90) boolF -> . AND np_addOp bool
    (91) boolF -> . empty
    (120) empty -> .

    OR              shift and go to state 259
    AND             shift and go to state 260
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    boolF                          shift and go to state 258
    empty                          shift and go to state 261

state 222

    (92) logical -> ex np_addLogical . logicalF
    (93) logicalF -> . LESS np_addOp logical
    (94) logicalF -> . GREATER np_addOp logical
    (95) logicalF -> . LESS_TH np_addOp logical
    (96) logicalF -> . GREAT_TH np_addOp logical
    (97) logicalF -> . SAME np_addOp logical
    (98) logicalF -> . DIF np_addOp logical
    (99) logicalF -> . empty
    (120) empty -> .

    LESS            shift and go to state 263
    GREATER         shift and go to state 264
    LESS_TH         shift and go to state 265
    GREAT_TH        shift and go to state 266
    SAME            shift and go to state 267
    DIF             shift and go to state 268
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    logicalF                       shift and go to state 262
    empty                          shift and go to state 269

state 223

    (101) ex -> term np_addEx . exF
    (102) exF -> . PLUS np_addOp ex
    (103) exF -> . MINUS np_addOp ex
    (104) exF -> . empty
    (120) empty -> .

    PLUS            shift and go to state 271
    MINUS           shift and go to state 272
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    exF                            shift and go to state 270
    empty                          shift and go to state 273

state 224

    (105) term -> factor np_addTerm . termF
    (106) termF -> . MULT np_addOp term
    (107) termF -> . DIV np_addOp term
    (108) termF -> . empty
    (120) empty -> .

    MULT            shift and go to state 275
    DIV             shift and go to state 276
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    termF                          shift and go to state 274
    empty                          shift and go to state 277

state 225

    (111) factorT -> PLUS factorF .

    MULT            reduce using rule 111 (factorT -> PLUS factorF .)
    DIV             reduce using rule 111 (factorT -> PLUS factorF .)
    PLUS            reduce using rule 111 (factorT -> PLUS factorF .)
    MINUS           reduce using rule 111 (factorT -> PLUS factorF .)
    LESS            reduce using rule 111 (factorT -> PLUS factorF .)
    GREATER         reduce using rule 111 (factorT -> PLUS factorF .)
    LESS_TH         reduce using rule 111 (factorT -> PLUS factorF .)
    GREAT_TH        reduce using rule 111 (factorT -> PLUS factorF .)
    SAME            reduce using rule 111 (factorT -> PLUS factorF .)
    DIF             reduce using rule 111 (factorT -> PLUS factorF .)
    OR              reduce using rule 111 (factorT -> PLUS factorF .)
    AND             reduce using rule 111 (factorT -> PLUS factorF .)
    COMMA           reduce using rule 111 (factorT -> PLUS factorF .)
    R_PAR           reduce using rule 111 (factorT -> PLUS factorF .)
    R_BREAK         reduce using rule 111 (factorT -> PLUS factorF .)
    TO              reduce using rule 111 (factorT -> PLUS factorF .)
    SEMICOLON       reduce using rule 111 (factorT -> PLUS factorF .)
    DO              reduce using rule 111 (factorT -> PLUS factorF .)


state 226

    (112) factorT -> MINUS factorF .

    MULT            reduce using rule 112 (factorT -> MINUS factorF .)
    DIV             reduce using rule 112 (factorT -> MINUS factorF .)
    PLUS            reduce using rule 112 (factorT -> MINUS factorF .)
    MINUS           reduce using rule 112 (factorT -> MINUS factorF .)
    LESS            reduce using rule 112 (factorT -> MINUS factorF .)
    GREATER         reduce using rule 112 (factorT -> MINUS factorF .)
    LESS_TH         reduce using rule 112 (factorT -> MINUS factorF .)
    GREAT_TH        reduce using rule 112 (factorT -> MINUS factorF .)
    SAME            reduce using rule 112 (factorT -> MINUS factorF .)
    DIF             reduce using rule 112 (factorT -> MINUS factorF .)
    OR              reduce using rule 112 (factorT -> MINUS factorF .)
    AND             reduce using rule 112 (factorT -> MINUS factorF .)
    COMMA           reduce using rule 112 (factorT -> MINUS factorF .)
    R_PAR           reduce using rule 112 (factorT -> MINUS factorF .)
    R_BREAK         reduce using rule 112 (factorT -> MINUS factorF .)
    TO              reduce using rule 112 (factorT -> MINUS factorF .)
    SEMICOLON       reduce using rule 112 (factorT -> MINUS factorF .)
    DO              reduce using rule 112 (factorT -> MINUS factorF .)


state 227

    (114) factorF -> varcte empty .

    MULT            reduce using rule 114 (factorF -> varcte empty .)
    DIV             reduce using rule 114 (factorF -> varcte empty .)
    PLUS            reduce using rule 114 (factorF -> varcte empty .)
    MINUS           reduce using rule 114 (factorF -> varcte empty .)
    LESS            reduce using rule 114 (factorF -> varcte empty .)
    GREATER         reduce using rule 114 (factorF -> varcte empty .)
    LESS_TH         reduce using rule 114 (factorF -> varcte empty .)
    GREAT_TH        reduce using rule 114 (factorF -> varcte empty .)
    SAME            reduce using rule 114 (factorF -> varcte empty .)
    DIF             reduce using rule 114 (factorF -> varcte empty .)
    OR              reduce using rule 114 (factorF -> varcte empty .)
    AND             reduce using rule 114 (factorF -> varcte empty .)
    COMMA           reduce using rule 114 (factorF -> varcte empty .)
    R_PAR           reduce using rule 114 (factorF -> varcte empty .)
    R_BREAK         reduce using rule 114 (factorF -> varcte empty .)
    TO              reduce using rule 114 (factorF -> varcte empty .)
    SEMICOLON       reduce using rule 114 (factorF -> varcte empty .)
    DO              reduce using rule 114 (factorF -> varcte empty .)


state 228

    (115) varcte -> var np_addId . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 278

state 229

    (116) varcte -> CTE_INT np_addConstInt . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 279

state 230

    (117) varcte -> CTE_FLOAT np_addConstFloat . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 280

state 231

    (118) varcte -> CTE_CHAR np_addConstChar . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 281

state 232

    (119) varcte -> CTE_BOOL np_addConstBool . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 282

state 233

    (59) return -> RETURN L_PAR exp np_addReturn . R_PAR empty

    R_PAR           shift and go to state 283


state 234

    (65) readF -> var np_addRead . COMMA readF
    (66) readF -> var np_addRead . R_PAR empty

    COMMA           shift and go to state 284
    R_PAR           shift and go to state 285


state 235

    (68) writeT -> CTE_STRING np_addConstString . writeF
    (70) writeF -> . COMMA np_addWrite writeT
    (71) writeF -> . R_PAR np_addWrite empty

    COMMA           shift and go to state 237
    R_PAR           shift and go to state 238

    writeF                         shift and go to state 286

state 236

    (69) writeT -> exp writeF .

    SEMICOLON       reduce using rule 69 (writeT -> exp writeF .)


state 237

    (70) writeF -> COMMA . np_addWrite writeT
    (142) np_addWrite -> .

    CTE_STRING      reduce using rule 142 (np_addWrite -> .)
    L_PAR           reduce using rule 142 (np_addWrite -> .)
    PLUS            reduce using rule 142 (np_addWrite -> .)
    MINUS           reduce using rule 142 (np_addWrite -> .)
    CTE_INT         reduce using rule 142 (np_addWrite -> .)
    CTE_FLOAT       reduce using rule 142 (np_addWrite -> .)
    CTE_CHAR        reduce using rule 142 (np_addWrite -> .)
    CTE_BOOL        reduce using rule 142 (np_addWrite -> .)
    VAR             reduce using rule 142 (np_addWrite -> .)
    ID              reduce using rule 142 (np_addWrite -> .)

    np_addWrite                    shift and go to state 287

state 238

    (71) writeF -> R_PAR . np_addWrite empty
    (142) np_addWrite -> .

    SEMICOLON       reduce using rule 142 (np_addWrite -> .)

    np_addWrite                    shift and go to state 288

state 239

    (74) if -> IF L_PAR exp np_checkBool . R_PAR THEN L_CURPAR statement R_CURPAR ifF

    R_PAR           shift and go to state 289


state 240

    (54) arrfunc -> L_BREAK exp COMMA . exp R_BREAK empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    exp                            shift and go to state 290
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 241

    (55) arrfunc -> L_BREAK exp R_BREAK . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)
    L_PAR           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 291

state 242

    (84) conditional -> WHILE np_addWhile L_PAR exp . R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty

    R_PAR           shift and go to state 292


state 243

    (85) nonconditional -> FROM VAR arrfunc nonconditionalF .

    ID              reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    RETURN          reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    READ            reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WRITE           reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    IF              reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    VAR             reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WHILE           reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    FROM            reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    R_CURPAR        reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)


state 244

    (87) nonconditionalF -> exp TO . exp DO L_CURPAR statement R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    exp                            shift and go to state 293
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 245

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON . empty
    (120) empty -> .

    CLASS           reduce using rule 120 (empty -> .)
    VARS            reduce using rule 120 (empty -> .)
    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 294

state 246

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .

    MAIN            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    INT             reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    FLOAT           reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    CHAR            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    BOOL            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    ID              reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    VOID            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    METHODS         reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    L_CURPAR        reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)


state 247

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 295
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 248

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 296


state 249

    (33) parameter -> VAR COLON typepar SEMICOLON parameterF .

    R_PAR           reduce using rule 33 (parameter -> VAR COLON typepar SEMICOLON parameterF .)


state 250

    (34) parameterF -> parameter .

    R_PAR           reduce using rule 34 (parameterF -> parameter .)


state 251

    (35) parameterF -> empty .

    R_PAR           reduce using rule 35 (parameterF -> empty .)


state 252

    (78) assigmentF -> EQUAL np_addOp exp . np_doAssign empty
    (140) np_doAssign -> .

    SEMICOLON       reduce using rule 140 (np_doAssign -> .)

    np_doAssign                    shift and go to state 297

state 253

    (79) assigmentF -> ope np_addOp exp . np_doAssign empty
    (140) np_doAssign -> .

    SEMICOLON       reduce using rule 140 (np_doAssign -> .)

    np_doAssign                    shift and go to state 298

state 254

    (51) void -> ID DOT ID L_PAR param . R_PAR empty

    R_PAR           shift and go to state 299


state 255

    (109) factor -> L_PAR np_addPar exp . R_PAR np_popPar empty

    R_PAR           shift and go to state 300


state 256

    (52) void -> ID L_PAR param R_PAR empty .

    SEMICOLON       reduce using rule 52 (void -> ID L_PAR param R_PAR empty .)


state 257

    (57) paramF -> COMMA param .

    R_PAR           reduce using rule 57 (paramF -> COMMA param .)


state 258

    (88) bool -> logical np_addBool boolF .

    COMMA           reduce using rule 88 (bool -> logical np_addBool boolF .)
    R_PAR           reduce using rule 88 (bool -> logical np_addBool boolF .)
    R_BREAK         reduce using rule 88 (bool -> logical np_addBool boolF .)
    TO              reduce using rule 88 (bool -> logical np_addBool boolF .)
    SEMICOLON       reduce using rule 88 (bool -> logical np_addBool boolF .)
    DO              reduce using rule 88 (bool -> logical np_addBool boolF .)


state 259

    (89) boolF -> OR . np_addOp bool
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 301

state 260

    (90) boolF -> AND . np_addOp bool
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 302

state 261

    (91) boolF -> empty .

    COMMA           reduce using rule 91 (boolF -> empty .)
    R_PAR           reduce using rule 91 (boolF -> empty .)
    R_BREAK         reduce using rule 91 (boolF -> empty .)
    TO              reduce using rule 91 (boolF -> empty .)
    SEMICOLON       reduce using rule 91 (boolF -> empty .)
    DO              reduce using rule 91 (boolF -> empty .)


state 262

    (92) logical -> ex np_addLogical logicalF .

    OR              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    AND             reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    COMMA           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_PAR           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_BREAK         reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    TO              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    SEMICOLON       reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    DO              reduce using rule 92 (logical -> ex np_addLogical logicalF .)


state 263

    (93) logicalF -> LESS . np_addOp logical
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 303

state 264

    (94) logicalF -> GREATER . np_addOp logical
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 304

state 265

    (95) logicalF -> LESS_TH . np_addOp logical
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 305

state 266

    (96) logicalF -> GREAT_TH . np_addOp logical
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 306

state 267

    (97) logicalF -> SAME . np_addOp logical
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 307

state 268

    (98) logicalF -> DIF . np_addOp logical
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 308

state 269

    (99) logicalF -> empty .

    OR              reduce using rule 99 (logicalF -> empty .)
    AND             reduce using rule 99 (logicalF -> empty .)
    COMMA           reduce using rule 99 (logicalF -> empty .)
    R_PAR           reduce using rule 99 (logicalF -> empty .)
    R_BREAK         reduce using rule 99 (logicalF -> empty .)
    TO              reduce using rule 99 (logicalF -> empty .)
    SEMICOLON       reduce using rule 99 (logicalF -> empty .)
    DO              reduce using rule 99 (logicalF -> empty .)


state 270

    (101) ex -> term np_addEx exF .

    LESS            reduce using rule 101 (ex -> term np_addEx exF .)
    GREATER         reduce using rule 101 (ex -> term np_addEx exF .)
    LESS_TH         reduce using rule 101 (ex -> term np_addEx exF .)
    GREAT_TH        reduce using rule 101 (ex -> term np_addEx exF .)
    SAME            reduce using rule 101 (ex -> term np_addEx exF .)
    DIF             reduce using rule 101 (ex -> term np_addEx exF .)
    OR              reduce using rule 101 (ex -> term np_addEx exF .)
    AND             reduce using rule 101 (ex -> term np_addEx exF .)
    COMMA           reduce using rule 101 (ex -> term np_addEx exF .)
    R_PAR           reduce using rule 101 (ex -> term np_addEx exF .)
    R_BREAK         reduce using rule 101 (ex -> term np_addEx exF .)
    TO              reduce using rule 101 (ex -> term np_addEx exF .)
    SEMICOLON       reduce using rule 101 (ex -> term np_addEx exF .)
    DO              reduce using rule 101 (ex -> term np_addEx exF .)


state 271

    (102) exF -> PLUS . np_addOp ex
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 309

state 272

    (103) exF -> MINUS . np_addOp ex
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 310

state 273

    (104) exF -> empty .

    LESS            reduce using rule 104 (exF -> empty .)
    GREATER         reduce using rule 104 (exF -> empty .)
    LESS_TH         reduce using rule 104 (exF -> empty .)
    GREAT_TH        reduce using rule 104 (exF -> empty .)
    SAME            reduce using rule 104 (exF -> empty .)
    DIF             reduce using rule 104 (exF -> empty .)
    OR              reduce using rule 104 (exF -> empty .)
    AND             reduce using rule 104 (exF -> empty .)
    COMMA           reduce using rule 104 (exF -> empty .)
    R_PAR           reduce using rule 104 (exF -> empty .)
    R_BREAK         reduce using rule 104 (exF -> empty .)
    TO              reduce using rule 104 (exF -> empty .)
    SEMICOLON       reduce using rule 104 (exF -> empty .)
    DO              reduce using rule 104 (exF -> empty .)


state 274

    (105) term -> factor np_addTerm termF .

    PLUS            reduce using rule 105 (term -> factor np_addTerm termF .)
    MINUS           reduce using rule 105 (term -> factor np_addTerm termF .)
    LESS            reduce using rule 105 (term -> factor np_addTerm termF .)
    GREATER         reduce using rule 105 (term -> factor np_addTerm termF .)
    LESS_TH         reduce using rule 105 (term -> factor np_addTerm termF .)
    GREAT_TH        reduce using rule 105 (term -> factor np_addTerm termF .)
    SAME            reduce using rule 105 (term -> factor np_addTerm termF .)
    DIF             reduce using rule 105 (term -> factor np_addTerm termF .)
    OR              reduce using rule 105 (term -> factor np_addTerm termF .)
    AND             reduce using rule 105 (term -> factor np_addTerm termF .)
    COMMA           reduce using rule 105 (term -> factor np_addTerm termF .)
    R_PAR           reduce using rule 105 (term -> factor np_addTerm termF .)
    R_BREAK         reduce using rule 105 (term -> factor np_addTerm termF .)
    TO              reduce using rule 105 (term -> factor np_addTerm termF .)
    SEMICOLON       reduce using rule 105 (term -> factor np_addTerm termF .)
    DO              reduce using rule 105 (term -> factor np_addTerm termF .)


state 275

    (106) termF -> MULT . np_addOp term
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 311

state 276

    (107) termF -> DIV . np_addOp term
    (133) np_addOp -> .

    L_PAR           reduce using rule 133 (np_addOp -> .)
    PLUS            reduce using rule 133 (np_addOp -> .)
    MINUS           reduce using rule 133 (np_addOp -> .)
    CTE_INT         reduce using rule 133 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 133 (np_addOp -> .)
    CTE_CHAR        reduce using rule 133 (np_addOp -> .)
    CTE_BOOL        reduce using rule 133 (np_addOp -> .)
    VAR             reduce using rule 133 (np_addOp -> .)
    ID              reduce using rule 133 (np_addOp -> .)

    np_addOp                       shift and go to state 312

state 277

    (108) termF -> empty .

    PLUS            reduce using rule 108 (termF -> empty .)
    MINUS           reduce using rule 108 (termF -> empty .)
    LESS            reduce using rule 108 (termF -> empty .)
    GREATER         reduce using rule 108 (termF -> empty .)
    LESS_TH         reduce using rule 108 (termF -> empty .)
    GREAT_TH        reduce using rule 108 (termF -> empty .)
    SAME            reduce using rule 108 (termF -> empty .)
    DIF             reduce using rule 108 (termF -> empty .)
    OR              reduce using rule 108 (termF -> empty .)
    AND             reduce using rule 108 (termF -> empty .)
    COMMA           reduce using rule 108 (termF -> empty .)
    R_PAR           reduce using rule 108 (termF -> empty .)
    R_BREAK         reduce using rule 108 (termF -> empty .)
    TO              reduce using rule 108 (termF -> empty .)
    SEMICOLON       reduce using rule 108 (termF -> empty .)
    DO              reduce using rule 108 (termF -> empty .)


state 278

    (115) varcte -> var np_addId empty .

    MULT            reduce using rule 115 (varcte -> var np_addId empty .)
    DIV             reduce using rule 115 (varcte -> var np_addId empty .)
    PLUS            reduce using rule 115 (varcte -> var np_addId empty .)
    MINUS           reduce using rule 115 (varcte -> var np_addId empty .)
    LESS            reduce using rule 115 (varcte -> var np_addId empty .)
    GREATER         reduce using rule 115 (varcte -> var np_addId empty .)
    LESS_TH         reduce using rule 115 (varcte -> var np_addId empty .)
    GREAT_TH        reduce using rule 115 (varcte -> var np_addId empty .)
    SAME            reduce using rule 115 (varcte -> var np_addId empty .)
    DIF             reduce using rule 115 (varcte -> var np_addId empty .)
    OR              reduce using rule 115 (varcte -> var np_addId empty .)
    AND             reduce using rule 115 (varcte -> var np_addId empty .)
    COMMA           reduce using rule 115 (varcte -> var np_addId empty .)
    R_PAR           reduce using rule 115 (varcte -> var np_addId empty .)
    R_BREAK         reduce using rule 115 (varcte -> var np_addId empty .)
    TO              reduce using rule 115 (varcte -> var np_addId empty .)
    SEMICOLON       reduce using rule 115 (varcte -> var np_addId empty .)
    DO              reduce using rule 115 (varcte -> var np_addId empty .)


state 279

    (116) varcte -> CTE_INT np_addConstInt empty .

    MULT            reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    DIV             reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    PLUS            reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    MINUS           reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    LESS            reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    GREATER         reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    LESS_TH         reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    GREAT_TH        reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    SAME            reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    DIF             reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    OR              reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    AND             reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    COMMA           reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    R_PAR           reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    R_BREAK         reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    TO              reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    SEMICOLON       reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)
    DO              reduce using rule 116 (varcte -> CTE_INT np_addConstInt empty .)


state 280

    (117) varcte -> CTE_FLOAT np_addConstFloat empty .

    MULT            reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    DIV             reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    PLUS            reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    MINUS           reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    LESS            reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    GREATER         reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    LESS_TH         reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    GREAT_TH        reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    SAME            reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    DIF             reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    OR              reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    AND             reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    COMMA           reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    R_PAR           reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    R_BREAK         reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    TO              reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    SEMICOLON       reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)
    DO              reduce using rule 117 (varcte -> CTE_FLOAT np_addConstFloat empty .)


state 281

    (118) varcte -> CTE_CHAR np_addConstChar empty .

    MULT            reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    DIV             reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    PLUS            reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    MINUS           reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    LESS            reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    GREATER         reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    LESS_TH         reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    GREAT_TH        reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    SAME            reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    DIF             reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    OR              reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    AND             reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    COMMA           reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    R_PAR           reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    R_BREAK         reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    TO              reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    SEMICOLON       reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)
    DO              reduce using rule 118 (varcte -> CTE_CHAR np_addConstChar empty .)


state 282

    (119) varcte -> CTE_BOOL np_addConstBool empty .

    MULT            reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    DIV             reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    PLUS            reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    MINUS           reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    LESS            reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    GREATER         reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    LESS_TH         reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    GREAT_TH        reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    SAME            reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    DIF             reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    OR              reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    AND             reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    COMMA           reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    R_PAR           reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    R_BREAK         reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    TO              reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    SEMICOLON       reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)
    DO              reduce using rule 119 (varcte -> CTE_BOOL np_addConstBool empty .)


state 283

    (59) return -> RETURN L_PAR exp np_addReturn R_PAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 313

state 284

    (65) readF -> var np_addRead COMMA . readF
    (65) readF -> . var np_addRead COMMA readF
    (66) readF -> . var np_addRead R_PAR empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 100
    ID              shift and go to state 161

    var                            shift and go to state 183
    readF                          shift and go to state 314

state 285

    (66) readF -> var np_addRead R_PAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 315

state 286

    (68) writeT -> CTE_STRING np_addConstString writeF .

    SEMICOLON       reduce using rule 68 (writeT -> CTE_STRING np_addConstString writeF .)


state 287

    (70) writeF -> COMMA np_addWrite . writeT
    (68) writeT -> . CTE_STRING np_addConstString writeF
    (69) writeT -> . exp writeF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 185
    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    writeT                         shift and go to state 316
    exp                            shift and go to state 186
    bool                           shift and go to state 166
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 288

    (71) writeF -> R_PAR np_addWrite . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 317

state 289

    (74) if -> IF L_PAR exp np_checkBool R_PAR . THEN L_CURPAR statement R_CURPAR ifF

    THEN            shift and go to state 318


state 290

    (54) arrfunc -> L_BREAK exp COMMA exp . R_BREAK empty

    R_BREAK         shift and go to state 319


state 291

    (55) arrfunc -> L_BREAK exp R_BREAK empty .

    EQUAL           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MIN_EQ          reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT_EQ         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV_EQ          reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MINUS           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREATER         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS_TH         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREAT_TH        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SAME            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIF             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    OR              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    AND             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    COMMA           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_PAR           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_BREAK         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    TO              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SEMICOLON       reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DO              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    L_PAR           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_INT         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_BOOL        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    VAR             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    ID              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)


state 292

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR . np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (144) np_checkBool -> .

    DO              reduce using rule 144 (np_checkBool -> .)

    np_checkBool                   shift and go to state 320

state 293

    (87) nonconditionalF -> exp TO exp . DO L_CURPAR statement R_CURPAR empty

    DO              shift and go to state 321


state 294

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .

    CLASS           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VARS            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    MAIN            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    INT             reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    FLOAT           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    CHAR            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    BOOL            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    ID              reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VOID            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)


state 295

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 322


state 296

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 323

state 297

    (78) assigmentF -> EQUAL np_addOp exp np_doAssign . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 324

state 298

    (79) assigmentF -> ope np_addOp exp np_doAssign . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 325

state 299

    (51) void -> ID DOT ID L_PAR param R_PAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 326

state 300

    (109) factor -> L_PAR np_addPar exp R_PAR . np_popPar empty
    (135) np_popPar -> .

    MULT            reduce using rule 135 (np_popPar -> .)
    DIV             reduce using rule 135 (np_popPar -> .)
    PLUS            reduce using rule 135 (np_popPar -> .)
    MINUS           reduce using rule 135 (np_popPar -> .)
    LESS            reduce using rule 135 (np_popPar -> .)
    GREATER         reduce using rule 135 (np_popPar -> .)
    LESS_TH         reduce using rule 135 (np_popPar -> .)
    GREAT_TH        reduce using rule 135 (np_popPar -> .)
    SAME            reduce using rule 135 (np_popPar -> .)
    DIF             reduce using rule 135 (np_popPar -> .)
    OR              reduce using rule 135 (np_popPar -> .)
    AND             reduce using rule 135 (np_popPar -> .)
    COMMA           reduce using rule 135 (np_popPar -> .)
    R_PAR           reduce using rule 135 (np_popPar -> .)
    R_BREAK         reduce using rule 135 (np_popPar -> .)
    TO              reduce using rule 135 (np_popPar -> .)
    SEMICOLON       reduce using rule 135 (np_popPar -> .)
    DO              reduce using rule 135 (np_popPar -> .)

    np_popPar                      shift and go to state 327

state 301

    (89) boolF -> OR np_addOp . bool
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    bool                           shift and go to state 328
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 302

    (90) boolF -> AND np_addOp . bool
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    bool                           shift and go to state 329
    logical                        shift and go to state 167
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 303

    (93) logicalF -> LESS np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    logical                        shift and go to state 330
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 304

    (94) logicalF -> GREATER np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    logical                        shift and go to state 331
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 305

    (95) logicalF -> LESS_TH np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    logical                        shift and go to state 332
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 306

    (96) logicalF -> GREAT_TH np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    logical                        shift and go to state 333
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 307

    (97) logicalF -> SAME np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    logical                        shift and go to state 334
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 308

    (98) logicalF -> DIF np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    logical                        shift and go to state 335
    ex                             shift and go to state 168
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 309

    (102) exF -> PLUS np_addOp . ex
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    ex                             shift and go to state 336
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 310

    (103) exF -> MINUS np_addOp . ex
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    ex                             shift and go to state 337
    term                           shift and go to state 169
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 311

    (106) termF -> MULT np_addOp . term
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    term                           shift and go to state 338
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 312

    (107) termF -> DIV np_addOp . term
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT np_addConstInt empty
    (117) varcte -> . CTE_FLOAT np_addConstFloat empty
    (118) varcte -> . CTE_CHAR np_addConstChar empty
    (119) varcte -> . CTE_BOOL np_addConstBool empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 162
    PLUS            shift and go to state 172
    MINUS           shift and go to state 174
    CTE_INT         shift and go to state 177
    CTE_FLOAT       shift and go to state 178
    CTE_CHAR        shift and go to state 179
    CTE_BOOL        shift and go to state 180
    VAR             shift and go to state 100
    ID              shift and go to state 161

    term                           shift and go to state 339
    factor                         shift and go to state 170
    factorT                        shift and go to state 171
    factorF                        shift and go to state 173
    varcte                         shift and go to state 175
    var                            shift and go to state 176

state 313

    (59) return -> RETURN L_PAR exp np_addReturn R_PAR empty .

    SEMICOLON       reduce using rule 59 (return -> RETURN L_PAR exp np_addReturn R_PAR empty .)


state 314

    (65) readF -> var np_addRead COMMA readF .

    SEMICOLON       reduce using rule 65 (readF -> var np_addRead COMMA readF .)


state 315

    (66) readF -> var np_addRead R_PAR empty .

    SEMICOLON       reduce using rule 66 (readF -> var np_addRead R_PAR empty .)


state 316

    (70) writeF -> COMMA np_addWrite writeT .

    SEMICOLON       reduce using rule 70 (writeF -> COMMA np_addWrite writeT .)


state 317

    (71) writeF -> R_PAR np_addWrite empty .

    SEMICOLON       reduce using rule 71 (writeF -> R_PAR np_addWrite empty .)


state 318

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN . L_CURPAR statement R_CURPAR ifF

    L_CURPAR        shift and go to state 340


state 319

    (54) arrfunc -> L_BREAK exp COMMA exp R_BREAK . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)
    L_PAR           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 341

state 320

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool . DO L_CURPAR statement R_CURPAR np_endWhile empty

    DO              shift and go to state 342


state 321

    (87) nonconditionalF -> exp TO exp DO . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 343


state 322

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 344

state 323

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    BOOL            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 324

    (78) assigmentF -> EQUAL np_addOp exp np_doAssign empty .

    SEMICOLON       reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)


state 325

    (79) assigmentF -> ope np_addOp exp np_doAssign empty .

    SEMICOLON       reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)


state 326

    (51) void -> ID DOT ID L_PAR param R_PAR empty .

    SEMICOLON       reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR empty .)


state 327

    (109) factor -> L_PAR np_addPar exp R_PAR np_popPar . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 345

state 328

    (89) boolF -> OR np_addOp bool .

    COMMA           reduce using rule 89 (boolF -> OR np_addOp bool .)
    R_PAR           reduce using rule 89 (boolF -> OR np_addOp bool .)
    R_BREAK         reduce using rule 89 (boolF -> OR np_addOp bool .)
    TO              reduce using rule 89 (boolF -> OR np_addOp bool .)
    SEMICOLON       reduce using rule 89 (boolF -> OR np_addOp bool .)
    DO              reduce using rule 89 (boolF -> OR np_addOp bool .)


state 329

    (90) boolF -> AND np_addOp bool .

    COMMA           reduce using rule 90 (boolF -> AND np_addOp bool .)
    R_PAR           reduce using rule 90 (boolF -> AND np_addOp bool .)
    R_BREAK         reduce using rule 90 (boolF -> AND np_addOp bool .)
    TO              reduce using rule 90 (boolF -> AND np_addOp bool .)
    SEMICOLON       reduce using rule 90 (boolF -> AND np_addOp bool .)
    DO              reduce using rule 90 (boolF -> AND np_addOp bool .)


state 330

    (93) logicalF -> LESS np_addOp logical .

    OR              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    AND             reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    COMMA           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_PAR           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_BREAK         reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    TO              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    SEMICOLON       reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    DO              reduce using rule 93 (logicalF -> LESS np_addOp logical .)


state 331

    (94) logicalF -> GREATER np_addOp logical .

    OR              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    AND             reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    COMMA           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_PAR           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_BREAK         reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    TO              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    SEMICOLON       reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    DO              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)


state 332

    (95) logicalF -> LESS_TH np_addOp logical .

    OR              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    AND             reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    COMMA           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_PAR           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_BREAK         reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    TO              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    SEMICOLON       reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    DO              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)


state 333

    (96) logicalF -> GREAT_TH np_addOp logical .

    OR              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    AND             reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    COMMA           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_PAR           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_BREAK         reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    TO              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    SEMICOLON       reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    DO              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)


state 334

    (97) logicalF -> SAME np_addOp logical .

    OR              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    AND             reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    COMMA           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_PAR           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_BREAK         reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    TO              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    SEMICOLON       reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    DO              reduce using rule 97 (logicalF -> SAME np_addOp logical .)


state 335

    (98) logicalF -> DIF np_addOp logical .

    OR              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    AND             reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    COMMA           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_PAR           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_BREAK         reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    TO              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    SEMICOLON       reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    DO              reduce using rule 98 (logicalF -> DIF np_addOp logical .)


state 336

    (102) exF -> PLUS np_addOp ex .

    LESS            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    GREATER         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    LESS_TH         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    GREAT_TH        reduce using rule 102 (exF -> PLUS np_addOp ex .)
    SAME            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    DIF             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    OR              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    AND             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    COMMA           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_PAR           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_BREAK         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    TO              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    SEMICOLON       reduce using rule 102 (exF -> PLUS np_addOp ex .)
    DO              reduce using rule 102 (exF -> PLUS np_addOp ex .)


state 337

    (103) exF -> MINUS np_addOp ex .

    LESS            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    GREATER         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    LESS_TH         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    GREAT_TH        reduce using rule 103 (exF -> MINUS np_addOp ex .)
    SAME            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    DIF             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    OR              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    AND             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    COMMA           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_PAR           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_BREAK         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    TO              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    SEMICOLON       reduce using rule 103 (exF -> MINUS np_addOp ex .)
    DO              reduce using rule 103 (exF -> MINUS np_addOp ex .)


state 338

    (106) termF -> MULT np_addOp term .

    PLUS            reduce using rule 106 (termF -> MULT np_addOp term .)
    MINUS           reduce using rule 106 (termF -> MULT np_addOp term .)
    LESS            reduce using rule 106 (termF -> MULT np_addOp term .)
    GREATER         reduce using rule 106 (termF -> MULT np_addOp term .)
    LESS_TH         reduce using rule 106 (termF -> MULT np_addOp term .)
    GREAT_TH        reduce using rule 106 (termF -> MULT np_addOp term .)
    SAME            reduce using rule 106 (termF -> MULT np_addOp term .)
    DIF             reduce using rule 106 (termF -> MULT np_addOp term .)
    OR              reduce using rule 106 (termF -> MULT np_addOp term .)
    AND             reduce using rule 106 (termF -> MULT np_addOp term .)
    COMMA           reduce using rule 106 (termF -> MULT np_addOp term .)
    R_PAR           reduce using rule 106 (termF -> MULT np_addOp term .)
    R_BREAK         reduce using rule 106 (termF -> MULT np_addOp term .)
    TO              reduce using rule 106 (termF -> MULT np_addOp term .)
    SEMICOLON       reduce using rule 106 (termF -> MULT np_addOp term .)
    DO              reduce using rule 106 (termF -> MULT np_addOp term .)


state 339

    (107) termF -> DIV np_addOp term .

    PLUS            reduce using rule 107 (termF -> DIV np_addOp term .)
    MINUS           reduce using rule 107 (termF -> DIV np_addOp term .)
    LESS            reduce using rule 107 (termF -> DIV np_addOp term .)
    GREATER         reduce using rule 107 (termF -> DIV np_addOp term .)
    LESS_TH         reduce using rule 107 (termF -> DIV np_addOp term .)
    GREAT_TH        reduce using rule 107 (termF -> DIV np_addOp term .)
    SAME            reduce using rule 107 (termF -> DIV np_addOp term .)
    DIF             reduce using rule 107 (termF -> DIV np_addOp term .)
    OR              reduce using rule 107 (termF -> DIV np_addOp term .)
    AND             reduce using rule 107 (termF -> DIV np_addOp term .)
    COMMA           reduce using rule 107 (termF -> DIV np_addOp term .)
    R_PAR           reduce using rule 107 (termF -> DIV np_addOp term .)
    R_BREAK         reduce using rule 107 (termF -> DIV np_addOp term .)
    TO              reduce using rule 107 (termF -> DIV np_addOp term .)
    SEMICOLON       reduce using rule 107 (termF -> DIV np_addOp term .)
    DO              reduce using rule 107 (termF -> DIV np_addOp term .)


state 340

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR . statement R_CURPAR ifF
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 346
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 341

    (54) arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .

    EQUAL           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MIN_EQ          reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT_EQ         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV_EQ          reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MINUS           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREATER         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS_TH         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREAT_TH        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SAME            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIF             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    OR              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    AND             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    COMMA           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_PAR           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_BREAK         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    TO              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SEMICOLON       reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DO              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    L_PAR           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_INT         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_BOOL        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    VAR             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    ID              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)


state 342

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO . L_CURPAR statement R_CURPAR np_endWhile empty

    L_CURPAR        shift and go to state 347


state 343

    (87) nonconditionalF -> exp TO exp DO L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 348
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 344

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    BOOL            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 345

    (109) factor -> L_PAR np_addPar exp R_PAR np_popPar empty .

    MULT            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIV             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    PLUS            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    MINUS           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREATER         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS_TH         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREAT_TH        reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SAME            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIF             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    OR              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    AND             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    COMMA           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_PAR           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_BREAK         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    TO              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SEMICOLON       reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DO              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)


state 346

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement . R_CURPAR ifF

    R_CURPAR        shift and go to state 349


state 347

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR . statement R_CURPAR np_endWhile empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 350
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 348

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 351


state 349

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR . ifF
    (75) ifF -> . ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty
    (76) ifF -> . np_endIf empty
    (145) np_endIf -> .

    ELSE            shift and go to state 353
    ID              reduce using rule 145 (np_endIf -> .)
    RETURN          reduce using rule 145 (np_endIf -> .)
    READ            reduce using rule 145 (np_endIf -> .)
    WRITE           reduce using rule 145 (np_endIf -> .)
    IF              reduce using rule 145 (np_endIf -> .)
    VAR             reduce using rule 145 (np_endIf -> .)
    WHILE           reduce using rule 145 (np_endIf -> .)
    FROM            reduce using rule 145 (np_endIf -> .)
    R_CURPAR        reduce using rule 145 (np_endIf -> .)

    ifF                            shift and go to state 352
    np_endIf                       shift and go to state 354

state 350

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement . R_CURPAR np_endWhile empty

    R_CURPAR        shift and go to state 355


state 351

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 356

state 352

    (74) if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .

    ID              reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    RETURN          reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    READ            reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    WRITE           reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    IF              reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    VAR             reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    WHILE           reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    FROM            reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)
    R_CURPAR        reduce using rule 74 (if -> IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF .)


state 353

    (75) ifF -> ELSE . np_else L_CURPAR statement R_CURPAR np_endIf empty
    (146) np_else -> .

    L_CURPAR        reduce using rule 146 (np_else -> .)

    np_else                        shift and go to state 357

state 354

    (76) ifF -> np_endIf . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 358

state 355

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR . np_endWhile empty
    (148) np_endWhile -> .

    ID              reduce using rule 148 (np_endWhile -> .)
    RETURN          reduce using rule 148 (np_endWhile -> .)
    READ            reduce using rule 148 (np_endWhile -> .)
    WRITE           reduce using rule 148 (np_endWhile -> .)
    IF              reduce using rule 148 (np_endWhile -> .)
    VAR             reduce using rule 148 (np_endWhile -> .)
    WHILE           reduce using rule 148 (np_endWhile -> .)
    FROM            reduce using rule 148 (np_endWhile -> .)
    R_CURPAR        reduce using rule 148 (np_endWhile -> .)

    np_endWhile                    shift and go to state 359

state 356

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty .

    ID              reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty .)
    RETURN          reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty .)
    READ            reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty .)
    WRITE           reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty .)
    IF              reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty .)
    VAR             reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty .)
    WHILE           reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty .)
    FROM            reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement R_CURPAR empty .)


state 357

    (75) ifF -> ELSE np_else . L_CURPAR statement R_CURPAR np_endIf empty

    L_CURPAR        shift and go to state 360


state 358

    (76) ifF -> np_endIf empty .

    ID              reduce using rule 76 (ifF -> np_endIf empty .)
    RETURN          reduce using rule 76 (ifF -> np_endIf empty .)
    READ            reduce using rule 76 (ifF -> np_endIf empty .)
    WRITE           reduce using rule 76 (ifF -> np_endIf empty .)
    IF              reduce using rule 76 (ifF -> np_endIf empty .)
    VAR             reduce using rule 76 (ifF -> np_endIf empty .)
    WHILE           reduce using rule 76 (ifF -> np_endIf empty .)
    FROM            reduce using rule 76 (ifF -> np_endIf empty .)
    R_CURPAR        reduce using rule 76 (ifF -> np_endIf empty .)


state 359

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 361

state 360

    (75) ifF -> ELSE np_else L_CURPAR . statement R_CURPAR np_endIf empty
    (42) statement -> . assigment SEMICOLON statementF
    (43) statement -> . void SEMICOLON statementF
    (44) statement -> . return SEMICOLON statementF
    (45) statement -> . read SEMICOLON statementF
    (46) statement -> . write SEMICOLON statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR empty
    (52) void -> . ID L_PAR param R_PAR empty
    (53) void -> . ID L_PAR R_PAR empty
    (59) return -> . RETURN L_PAR exp np_addReturn R_PAR empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp np_checkBool R_PAR THEN L_CURPAR statement R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 93
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    VAR             shift and go to state 100
    WHILE           shift and go to state 101
    FROM            shift and go to state 102

    statement                      shift and go to state 362
    assigment                      shift and go to state 85
    void                           shift and go to state 86
    return                         shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    if                             shift and go to state 90
    repeat                         shift and go to state 91
    var                            shift and go to state 92
    conditional                    shift and go to state 98
    nonconditional                 shift and go to state 99

state 361

    (84) conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .

    ID              reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    RETURN          reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    READ            reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    WRITE           reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    IF              reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    VAR             reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    WHILE           reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    FROM            reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)
    R_CURPAR        reduce using rule 84 (conditional -> WHILE np_addWhile L_PAR exp R_PAR np_checkBool DO L_CURPAR statement R_CURPAR np_endWhile empty .)


state 362

    (75) ifF -> ELSE np_else L_CURPAR statement . R_CURPAR np_endIf empty

    R_CURPAR        shift and go to state 363


state 363

    (75) ifF -> ELSE np_else L_CURPAR statement R_CURPAR . np_endIf empty
    (145) np_endIf -> .

    ID              reduce using rule 145 (np_endIf -> .)
    RETURN          reduce using rule 145 (np_endIf -> .)
    READ            reduce using rule 145 (np_endIf -> .)
    WRITE           reduce using rule 145 (np_endIf -> .)
    IF              reduce using rule 145 (np_endIf -> .)
    VAR             reduce using rule 145 (np_endIf -> .)
    WHILE           reduce using rule 145 (np_endIf -> .)
    FROM            reduce using rule 145 (np_endIf -> .)
    R_CURPAR        reduce using rule 145 (np_endIf -> .)

    np_endIf                       shift and go to state 364

state 364

    (75) ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 365

state 365

    (75) ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .

    ID              reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    RETURN          reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    READ            reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    WRITE           reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    IF              reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    VAR             reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    WHILE           reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    FROM            reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)
    R_CURPAR        reduce using rule 75 (ifF -> ELSE np_else L_CURPAR statement R_CURPAR np_endIf empty .)

