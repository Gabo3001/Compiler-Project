Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID np_getcurrFunc SEMICOLON programT
Rule 2     programT -> class programT
Rule 3     programT -> vars programF
Rule 4     programT -> programF
Rule 5     programF -> func programF
Rule 6     programF -> main empty
Rule 7     class -> CLASS ID classT
Rule 8     classT -> LESS INHERIT ID GREATER classF
Rule 9     classT -> classF
Rule 10    classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty
Rule 11    vars -> VARS dec np_AddFunc empty
Rule 12    dec -> VAR arr np_getDecArr decF
Rule 13    dec -> VAR np_getDec decF
Rule 14    decF -> COMMA dec
Rule 15    decF -> COLON type np_getVarType SEMICOLON np_getDec dec
Rule 16    decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty
Rule 17    type -> INT empty
Rule 18    type -> FLOAT empty
Rule 19    type -> CHAR empty
Rule 20    type -> ID empty
Rule 21    arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
Rule 22    arr -> L_BREAK CTE_INT R_BREAK empty
Rule 23    func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
Rule 24    funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 25    funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 26    typeFunc -> INT empty
Rule 27    typeFunc -> FLOAT empty
Rule 28    typeFunc -> CHAR empty
Rule 29    typeFunc -> ID empty
Rule 30    typeFunc -> VOID empty
Rule 31    parameter -> VAR COLON typepar SEMICOLON parameterF
Rule 32    parameterF -> parameter
Rule 33    parameterF -> empty
Rule 34    typepar -> INT empty
Rule 35    typepar -> FLOAT empty
Rule 36    typepar -> CHAR empty
Rule 37    typepar -> ID empty
Rule 38    main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
Rule 39    statement -> assigment statementF
Rule 40    statement -> void statementF
Rule 41    statement -> return statementF
Rule 42    statement -> read statementF
Rule 43    statement -> write statementF
Rule 44    statement -> if statementF
Rule 45    statement -> repeat statementF
Rule 46    statementF -> statement
Rule 47    statementF -> empty
Rule 48    void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty
Rule 49    void -> ID L_PAR param R_PAR SEMICOLON empty
Rule 50    void -> ID L_PAR R_PAR SEMICOLON empty
Rule 51    arrfunc -> L_BREAK exp COMMA exp R_BREAK empty
Rule 52    arrfunc -> L_BREAK exp R_BREAK empty
Rule 53    param -> exp paramF
Rule 54    paramF -> COMMA param
Rule 55    paramF -> empty
Rule 56    return -> RETURN L_PAR exp R_PAR SEMICOLON empty
Rule 57    var -> VAR varF
Rule 58    var -> ID DOT VAR varF
Rule 59    varF -> arrfunc empty
Rule 60    varF -> empty
Rule 61    read -> READ L_PAR readF
Rule 62    readF -> var COMMA readF
Rule 63    readF -> var R_PAR SEMICOLON empty
Rule 64    write -> WRITE L_PAR writeT
Rule 65    writeT -> CTE_CHAR writeF
Rule 66    writeT -> exp writeF
Rule 67    writeF -> COMMA writeT
Rule 68    writeF -> R_PAR SEMICOLON empty
Rule 69    repeat -> conditional empty
Rule 70    repeat -> nonconditional empty
Rule 71    if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
Rule 72    ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 73    ifF -> empty
Rule 74    assigment -> var np_addId assigmentF
Rule 75    assigmentF -> EQUAL np_addOp exp np_doAssign empty
Rule 76    assigmentF -> ope np_addOp exp np_doAssign empty
Rule 77    ope -> PLUS_EQ empty
Rule 78    ope -> MIN_EQ empty
Rule 79    ope -> MULT_EQ empty
Rule 80    ope -> DIV_EQ empty
Rule 81    conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 82    nonconditional -> FROM VAR arrfunc nonconditionalF
Rule 83    nonconditional -> FROM VAR nonconditionalF
Rule 84    nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 85    bool -> logical np_addBool boolF
Rule 86    boolF -> OR np_addOp bool
Rule 87    boolF -> AND np_addOp bool
Rule 88    boolF -> empty
Rule 89    logical -> ex np_addLogical logicalF
Rule 90    logicalF -> LESS np_addOp logical
Rule 91    logicalF -> GREATER np_addOp logical
Rule 92    logicalF -> LESS_TH np_addOp logical
Rule 93    logicalF -> GREAT_TH np_addOp logical
Rule 94    logicalF -> SAME np_addOp logical
Rule 95    logicalF -> DIF np_addOp logical
Rule 96    logicalF -> empty
Rule 97    exp -> bool empty
Rule 98    ex -> term np_addEx exF
Rule 99    exF -> PLUS np_addOp ex
Rule 100   exF -> MINUS np_addOp ex
Rule 101   exF -> empty
Rule 102   term -> factor np_addTerm termF
Rule 103   termF -> MULT np_addOp term
Rule 104   termF -> DIV np_addOp term
Rule 105   termF -> empty
Rule 106   factor -> L_PAR np_addPar exp R_PAR np_popPar empty
Rule 107   factor -> factorT
Rule 108   factorT -> PLUS factorF
Rule 109   factorT -> MINUS factorF
Rule 110   factorT -> factorF
Rule 111   factorF -> varcte empty
Rule 112   varcte -> var np_addId empty
Rule 113   varcte -> CTE_INT empty
Rule 114   varcte -> CTE_FLOAT empty
Rule 115   varcte -> CTE_CHAR empty
Rule 116   empty -> <empty>
Rule 117   np_getcurrFunc -> <empty>
Rule 118   np_getDec -> <empty>
Rule 119   np_getDecArr -> <empty>
Rule 120   np_getVarType -> <empty>
Rule 121   np_AddFunc -> <empty>
Rule 122   np_addToDic -> <empty>
Rule 123   np_addId -> <empty>
Rule 124   np_addOp -> <empty>
Rule 125   np_addPar -> <empty>
Rule 126   np_popPar -> <empty>
Rule 127   np_addTerm -> <empty>
Rule 128   np_addEx -> <empty>
Rule 129   np_addLogical -> <empty>
Rule 130   np_addBool -> <empty>
Rule 131   np_doAssign -> <empty>

Terminals, with rules where they appear

AND                  : 87
ATTRIBUTES           : 10
CHAR                 : 19 28 36
CLASS                : 7
COLON                : 15 16 31
COMMA                : 14 21 51 54 62 67
CTE_CHAR             : 65 115
CTE_FLOAT            : 114
CTE_INT              : 21 21 22 113
DIF                  : 95
DIV                  : 104
DIV_EQ               : 80
DO                   : 81 84
DOT                  : 48 58
ELSE                 : 72
EQUAL                : 75
FLOAT                : 18 27 35
FROM                 : 82 83
FUNCTION             : 23
GREATER              : 8 91
GREAT_TH             : 93
ID                   : 1 7 8 20 23 29 37 48 48 49 50 58
IF                   : 71
INHERIT              : 8
INT                  : 17 26 34
LESS                 : 8 90
LESS_TH              : 92
L_BREAK              : 21 22 51 52
L_CURPAR             : 10 24 25 38 71 72 81 84
L_PAR                : 23 38 48 49 50 56 61 64 71 81 106
MAIN                 : 38
METHODS              : 10
MINUS                : 100 109
MIN_EQ               : 78
MULT                 : 103
MULT_EQ              : 79
OR                   : 86
PLUS                 : 99 108
PLUS_EQ              : 77
PROGRAM              : 1
READ                 : 61
RETURN               : 56
R_BREAK              : 21 22 51 52
R_CURPAR             : 10 24 25 38 71 72 81 84
R_PAR                : 24 25 38 48 49 50 56 63 68 71 81 106
SAME                 : 94
SEMICOLON            : 1 10 10 15 16 24 25 31 48 49 50 56 63 68 71 72 81 84
THEN                 : 71
TO                   : 84
VAR                  : 12 13 31 57 58 82 83
VARS                 : 11
VOID                 : 30
WHILE                : 81
WRITE                : 64
error                : 

Nonterminals, with rules where they appear

arr                  : 12
arrfunc              : 59 82
assigment            : 39
assigmentF           : 74
bool                 : 86 87 97
boolF                : 85
class                : 2
classF               : 8 9
classT               : 7
conditional          : 69
dec                  : 10 11 14 15 24 25
decF                 : 12 13
empty                : 6 10 11 16 17 18 19 20 21 22 24 25 26 27 28 29 30 33 34 35 36 37 38 47 48 49 50 51 52 55 56 59 60 63 68 69 70 72 73 75 76 77 78 79 80 81 84 88 96 97 101 105 106 111 112 113 114 115
ex                   : 89 99 100
exF                  : 98
exp                  : 51 51 52 53 56 66 71 75 76 81 84 84 106
factor               : 102
factorF              : 108 109 110
factorT              : 107
func                 : 5 10
funcF                : 23
if                   : 44
ifF                  : 71
logical              : 85 90 91 92 93 94 95
logicalF             : 89
main                 : 6
nonconditional       : 70
nonconditionalF      : 82 83
np_AddFunc           : 11 23
np_addBool           : 85
np_addEx             : 98
np_addId             : 74 112
np_addLogical        : 89
np_addOp             : 75 76 86 87 90 91 92 93 94 95 99 100 103 104
np_addPar            : 106
np_addTerm           : 102
np_addToDic          : 16
np_doAssign          : 75 76
np_getDec            : 13 15 16
np_getDecArr         : 12
np_getVarType        : 15 16
np_getcurrFunc       : 1 23
np_popPar            : 106
ope                  : 76
param                : 48 49 54
paramF               : 53
parameter            : 24 32
parameterF           : 31
program              : 0
programF             : 3 4 5
programT             : 1 2
read                 : 42
readF                : 61 62
repeat               : 45
return               : 41
statement            : 24 25 38 46 71 72 81 84
statementF           : 39 40 41 42 43 44 45
term                 : 98 103 104
termF                : 102
type                 : 15 16
typeFunc             : 23
typepar              : 31
var                  : 62 63 74 112
varF                 : 57 58
varcte               : 111
vars                 : 3
void                 : 40
write                : 43
writeF               : 65 66
writeT               : 64 67

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID np_getcurrFunc SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID np_getcurrFunc SEMICOLON programT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . np_getcurrFunc SEMICOLON programT
    (117) np_getcurrFunc -> .

    SEMICOLON       reduce using rule 117 (np_getcurrFunc -> .)

    np_getcurrFunc                 shift and go to state 4

state 4

    (1) program -> PROGRAM ID np_getcurrFunc . SEMICOLON programT

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID np_getcurrFunc SEMICOLON . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec np_AddFunc empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    CLASS           shift and go to state 11
    VARS            shift and go to state 12
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    ID              shift and go to state 6
    VOID            shift and go to state 20

    programT                       shift and go to state 7
    class                          shift and go to state 8
    vars                           shift and go to state 9
    programF                       shift and go to state 10
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 6

    (29) typeFunc -> ID . empty
    (116) empty -> .

    FUNCTION        reduce using rule 116 (empty -> .)

    empty                          shift and go to state 21

state 7

    (1) program -> PROGRAM ID np_getcurrFunc SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM ID np_getcurrFunc SEMICOLON programT .)


state 8

    (2) programT -> class . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec np_AddFunc empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    CLASS           shift and go to state 11
    VARS            shift and go to state 12
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    ID              shift and go to state 6
    VOID            shift and go to state 20

    class                          shift and go to state 8
    programT                       shift and go to state 22
    vars                           shift and go to state 9
    programF                       shift and go to state 10
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 9

    (3) programT -> vars . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    ID              shift and go to state 6
    VOID            shift and go to state 20

    programF                       shift and go to state 23
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 10

    (4) programT -> programF .

    $end            reduce using rule 4 (programT -> programF .)


state 11

    (7) class -> CLASS . ID classT

    ID              shift and go to state 24


state 12

    (11) vars -> VARS . dec np_AddFunc empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 26

    dec                            shift and go to state 25

state 13

    (5) programF -> func . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (23) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (38) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    ID              shift and go to state 6
    VOID            shift and go to state 20

    func                           shift and go to state 13
    programF                       shift and go to state 27
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 14

    (6) programF -> main . empty
    (116) empty -> .

    $end            reduce using rule 116 (empty -> .)

    empty                          shift and go to state 28

state 15

    (23) func -> typeFunc . FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF

    FUNCTION        shift and go to state 29


state 16

    (38) main -> MAIN . L_PAR R_PAR L_CURPAR statement R_CURPAR empty

    L_PAR           shift and go to state 30


state 17

    (26) typeFunc -> INT . empty
    (116) empty -> .

    FUNCTION        reduce using rule 116 (empty -> .)

    empty                          shift and go to state 31

state 18

    (27) typeFunc -> FLOAT . empty
    (116) empty -> .

    FUNCTION        reduce using rule 116 (empty -> .)

    empty                          shift and go to state 32

state 19

    (28) typeFunc -> CHAR . empty
    (116) empty -> .

    FUNCTION        reduce using rule 116 (empty -> .)

    empty                          shift and go to state 33

state 20

    (30) typeFunc -> VOID . empty
    (116) empty -> .

    FUNCTION        reduce using rule 116 (empty -> .)

    empty                          shift and go to state 34

state 21

    (29) typeFunc -> ID empty .

    FUNCTION        reduce using rule 29 (typeFunc -> ID empty .)


state 22

    (2) programT -> class programT .

    $end            reduce using rule 2 (programT -> class programT .)


state 23

    (3) programT -> vars programF .

    $end            reduce using rule 3 (programT -> vars programF .)


state 24

    (7) class -> CLASS ID . classT
    (8) classT -> . LESS INHERIT ID GREATER classF
    (9) classT -> . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    LESS            shift and go to state 36
    SEMICOLON       shift and go to state 38

    classT                         shift and go to state 35
    classF                         shift and go to state 37

state 25

    (11) vars -> VARS dec . np_AddFunc empty
    (121) np_AddFunc -> .

    MAIN            reduce using rule 121 (np_AddFunc -> .)
    INT             reduce using rule 121 (np_AddFunc -> .)
    FLOAT           reduce using rule 121 (np_AddFunc -> .)
    CHAR            reduce using rule 121 (np_AddFunc -> .)
    ID              reduce using rule 121 (np_AddFunc -> .)
    VOID            reduce using rule 121 (np_AddFunc -> .)

    np_AddFunc                     shift and go to state 39

state 26

    (12) dec -> VAR . arr np_getDecArr decF
    (13) dec -> VAR . np_getDec decF
    (21) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (22) arr -> . L_BREAK CTE_INT R_BREAK empty
    (118) np_getDec -> .

    L_BREAK         shift and go to state 42
    COMMA           reduce using rule 118 (np_getDec -> .)
    COLON           reduce using rule 118 (np_getDec -> .)

    arr                            shift and go to state 40
    np_getDec                      shift and go to state 41

state 27

    (5) programF -> func programF .

    $end            reduce using rule 5 (programF -> func programF .)


state 28

    (6) programF -> main empty .

    $end            reduce using rule 6 (programF -> main empty .)


state 29

    (23) func -> typeFunc FUNCTION . ID np_getcurrFunc np_AddFunc L_PAR funcF

    ID              shift and go to state 43


state 30

    (38) main -> MAIN L_PAR . R_PAR L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 44


state 31

    (26) typeFunc -> INT empty .

    FUNCTION        reduce using rule 26 (typeFunc -> INT empty .)


state 32

    (27) typeFunc -> FLOAT empty .

    FUNCTION        reduce using rule 27 (typeFunc -> FLOAT empty .)


state 33

    (28) typeFunc -> CHAR empty .

    FUNCTION        reduce using rule 28 (typeFunc -> CHAR empty .)


state 34

    (30) typeFunc -> VOID empty .

    FUNCTION        reduce using rule 30 (typeFunc -> VOID empty .)


state 35

    (7) class -> CLASS ID classT .

    CLASS           reduce using rule 7 (class -> CLASS ID classT .)
    VARS            reduce using rule 7 (class -> CLASS ID classT .)
    MAIN            reduce using rule 7 (class -> CLASS ID classT .)
    INT             reduce using rule 7 (class -> CLASS ID classT .)
    FLOAT           reduce using rule 7 (class -> CLASS ID classT .)
    CHAR            reduce using rule 7 (class -> CLASS ID classT .)
    ID              reduce using rule 7 (class -> CLASS ID classT .)
    VOID            reduce using rule 7 (class -> CLASS ID classT .)


state 36

    (8) classT -> LESS . INHERIT ID GREATER classF

    INHERIT         shift and go to state 45


state 37

    (9) classT -> classF .

    CLASS           reduce using rule 9 (classT -> classF .)
    VARS            reduce using rule 9 (classT -> classF .)
    MAIN            reduce using rule 9 (classT -> classF .)
    INT             reduce using rule 9 (classT -> classF .)
    FLOAT           reduce using rule 9 (classT -> classF .)
    CHAR            reduce using rule 9 (classT -> classF .)
    ID              reduce using rule 9 (classT -> classF .)
    VOID            reduce using rule 9 (classT -> classF .)


state 38

    (10) classF -> SEMICOLON . L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    L_CURPAR        shift and go to state 46


state 39

    (11) vars -> VARS dec np_AddFunc . empty
    (116) empty -> .

    MAIN            reduce using rule 116 (empty -> .)
    INT             reduce using rule 116 (empty -> .)
    FLOAT           reduce using rule 116 (empty -> .)
    CHAR            reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    VOID            reduce using rule 116 (empty -> .)

    empty                          shift and go to state 47

state 40

    (12) dec -> VAR arr . np_getDecArr decF
    (119) np_getDecArr -> .

    COMMA           reduce using rule 119 (np_getDecArr -> .)
    COLON           reduce using rule 119 (np_getDecArr -> .)

    np_getDecArr                   shift and go to state 48

state 41

    (13) dec -> VAR np_getDec . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 50
    COLON           shift and go to state 51

    decF                           shift and go to state 49

state 42

    (21) arr -> L_BREAK . CTE_INT COMMA CTE_INT R_BREAK empty
    (22) arr -> L_BREAK . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 52


state 43

    (23) func -> typeFunc FUNCTION ID . np_getcurrFunc np_AddFunc L_PAR funcF
    (117) np_getcurrFunc -> .

    L_PAR           reduce using rule 117 (np_getcurrFunc -> .)

    np_getcurrFunc                 shift and go to state 53

state 44

    (38) main -> MAIN L_PAR R_PAR . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 54


state 45

    (8) classT -> LESS INHERIT . ID GREATER classF

    ID              shift and go to state 55


state 46

    (10) classF -> SEMICOLON L_CURPAR . ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    ATTRIBUTES      shift and go to state 56


state 47

    (11) vars -> VARS dec np_AddFunc empty .

    MAIN            reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    INT             reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    FLOAT           reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    CHAR            reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    ID              reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    VOID            reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)


state 48

    (12) dec -> VAR arr np_getDecArr . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 50
    COLON           shift and go to state 51

    decF                           shift and go to state 57

state 49

    (13) dec -> VAR np_getDec decF .

    MAIN            reduce using rule 13 (dec -> VAR np_getDec decF .)
    INT             reduce using rule 13 (dec -> VAR np_getDec decF .)
    FLOAT           reduce using rule 13 (dec -> VAR np_getDec decF .)
    CHAR            reduce using rule 13 (dec -> VAR np_getDec decF .)
    ID              reduce using rule 13 (dec -> VAR np_getDec decF .)
    VOID            reduce using rule 13 (dec -> VAR np_getDec decF .)
    METHODS         reduce using rule 13 (dec -> VAR np_getDec decF .)
    L_CURPAR        reduce using rule 13 (dec -> VAR np_getDec decF .)


state 50

    (14) decF -> COMMA . dec
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 26

    dec                            shift and go to state 58

state 51

    (15) decF -> COLON . type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON . type np_getVarType SEMICOLON np_getDec np_addToDic empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . ID empty

    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    CHAR            shift and go to state 62
    ID              shift and go to state 63

    type                           shift and go to state 59

state 52

    (21) arr -> L_BREAK CTE_INT . COMMA CTE_INT R_BREAK empty
    (22) arr -> L_BREAK CTE_INT . R_BREAK empty

    COMMA           shift and go to state 64
    R_BREAK         shift and go to state 65


state 53

    (23) func -> typeFunc FUNCTION ID np_getcurrFunc . np_AddFunc L_PAR funcF
    (121) np_AddFunc -> .

    L_PAR           reduce using rule 121 (np_AddFunc -> .)

    np_AddFunc                     shift and go to state 66

state 54

    (38) main -> MAIN L_PAR R_PAR L_CURPAR . statement R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 67
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 55

    (8) classT -> LESS INHERIT ID . GREATER classF

    GREATER         shift and go to state 86


state 56

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES . dec METHODS func R_CURPAR SEMICOLON empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 26

    dec                            shift and go to state 87

state 57

    (12) dec -> VAR arr np_getDecArr decF .

    MAIN            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    INT             reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    FLOAT           reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    CHAR            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    ID              reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    VOID            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    METHODS         reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    L_CURPAR        reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)


state 58

    (14) decF -> COMMA dec .

    MAIN            reduce using rule 14 (decF -> COMMA dec .)
    INT             reduce using rule 14 (decF -> COMMA dec .)
    FLOAT           reduce using rule 14 (decF -> COMMA dec .)
    CHAR            reduce using rule 14 (decF -> COMMA dec .)
    ID              reduce using rule 14 (decF -> COMMA dec .)
    VOID            reduce using rule 14 (decF -> COMMA dec .)
    METHODS         reduce using rule 14 (decF -> COMMA dec .)
    L_CURPAR        reduce using rule 14 (decF -> COMMA dec .)


state 59

    (15) decF -> COLON type . np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON type . np_getVarType SEMICOLON np_getDec np_addToDic empty
    (120) np_getVarType -> .

    SEMICOLON       reduce using rule 120 (np_getVarType -> .)

    np_getVarType                  shift and go to state 88

state 60

    (17) type -> INT . empty
    (116) empty -> .

    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 89

state 61

    (18) type -> FLOAT . empty
    (116) empty -> .

    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 90

state 62

    (19) type -> CHAR . empty
    (116) empty -> .

    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 91

state 63

    (20) type -> ID . empty
    (116) empty -> .

    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 92

state 64

    (21) arr -> L_BREAK CTE_INT COMMA . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 93


state 65

    (22) arr -> L_BREAK CTE_INT R_BREAK . empty
    (116) empty -> .

    COMMA           reduce using rule 116 (empty -> .)
    COLON           reduce using rule 116 (empty -> .)

    empty                          shift and go to state 94

state 66

    (23) func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc . L_PAR funcF

    L_PAR           shift and go to state 95


state 67

    (38) main -> MAIN L_PAR R_PAR L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 96


state 68

    (39) statement -> assigment . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (116) empty -> .
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    assigment                      shift and go to state 68
    statementF                     shift and go to state 97
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 69

    (40) statement -> void . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (116) empty -> .
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    void                           shift and go to state 69
    statementF                     shift and go to state 100
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 70

    (41) statement -> return . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (116) empty -> .
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    return                         shift and go to state 70
    statementF                     shift and go to state 101
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 71

    (42) statement -> read . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (116) empty -> .
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    read                           shift and go to state 71
    statementF                     shift and go to state 102
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 72

    (43) statement -> write . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (116) empty -> .
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    write                          shift and go to state 72
    statementF                     shift and go to state 103
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 73

    (44) statement -> if . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (116) empty -> .
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    if                             shift and go to state 73
    statementF                     shift and go to state 104
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 74

    (45) statement -> repeat . statementF
    (46) statementF -> . statement
    (47) statementF -> . empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (116) empty -> .
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    repeat                         shift and go to state 74
    statementF                     shift and go to state 105
    statement                      shift and go to state 98
    empty                          shift and go to state 99
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 75

    (74) assigment -> var . np_addId assigmentF
    (123) np_addId -> .

    EQUAL           reduce using rule 123 (np_addId -> .)
    PLUS_EQ         reduce using rule 123 (np_addId -> .)
    MIN_EQ          reduce using rule 123 (np_addId -> .)
    MULT_EQ         reduce using rule 123 (np_addId -> .)
    DIV_EQ          reduce using rule 123 (np_addId -> .)

    np_addId                       shift and go to state 106

state 76

    (48) void -> ID . DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> ID . L_PAR param R_PAR SEMICOLON empty
    (50) void -> ID . L_PAR R_PAR SEMICOLON empty
    (58) var -> ID . DOT VAR varF

    DOT             shift and go to state 107
    L_PAR           shift and go to state 108


state 77

    (56) return -> RETURN . L_PAR exp R_PAR SEMICOLON empty

    L_PAR           shift and go to state 109


state 78

    (61) read -> READ . L_PAR readF

    L_PAR           shift and go to state 110


state 79

    (64) write -> WRITE . L_PAR writeT

    L_PAR           shift and go to state 111


state 80

    (71) if -> IF . L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_PAR           shift and go to state 112


state 81

    (69) repeat -> conditional . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 113

state 82

    (70) repeat -> nonconditional . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 114

state 83

    (57) var -> VAR . varF
    (59) varF -> . arrfunc empty
    (60) varF -> . empty
    (51) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (52) arrfunc -> . L_BREAK exp R_BREAK empty
    (116) empty -> .

    L_BREAK         shift and go to state 118
    EQUAL           reduce using rule 116 (empty -> .)
    PLUS_EQ         reduce using rule 116 (empty -> .)
    MIN_EQ          reduce using rule 116 (empty -> .)
    MULT_EQ         reduce using rule 116 (empty -> .)
    DIV_EQ          reduce using rule 116 (empty -> .)
    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    varF                           shift and go to state 115
    arrfunc                        shift and go to state 116
    empty                          shift and go to state 117

state 84

    (81) conditional -> WHILE . L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    L_PAR           shift and go to state 119


state 85

    (82) nonconditional -> FROM . VAR arrfunc nonconditionalF
    (83) nonconditional -> FROM . VAR nonconditionalF

    VAR             shift and go to state 120


state 86

    (8) classT -> LESS INHERIT ID GREATER . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    SEMICOLON       shift and go to state 38

    classF                         shift and go to state 121

state 87

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec . METHODS func R_CURPAR SEMICOLON empty

    METHODS         shift and go to state 122


state 88

    (15) decF -> COLON type np_getVarType . SEMICOLON np_getDec dec
    (16) decF -> COLON type np_getVarType . SEMICOLON np_getDec np_addToDic empty

    SEMICOLON       shift and go to state 123


state 89

    (17) type -> INT empty .

    SEMICOLON       reduce using rule 17 (type -> INT empty .)


state 90

    (18) type -> FLOAT empty .

    SEMICOLON       reduce using rule 18 (type -> FLOAT empty .)


state 91

    (19) type -> CHAR empty .

    SEMICOLON       reduce using rule 19 (type -> CHAR empty .)


state 92

    (20) type -> ID empty .

    SEMICOLON       reduce using rule 20 (type -> ID empty .)


state 93

    (21) arr -> L_BREAK CTE_INT COMMA CTE_INT . R_BREAK empty

    R_BREAK         shift and go to state 124


state 94

    (22) arr -> L_BREAK CTE_INT R_BREAK empty .

    COMMA           reduce using rule 22 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    COLON           reduce using rule 22 (arr -> L_BREAK CTE_INT R_BREAK empty .)


state 95

    (23) func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR . funcF
    (24) funcF -> . parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (25) funcF -> . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (31) parameter -> . VAR COLON typepar SEMICOLON parameterF

    R_PAR           shift and go to state 127
    VAR             shift and go to state 128

    funcF                          shift and go to state 125
    parameter                      shift and go to state 126

state 96

    (38) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR . empty
    (116) empty -> .

    $end            reduce using rule 116 (empty -> .)

    empty                          shift and go to state 129

state 97

    (39) statement -> assigment statementF .

    R_CURPAR        reduce using rule 39 (statement -> assigment statementF .)
    SEMICOLON       reduce using rule 39 (statement -> assigment statementF .)


state 98

    (46) statementF -> statement .

    R_CURPAR        reduce using rule 46 (statementF -> statement .)
    SEMICOLON       reduce using rule 46 (statementF -> statement .)


state 99

    (47) statementF -> empty .

    R_CURPAR        reduce using rule 47 (statementF -> empty .)
    SEMICOLON       reduce using rule 47 (statementF -> empty .)


state 100

    (40) statement -> void statementF .

    R_CURPAR        reduce using rule 40 (statement -> void statementF .)
    SEMICOLON       reduce using rule 40 (statement -> void statementF .)


state 101

    (41) statement -> return statementF .

    R_CURPAR        reduce using rule 41 (statement -> return statementF .)
    SEMICOLON       reduce using rule 41 (statement -> return statementF .)


state 102

    (42) statement -> read statementF .

    R_CURPAR        reduce using rule 42 (statement -> read statementF .)
    SEMICOLON       reduce using rule 42 (statement -> read statementF .)


state 103

    (43) statement -> write statementF .

    R_CURPAR        reduce using rule 43 (statement -> write statementF .)
    SEMICOLON       reduce using rule 43 (statement -> write statementF .)


state 104

    (44) statement -> if statementF .

    R_CURPAR        reduce using rule 44 (statement -> if statementF .)
    SEMICOLON       reduce using rule 44 (statement -> if statementF .)


state 105

    (45) statement -> repeat statementF .

    R_CURPAR        reduce using rule 45 (statement -> repeat statementF .)
    SEMICOLON       reduce using rule 45 (statement -> repeat statementF .)


state 106

    (74) assigment -> var np_addId . assigmentF
    (75) assigmentF -> . EQUAL np_addOp exp np_doAssign empty
    (76) assigmentF -> . ope np_addOp exp np_doAssign empty
    (77) ope -> . PLUS_EQ empty
    (78) ope -> . MIN_EQ empty
    (79) ope -> . MULT_EQ empty
    (80) ope -> . DIV_EQ empty

    EQUAL           shift and go to state 131
    PLUS_EQ         shift and go to state 133
    MIN_EQ          shift and go to state 134
    MULT_EQ         shift and go to state 135
    DIV_EQ          shift and go to state 136

    assigmentF                     shift and go to state 130
    ope                            shift and go to state 132

state 107

    (48) void -> ID DOT . ID L_PAR param R_PAR SEMICOLON empty
    (58) var -> ID DOT . VAR varF

    ID              shift and go to state 137
    VAR             shift and go to state 138


state 108

    (49) void -> ID L_PAR . param R_PAR SEMICOLON empty
    (50) void -> ID L_PAR . R_PAR SEMICOLON empty
    (53) param -> . exp paramF
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 142
    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    param                          shift and go to state 141
    exp                            shift and go to state 143
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 109

    (56) return -> RETURN L_PAR . exp R_PAR SEMICOLON empty
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    exp                            shift and go to state 158
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 110

    (61) read -> READ L_PAR . readF
    (62) readF -> . var COMMA readF
    (63) readF -> . var R_PAR SEMICOLON empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    VAR             shift and go to state 83
    ID              shift and go to state 139

    readF                          shift and go to state 159
    var                            shift and go to state 160

state 111

    (64) write -> WRITE L_PAR . writeT
    (65) writeT -> . CTE_CHAR writeF
    (66) writeT -> . exp writeF
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    CTE_CHAR        shift and go to state 162
    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    VAR             shift and go to state 83
    ID              shift and go to state 139

    writeT                         shift and go to state 161
    exp                            shift and go to state 163
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 112

    (71) if -> IF L_PAR . exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    exp                            shift and go to state 164
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 113

    (69) repeat -> conditional empty .

    ID              reduce using rule 69 (repeat -> conditional empty .)
    RETURN          reduce using rule 69 (repeat -> conditional empty .)
    READ            reduce using rule 69 (repeat -> conditional empty .)
    WRITE           reduce using rule 69 (repeat -> conditional empty .)
    IF              reduce using rule 69 (repeat -> conditional empty .)
    VAR             reduce using rule 69 (repeat -> conditional empty .)
    WHILE           reduce using rule 69 (repeat -> conditional empty .)
    FROM            reduce using rule 69 (repeat -> conditional empty .)
    R_CURPAR        reduce using rule 69 (repeat -> conditional empty .)
    SEMICOLON       reduce using rule 69 (repeat -> conditional empty .)


state 114

    (70) repeat -> nonconditional empty .

    ID              reduce using rule 70 (repeat -> nonconditional empty .)
    RETURN          reduce using rule 70 (repeat -> nonconditional empty .)
    READ            reduce using rule 70 (repeat -> nonconditional empty .)
    WRITE           reduce using rule 70 (repeat -> nonconditional empty .)
    IF              reduce using rule 70 (repeat -> nonconditional empty .)
    VAR             reduce using rule 70 (repeat -> nonconditional empty .)
    WHILE           reduce using rule 70 (repeat -> nonconditional empty .)
    FROM            reduce using rule 70 (repeat -> nonconditional empty .)
    R_CURPAR        reduce using rule 70 (repeat -> nonconditional empty .)
    SEMICOLON       reduce using rule 70 (repeat -> nonconditional empty .)


state 115

    (57) var -> VAR varF .

    EQUAL           reduce using rule 57 (var -> VAR varF .)
    PLUS_EQ         reduce using rule 57 (var -> VAR varF .)
    MIN_EQ          reduce using rule 57 (var -> VAR varF .)
    MULT_EQ         reduce using rule 57 (var -> VAR varF .)
    DIV_EQ          reduce using rule 57 (var -> VAR varF .)
    MULT            reduce using rule 57 (var -> VAR varF .)
    DIV             reduce using rule 57 (var -> VAR varF .)
    PLUS            reduce using rule 57 (var -> VAR varF .)
    MINUS           reduce using rule 57 (var -> VAR varF .)
    LESS            reduce using rule 57 (var -> VAR varF .)
    GREATER         reduce using rule 57 (var -> VAR varF .)
    LESS_TH         reduce using rule 57 (var -> VAR varF .)
    GREAT_TH        reduce using rule 57 (var -> VAR varF .)
    SAME            reduce using rule 57 (var -> VAR varF .)
    DIF             reduce using rule 57 (var -> VAR varF .)
    OR              reduce using rule 57 (var -> VAR varF .)
    AND             reduce using rule 57 (var -> VAR varF .)
    COMMA           reduce using rule 57 (var -> VAR varF .)
    R_PAR           reduce using rule 57 (var -> VAR varF .)
    R_BREAK         reduce using rule 57 (var -> VAR varF .)
    TO              reduce using rule 57 (var -> VAR varF .)
    ID              reduce using rule 57 (var -> VAR varF .)
    RETURN          reduce using rule 57 (var -> VAR varF .)
    READ            reduce using rule 57 (var -> VAR varF .)
    WRITE           reduce using rule 57 (var -> VAR varF .)
    IF              reduce using rule 57 (var -> VAR varF .)
    VAR             reduce using rule 57 (var -> VAR varF .)
    WHILE           reduce using rule 57 (var -> VAR varF .)
    FROM            reduce using rule 57 (var -> VAR varF .)
    R_CURPAR        reduce using rule 57 (var -> VAR varF .)
    SEMICOLON       reduce using rule 57 (var -> VAR varF .)
    DO              reduce using rule 57 (var -> VAR varF .)


state 116

    (59) varF -> arrfunc . empty
    (116) empty -> .

    EQUAL           reduce using rule 116 (empty -> .)
    PLUS_EQ         reduce using rule 116 (empty -> .)
    MIN_EQ          reduce using rule 116 (empty -> .)
    MULT_EQ         reduce using rule 116 (empty -> .)
    DIV_EQ          reduce using rule 116 (empty -> .)
    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 165

state 117

    (60) varF -> empty .

    EQUAL           reduce using rule 60 (varF -> empty .)
    PLUS_EQ         reduce using rule 60 (varF -> empty .)
    MIN_EQ          reduce using rule 60 (varF -> empty .)
    MULT_EQ         reduce using rule 60 (varF -> empty .)
    DIV_EQ          reduce using rule 60 (varF -> empty .)
    MULT            reduce using rule 60 (varF -> empty .)
    DIV             reduce using rule 60 (varF -> empty .)
    PLUS            reduce using rule 60 (varF -> empty .)
    MINUS           reduce using rule 60 (varF -> empty .)
    LESS            reduce using rule 60 (varF -> empty .)
    GREATER         reduce using rule 60 (varF -> empty .)
    LESS_TH         reduce using rule 60 (varF -> empty .)
    GREAT_TH        reduce using rule 60 (varF -> empty .)
    SAME            reduce using rule 60 (varF -> empty .)
    DIF             reduce using rule 60 (varF -> empty .)
    OR              reduce using rule 60 (varF -> empty .)
    AND             reduce using rule 60 (varF -> empty .)
    COMMA           reduce using rule 60 (varF -> empty .)
    R_PAR           reduce using rule 60 (varF -> empty .)
    R_BREAK         reduce using rule 60 (varF -> empty .)
    TO              reduce using rule 60 (varF -> empty .)
    ID              reduce using rule 60 (varF -> empty .)
    RETURN          reduce using rule 60 (varF -> empty .)
    READ            reduce using rule 60 (varF -> empty .)
    WRITE           reduce using rule 60 (varF -> empty .)
    IF              reduce using rule 60 (varF -> empty .)
    VAR             reduce using rule 60 (varF -> empty .)
    WHILE           reduce using rule 60 (varF -> empty .)
    FROM            reduce using rule 60 (varF -> empty .)
    R_CURPAR        reduce using rule 60 (varF -> empty .)
    SEMICOLON       reduce using rule 60 (varF -> empty .)
    DO              reduce using rule 60 (varF -> empty .)


state 118

    (51) arrfunc -> L_BREAK . exp COMMA exp R_BREAK empty
    (52) arrfunc -> L_BREAK . exp R_BREAK empty
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    exp                            shift and go to state 166
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 119

    (81) conditional -> WHILE L_PAR . exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    exp                            shift and go to state 167
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 120

    (82) nonconditional -> FROM VAR . arrfunc nonconditionalF
    (83) nonconditional -> FROM VAR . nonconditionalF
    (51) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (52) arrfunc -> . L_BREAK exp R_BREAK empty
    (84) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_BREAK         shift and go to state 118
    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    arrfunc                        shift and go to state 168
    nonconditionalF                shift and go to state 169
    exp                            shift and go to state 170
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 121

    (8) classT -> LESS INHERIT ID GREATER classF .

    CLASS           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VARS            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    MAIN            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    INT             reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    FLOAT           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    CHAR            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    ID              reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VOID            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)


state 122

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS . func R_CURPAR SEMICOLON empty
    (23) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (26) typeFunc -> . INT empty
    (27) typeFunc -> . FLOAT empty
    (28) typeFunc -> . CHAR empty
    (29) typeFunc -> . ID empty
    (30) typeFunc -> . VOID empty

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    ID              shift and go to state 6
    VOID            shift and go to state 20

    func                           shift and go to state 171
    typeFunc                       shift and go to state 15

state 123

    (15) decF -> COLON type np_getVarType SEMICOLON . np_getDec dec
    (16) decF -> COLON type np_getVarType SEMICOLON . np_getDec np_addToDic empty
    (118) np_getDec -> .

    VAR             reduce using rule 118 (np_getDec -> .)
    MAIN            reduce using rule 118 (np_getDec -> .)
    INT             reduce using rule 118 (np_getDec -> .)
    FLOAT           reduce using rule 118 (np_getDec -> .)
    CHAR            reduce using rule 118 (np_getDec -> .)
    ID              reduce using rule 118 (np_getDec -> .)
    VOID            reduce using rule 118 (np_getDec -> .)
    METHODS         reduce using rule 118 (np_getDec -> .)
    L_CURPAR        reduce using rule 118 (np_getDec -> .)

    np_getDec                      shift and go to state 172

state 124

    (21) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK . empty
    (116) empty -> .

    COMMA           reduce using rule 116 (empty -> .)
    COLON           reduce using rule 116 (empty -> .)

    empty                          shift and go to state 173

state 125

    (23) func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .

    MAIN            reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    INT             reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    FLOAT           reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    CHAR            reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    ID              reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    VOID            reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    R_CURPAR        reduce using rule 23 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)


state 126

    (24) funcF -> parameter . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 174


state 127

    (25) funcF -> R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 175


state 128

    (31) parameter -> VAR . COLON typepar SEMICOLON parameterF

    COLON           shift and go to state 176


state 129

    (38) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .

    $end            reduce using rule 38 (main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .)


state 130

    (74) assigment -> var np_addId assigmentF .

    ID              reduce using rule 74 (assigment -> var np_addId assigmentF .)
    RETURN          reduce using rule 74 (assigment -> var np_addId assigmentF .)
    READ            reduce using rule 74 (assigment -> var np_addId assigmentF .)
    WRITE           reduce using rule 74 (assigment -> var np_addId assigmentF .)
    IF              reduce using rule 74 (assigment -> var np_addId assigmentF .)
    VAR             reduce using rule 74 (assigment -> var np_addId assigmentF .)
    WHILE           reduce using rule 74 (assigment -> var np_addId assigmentF .)
    FROM            reduce using rule 74 (assigment -> var np_addId assigmentF .)
    R_CURPAR        reduce using rule 74 (assigment -> var np_addId assigmentF .)
    SEMICOLON       reduce using rule 74 (assigment -> var np_addId assigmentF .)


state 131

    (75) assigmentF -> EQUAL . np_addOp exp np_doAssign empty
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 177

state 132

    (76) assigmentF -> ope . np_addOp exp np_doAssign empty
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 178

state 133

    (77) ope -> PLUS_EQ . empty
    (116) empty -> .

    L_PAR           reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    CTE_INT         reduce using rule 116 (empty -> .)
    CTE_FLOAT       reduce using rule 116 (empty -> .)
    CTE_CHAR        reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 179

state 134

    (78) ope -> MIN_EQ . empty
    (116) empty -> .

    L_PAR           reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    CTE_INT         reduce using rule 116 (empty -> .)
    CTE_FLOAT       reduce using rule 116 (empty -> .)
    CTE_CHAR        reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 180

state 135

    (79) ope -> MULT_EQ . empty
    (116) empty -> .

    L_PAR           reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    CTE_INT         reduce using rule 116 (empty -> .)
    CTE_FLOAT       reduce using rule 116 (empty -> .)
    CTE_CHAR        reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 181

state 136

    (80) ope -> DIV_EQ . empty
    (116) empty -> .

    L_PAR           reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    CTE_INT         reduce using rule 116 (empty -> .)
    CTE_FLOAT       reduce using rule 116 (empty -> .)
    CTE_CHAR        reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 182

state 137

    (48) void -> ID DOT ID . L_PAR param R_PAR SEMICOLON empty

    L_PAR           shift and go to state 183


state 138

    (58) var -> ID DOT VAR . varF
    (59) varF -> . arrfunc empty
    (60) varF -> . empty
    (51) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (52) arrfunc -> . L_BREAK exp R_BREAK empty
    (116) empty -> .

    L_BREAK         shift and go to state 118
    EQUAL           reduce using rule 116 (empty -> .)
    PLUS_EQ         reduce using rule 116 (empty -> .)
    MIN_EQ          reduce using rule 116 (empty -> .)
    MULT_EQ         reduce using rule 116 (empty -> .)
    DIV_EQ          reduce using rule 116 (empty -> .)
    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    varF                           shift and go to state 184
    arrfunc                        shift and go to state 116
    empty                          shift and go to state 117

state 139

    (58) var -> ID . DOT VAR varF

    DOT             shift and go to state 185


state 140

    (106) factor -> L_PAR . np_addPar exp R_PAR np_popPar empty
    (125) np_addPar -> .

    L_PAR           reduce using rule 125 (np_addPar -> .)
    PLUS            reduce using rule 125 (np_addPar -> .)
    MINUS           reduce using rule 125 (np_addPar -> .)
    CTE_INT         reduce using rule 125 (np_addPar -> .)
    CTE_FLOAT       reduce using rule 125 (np_addPar -> .)
    CTE_CHAR        reduce using rule 125 (np_addPar -> .)
    VAR             reduce using rule 125 (np_addPar -> .)
    ID              reduce using rule 125 (np_addPar -> .)

    np_addPar                      shift and go to state 186

state 141

    (49) void -> ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 187


state 142

    (50) void -> ID L_PAR R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 188


state 143

    (53) param -> exp . paramF
    (54) paramF -> . COMMA param
    (55) paramF -> . empty
    (116) empty -> .

    COMMA           shift and go to state 190
    R_PAR           reduce using rule 116 (empty -> .)

    paramF                         shift and go to state 189
    empty                          shift and go to state 191

state 144

    (97) exp -> bool . empty
    (116) empty -> .

    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 192

state 145

    (85) bool -> logical . np_addBool boolF
    (130) np_addBool -> .

    OR              reduce using rule 130 (np_addBool -> .)
    AND             reduce using rule 130 (np_addBool -> .)
    COMMA           reduce using rule 130 (np_addBool -> .)
    R_PAR           reduce using rule 130 (np_addBool -> .)
    R_BREAK         reduce using rule 130 (np_addBool -> .)
    TO              reduce using rule 130 (np_addBool -> .)
    ID              reduce using rule 130 (np_addBool -> .)
    RETURN          reduce using rule 130 (np_addBool -> .)
    READ            reduce using rule 130 (np_addBool -> .)
    WRITE           reduce using rule 130 (np_addBool -> .)
    IF              reduce using rule 130 (np_addBool -> .)
    VAR             reduce using rule 130 (np_addBool -> .)
    WHILE           reduce using rule 130 (np_addBool -> .)
    FROM            reduce using rule 130 (np_addBool -> .)
    R_CURPAR        reduce using rule 130 (np_addBool -> .)
    SEMICOLON       reduce using rule 130 (np_addBool -> .)
    DO              reduce using rule 130 (np_addBool -> .)

    np_addBool                     shift and go to state 193

state 146

    (89) logical -> ex . np_addLogical logicalF
    (129) np_addLogical -> .

    LESS            reduce using rule 129 (np_addLogical -> .)
    GREATER         reduce using rule 129 (np_addLogical -> .)
    LESS_TH         reduce using rule 129 (np_addLogical -> .)
    GREAT_TH        reduce using rule 129 (np_addLogical -> .)
    SAME            reduce using rule 129 (np_addLogical -> .)
    DIF             reduce using rule 129 (np_addLogical -> .)
    OR              reduce using rule 129 (np_addLogical -> .)
    AND             reduce using rule 129 (np_addLogical -> .)
    COMMA           reduce using rule 129 (np_addLogical -> .)
    R_PAR           reduce using rule 129 (np_addLogical -> .)
    R_BREAK         reduce using rule 129 (np_addLogical -> .)
    TO              reduce using rule 129 (np_addLogical -> .)
    ID              reduce using rule 129 (np_addLogical -> .)
    RETURN          reduce using rule 129 (np_addLogical -> .)
    READ            reduce using rule 129 (np_addLogical -> .)
    WRITE           reduce using rule 129 (np_addLogical -> .)
    IF              reduce using rule 129 (np_addLogical -> .)
    VAR             reduce using rule 129 (np_addLogical -> .)
    WHILE           reduce using rule 129 (np_addLogical -> .)
    FROM            reduce using rule 129 (np_addLogical -> .)
    R_CURPAR        reduce using rule 129 (np_addLogical -> .)
    SEMICOLON       reduce using rule 129 (np_addLogical -> .)
    DO              reduce using rule 129 (np_addLogical -> .)

    np_addLogical                  shift and go to state 194

state 147

    (98) ex -> term . np_addEx exF
    (128) np_addEx -> .

    PLUS            reduce using rule 128 (np_addEx -> .)
    MINUS           reduce using rule 128 (np_addEx -> .)
    LESS            reduce using rule 128 (np_addEx -> .)
    GREATER         reduce using rule 128 (np_addEx -> .)
    LESS_TH         reduce using rule 128 (np_addEx -> .)
    GREAT_TH        reduce using rule 128 (np_addEx -> .)
    SAME            reduce using rule 128 (np_addEx -> .)
    DIF             reduce using rule 128 (np_addEx -> .)
    OR              reduce using rule 128 (np_addEx -> .)
    AND             reduce using rule 128 (np_addEx -> .)
    COMMA           reduce using rule 128 (np_addEx -> .)
    R_PAR           reduce using rule 128 (np_addEx -> .)
    R_BREAK         reduce using rule 128 (np_addEx -> .)
    TO              reduce using rule 128 (np_addEx -> .)
    ID              reduce using rule 128 (np_addEx -> .)
    RETURN          reduce using rule 128 (np_addEx -> .)
    READ            reduce using rule 128 (np_addEx -> .)
    WRITE           reduce using rule 128 (np_addEx -> .)
    IF              reduce using rule 128 (np_addEx -> .)
    VAR             reduce using rule 128 (np_addEx -> .)
    WHILE           reduce using rule 128 (np_addEx -> .)
    FROM            reduce using rule 128 (np_addEx -> .)
    R_CURPAR        reduce using rule 128 (np_addEx -> .)
    SEMICOLON       reduce using rule 128 (np_addEx -> .)
    DO              reduce using rule 128 (np_addEx -> .)

    np_addEx                       shift and go to state 195

state 148

    (102) term -> factor . np_addTerm termF
    (127) np_addTerm -> .

    MULT            reduce using rule 127 (np_addTerm -> .)
    DIV             reduce using rule 127 (np_addTerm -> .)
    PLUS            reduce using rule 127 (np_addTerm -> .)
    MINUS           reduce using rule 127 (np_addTerm -> .)
    LESS            reduce using rule 127 (np_addTerm -> .)
    GREATER         reduce using rule 127 (np_addTerm -> .)
    LESS_TH         reduce using rule 127 (np_addTerm -> .)
    GREAT_TH        reduce using rule 127 (np_addTerm -> .)
    SAME            reduce using rule 127 (np_addTerm -> .)
    DIF             reduce using rule 127 (np_addTerm -> .)
    OR              reduce using rule 127 (np_addTerm -> .)
    AND             reduce using rule 127 (np_addTerm -> .)
    COMMA           reduce using rule 127 (np_addTerm -> .)
    R_PAR           reduce using rule 127 (np_addTerm -> .)
    R_BREAK         reduce using rule 127 (np_addTerm -> .)
    TO              reduce using rule 127 (np_addTerm -> .)
    ID              reduce using rule 127 (np_addTerm -> .)
    RETURN          reduce using rule 127 (np_addTerm -> .)
    READ            reduce using rule 127 (np_addTerm -> .)
    WRITE           reduce using rule 127 (np_addTerm -> .)
    IF              reduce using rule 127 (np_addTerm -> .)
    VAR             reduce using rule 127 (np_addTerm -> .)
    WHILE           reduce using rule 127 (np_addTerm -> .)
    FROM            reduce using rule 127 (np_addTerm -> .)
    R_CURPAR        reduce using rule 127 (np_addTerm -> .)
    SEMICOLON       reduce using rule 127 (np_addTerm -> .)
    DO              reduce using rule 127 (np_addTerm -> .)

    np_addTerm                     shift and go to state 196

state 149

    (107) factor -> factorT .

    MULT            reduce using rule 107 (factor -> factorT .)
    DIV             reduce using rule 107 (factor -> factorT .)
    PLUS            reduce using rule 107 (factor -> factorT .)
    MINUS           reduce using rule 107 (factor -> factorT .)
    LESS            reduce using rule 107 (factor -> factorT .)
    GREATER         reduce using rule 107 (factor -> factorT .)
    LESS_TH         reduce using rule 107 (factor -> factorT .)
    GREAT_TH        reduce using rule 107 (factor -> factorT .)
    SAME            reduce using rule 107 (factor -> factorT .)
    DIF             reduce using rule 107 (factor -> factorT .)
    OR              reduce using rule 107 (factor -> factorT .)
    AND             reduce using rule 107 (factor -> factorT .)
    COMMA           reduce using rule 107 (factor -> factorT .)
    R_PAR           reduce using rule 107 (factor -> factorT .)
    R_BREAK         reduce using rule 107 (factor -> factorT .)
    TO              reduce using rule 107 (factor -> factorT .)
    ID              reduce using rule 107 (factor -> factorT .)
    RETURN          reduce using rule 107 (factor -> factorT .)
    READ            reduce using rule 107 (factor -> factorT .)
    WRITE           reduce using rule 107 (factor -> factorT .)
    IF              reduce using rule 107 (factor -> factorT .)
    VAR             reduce using rule 107 (factor -> factorT .)
    WHILE           reduce using rule 107 (factor -> factorT .)
    FROM            reduce using rule 107 (factor -> factorT .)
    R_CURPAR        reduce using rule 107 (factor -> factorT .)
    SEMICOLON       reduce using rule 107 (factor -> factorT .)
    DO              reduce using rule 107 (factor -> factorT .)


state 150

    (108) factorT -> PLUS . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    factorF                        shift and go to state 197
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 151

    (110) factorT -> factorF .

    MULT            reduce using rule 110 (factorT -> factorF .)
    DIV             reduce using rule 110 (factorT -> factorF .)
    PLUS            reduce using rule 110 (factorT -> factorF .)
    MINUS           reduce using rule 110 (factorT -> factorF .)
    LESS            reduce using rule 110 (factorT -> factorF .)
    GREATER         reduce using rule 110 (factorT -> factorF .)
    LESS_TH         reduce using rule 110 (factorT -> factorF .)
    GREAT_TH        reduce using rule 110 (factorT -> factorF .)
    SAME            reduce using rule 110 (factorT -> factorF .)
    DIF             reduce using rule 110 (factorT -> factorF .)
    OR              reduce using rule 110 (factorT -> factorF .)
    AND             reduce using rule 110 (factorT -> factorF .)
    COMMA           reduce using rule 110 (factorT -> factorF .)
    R_PAR           reduce using rule 110 (factorT -> factorF .)
    R_BREAK         reduce using rule 110 (factorT -> factorF .)
    TO              reduce using rule 110 (factorT -> factorF .)
    ID              reduce using rule 110 (factorT -> factorF .)
    RETURN          reduce using rule 110 (factorT -> factorF .)
    READ            reduce using rule 110 (factorT -> factorF .)
    WRITE           reduce using rule 110 (factorT -> factorF .)
    IF              reduce using rule 110 (factorT -> factorF .)
    VAR             reduce using rule 110 (factorT -> factorF .)
    WHILE           reduce using rule 110 (factorT -> factorF .)
    FROM            reduce using rule 110 (factorT -> factorF .)
    R_CURPAR        reduce using rule 110 (factorT -> factorF .)
    SEMICOLON       reduce using rule 110 (factorT -> factorF .)
    DO              reduce using rule 110 (factorT -> factorF .)


state 152

    (109) factorT -> MINUS . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    factorF                        shift and go to state 198
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 153

    (111) factorF -> varcte . empty
    (116) empty -> .

    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 199

state 154

    (112) varcte -> var . np_addId empty
    (123) np_addId -> .

    MULT            reduce using rule 123 (np_addId -> .)
    DIV             reduce using rule 123 (np_addId -> .)
    PLUS            reduce using rule 123 (np_addId -> .)
    MINUS           reduce using rule 123 (np_addId -> .)
    LESS            reduce using rule 123 (np_addId -> .)
    GREATER         reduce using rule 123 (np_addId -> .)
    LESS_TH         reduce using rule 123 (np_addId -> .)
    GREAT_TH        reduce using rule 123 (np_addId -> .)
    SAME            reduce using rule 123 (np_addId -> .)
    DIF             reduce using rule 123 (np_addId -> .)
    OR              reduce using rule 123 (np_addId -> .)
    AND             reduce using rule 123 (np_addId -> .)
    COMMA           reduce using rule 123 (np_addId -> .)
    R_PAR           reduce using rule 123 (np_addId -> .)
    R_BREAK         reduce using rule 123 (np_addId -> .)
    TO              reduce using rule 123 (np_addId -> .)
    ID              reduce using rule 123 (np_addId -> .)
    RETURN          reduce using rule 123 (np_addId -> .)
    READ            reduce using rule 123 (np_addId -> .)
    WRITE           reduce using rule 123 (np_addId -> .)
    IF              reduce using rule 123 (np_addId -> .)
    VAR             reduce using rule 123 (np_addId -> .)
    WHILE           reduce using rule 123 (np_addId -> .)
    FROM            reduce using rule 123 (np_addId -> .)
    R_CURPAR        reduce using rule 123 (np_addId -> .)
    SEMICOLON       reduce using rule 123 (np_addId -> .)
    DO              reduce using rule 123 (np_addId -> .)

    np_addId                       shift and go to state 200

state 155

    (113) varcte -> CTE_INT . empty
    (116) empty -> .

    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 201

state 156

    (114) varcte -> CTE_FLOAT . empty
    (116) empty -> .

    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 202

state 157

    (115) varcte -> CTE_CHAR . empty
    (116) empty -> .

    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 203

state 158

    (56) return -> RETURN L_PAR exp . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 204


state 159

    (61) read -> READ L_PAR readF .

    ID              reduce using rule 61 (read -> READ L_PAR readF .)
    RETURN          reduce using rule 61 (read -> READ L_PAR readF .)
    READ            reduce using rule 61 (read -> READ L_PAR readF .)
    WRITE           reduce using rule 61 (read -> READ L_PAR readF .)
    IF              reduce using rule 61 (read -> READ L_PAR readF .)
    VAR             reduce using rule 61 (read -> READ L_PAR readF .)
    WHILE           reduce using rule 61 (read -> READ L_PAR readF .)
    FROM            reduce using rule 61 (read -> READ L_PAR readF .)
    R_CURPAR        reduce using rule 61 (read -> READ L_PAR readF .)
    SEMICOLON       reduce using rule 61 (read -> READ L_PAR readF .)


state 160

    (62) readF -> var . COMMA readF
    (63) readF -> var . R_PAR SEMICOLON empty

    COMMA           shift and go to state 205
    R_PAR           shift and go to state 206


state 161

    (64) write -> WRITE L_PAR writeT .

    ID              reduce using rule 64 (write -> WRITE L_PAR writeT .)
    RETURN          reduce using rule 64 (write -> WRITE L_PAR writeT .)
    READ            reduce using rule 64 (write -> WRITE L_PAR writeT .)
    WRITE           reduce using rule 64 (write -> WRITE L_PAR writeT .)
    IF              reduce using rule 64 (write -> WRITE L_PAR writeT .)
    VAR             reduce using rule 64 (write -> WRITE L_PAR writeT .)
    WHILE           reduce using rule 64 (write -> WRITE L_PAR writeT .)
    FROM            reduce using rule 64 (write -> WRITE L_PAR writeT .)
    R_CURPAR        reduce using rule 64 (write -> WRITE L_PAR writeT .)
    SEMICOLON       reduce using rule 64 (write -> WRITE L_PAR writeT .)


state 162

    (65) writeT -> CTE_CHAR . writeF
    (115) varcte -> CTE_CHAR . empty
    (67) writeF -> . COMMA writeT
    (68) writeF -> . R_PAR SEMICOLON empty
    (116) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for R_PAR resolved as shift
    COMMA           shift and go to state 208
    R_PAR           shift and go to state 209
    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)

  ! COMMA           [ reduce using rule 116 (empty -> .) ]
  ! R_PAR           [ reduce using rule 116 (empty -> .) ]

    writeF                         shift and go to state 207
    empty                          shift and go to state 203

state 163

    (66) writeT -> exp . writeF
    (67) writeF -> . COMMA writeT
    (68) writeF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 208
    R_PAR           shift and go to state 209

    writeF                         shift and go to state 210

state 164

    (71) if -> IF L_PAR exp . R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    R_PAR           shift and go to state 211


state 165

    (59) varF -> arrfunc empty .

    EQUAL           reduce using rule 59 (varF -> arrfunc empty .)
    PLUS_EQ         reduce using rule 59 (varF -> arrfunc empty .)
    MIN_EQ          reduce using rule 59 (varF -> arrfunc empty .)
    MULT_EQ         reduce using rule 59 (varF -> arrfunc empty .)
    DIV_EQ          reduce using rule 59 (varF -> arrfunc empty .)
    MULT            reduce using rule 59 (varF -> arrfunc empty .)
    DIV             reduce using rule 59 (varF -> arrfunc empty .)
    PLUS            reduce using rule 59 (varF -> arrfunc empty .)
    MINUS           reduce using rule 59 (varF -> arrfunc empty .)
    LESS            reduce using rule 59 (varF -> arrfunc empty .)
    GREATER         reduce using rule 59 (varF -> arrfunc empty .)
    LESS_TH         reduce using rule 59 (varF -> arrfunc empty .)
    GREAT_TH        reduce using rule 59 (varF -> arrfunc empty .)
    SAME            reduce using rule 59 (varF -> arrfunc empty .)
    DIF             reduce using rule 59 (varF -> arrfunc empty .)
    OR              reduce using rule 59 (varF -> arrfunc empty .)
    AND             reduce using rule 59 (varF -> arrfunc empty .)
    COMMA           reduce using rule 59 (varF -> arrfunc empty .)
    R_PAR           reduce using rule 59 (varF -> arrfunc empty .)
    R_BREAK         reduce using rule 59 (varF -> arrfunc empty .)
    TO              reduce using rule 59 (varF -> arrfunc empty .)
    ID              reduce using rule 59 (varF -> arrfunc empty .)
    RETURN          reduce using rule 59 (varF -> arrfunc empty .)
    READ            reduce using rule 59 (varF -> arrfunc empty .)
    WRITE           reduce using rule 59 (varF -> arrfunc empty .)
    IF              reduce using rule 59 (varF -> arrfunc empty .)
    VAR             reduce using rule 59 (varF -> arrfunc empty .)
    WHILE           reduce using rule 59 (varF -> arrfunc empty .)
    FROM            reduce using rule 59 (varF -> arrfunc empty .)
    R_CURPAR        reduce using rule 59 (varF -> arrfunc empty .)
    SEMICOLON       reduce using rule 59 (varF -> arrfunc empty .)
    DO              reduce using rule 59 (varF -> arrfunc empty .)


state 166

    (51) arrfunc -> L_BREAK exp . COMMA exp R_BREAK empty
    (52) arrfunc -> L_BREAK exp . R_BREAK empty

    COMMA           shift and go to state 212
    R_BREAK         shift and go to state 213


state 167

    (81) conditional -> WHILE L_PAR exp . R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    R_PAR           shift and go to state 214


state 168

    (82) nonconditional -> FROM VAR arrfunc . nonconditionalF
    (84) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    nonconditionalF                shift and go to state 215
    exp                            shift and go to state 170
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 169

    (83) nonconditional -> FROM VAR nonconditionalF .

    ID              reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    RETURN          reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    READ            reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    WRITE           reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    IF              reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    VAR             reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    WHILE           reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    FROM            reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    R_CURPAR        reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)
    SEMICOLON       reduce using rule 83 (nonconditional -> FROM VAR nonconditionalF .)


state 170

    (84) nonconditionalF -> exp . TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty

    TO              shift and go to state 216


state 171

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func . R_CURPAR SEMICOLON empty

    R_CURPAR        shift and go to state 217


state 172

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec . dec
    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec . np_addToDic empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF
    (122) np_addToDic -> .

    VAR             shift and go to state 26
    MAIN            reduce using rule 122 (np_addToDic -> .)
    INT             reduce using rule 122 (np_addToDic -> .)
    FLOAT           reduce using rule 122 (np_addToDic -> .)
    CHAR            reduce using rule 122 (np_addToDic -> .)
    ID              reduce using rule 122 (np_addToDic -> .)
    VOID            reduce using rule 122 (np_addToDic -> .)
    METHODS         reduce using rule 122 (np_addToDic -> .)
    L_CURPAR        reduce using rule 122 (np_addToDic -> .)

    dec                            shift and go to state 218
    np_addToDic                    shift and go to state 219

state 173

    (21) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .

    COMMA           reduce using rule 21 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    COLON           reduce using rule 21 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)


state 174

    (24) funcF -> parameter R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 220


state 175

    (25) funcF -> R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 26

    dec                            shift and go to state 221

state 176

    (31) parameter -> VAR COLON . typepar SEMICOLON parameterF
    (34) typepar -> . INT empty
    (35) typepar -> . FLOAT empty
    (36) typepar -> . CHAR empty
    (37) typepar -> . ID empty

    INT             shift and go to state 223
    FLOAT           shift and go to state 224
    CHAR            shift and go to state 225
    ID              shift and go to state 226

    typepar                        shift and go to state 222

state 177

    (75) assigmentF -> EQUAL np_addOp . exp np_doAssign empty
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    exp                            shift and go to state 227
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 178

    (76) assigmentF -> ope np_addOp . exp np_doAssign empty
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    exp                            shift and go to state 228
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 179

    (77) ope -> PLUS_EQ empty .

    L_PAR           reduce using rule 77 (ope -> PLUS_EQ empty .)
    PLUS            reduce using rule 77 (ope -> PLUS_EQ empty .)
    MINUS           reduce using rule 77 (ope -> PLUS_EQ empty .)
    CTE_INT         reduce using rule 77 (ope -> PLUS_EQ empty .)
    CTE_FLOAT       reduce using rule 77 (ope -> PLUS_EQ empty .)
    CTE_CHAR        reduce using rule 77 (ope -> PLUS_EQ empty .)
    VAR             reduce using rule 77 (ope -> PLUS_EQ empty .)
    ID              reduce using rule 77 (ope -> PLUS_EQ empty .)


state 180

    (78) ope -> MIN_EQ empty .

    L_PAR           reduce using rule 78 (ope -> MIN_EQ empty .)
    PLUS            reduce using rule 78 (ope -> MIN_EQ empty .)
    MINUS           reduce using rule 78 (ope -> MIN_EQ empty .)
    CTE_INT         reduce using rule 78 (ope -> MIN_EQ empty .)
    CTE_FLOAT       reduce using rule 78 (ope -> MIN_EQ empty .)
    CTE_CHAR        reduce using rule 78 (ope -> MIN_EQ empty .)
    VAR             reduce using rule 78 (ope -> MIN_EQ empty .)
    ID              reduce using rule 78 (ope -> MIN_EQ empty .)


state 181

    (79) ope -> MULT_EQ empty .

    L_PAR           reduce using rule 79 (ope -> MULT_EQ empty .)
    PLUS            reduce using rule 79 (ope -> MULT_EQ empty .)
    MINUS           reduce using rule 79 (ope -> MULT_EQ empty .)
    CTE_INT         reduce using rule 79 (ope -> MULT_EQ empty .)
    CTE_FLOAT       reduce using rule 79 (ope -> MULT_EQ empty .)
    CTE_CHAR        reduce using rule 79 (ope -> MULT_EQ empty .)
    VAR             reduce using rule 79 (ope -> MULT_EQ empty .)
    ID              reduce using rule 79 (ope -> MULT_EQ empty .)


state 182

    (80) ope -> DIV_EQ empty .

    L_PAR           reduce using rule 80 (ope -> DIV_EQ empty .)
    PLUS            reduce using rule 80 (ope -> DIV_EQ empty .)
    MINUS           reduce using rule 80 (ope -> DIV_EQ empty .)
    CTE_INT         reduce using rule 80 (ope -> DIV_EQ empty .)
    CTE_FLOAT       reduce using rule 80 (ope -> DIV_EQ empty .)
    CTE_CHAR        reduce using rule 80 (ope -> DIV_EQ empty .)
    VAR             reduce using rule 80 (ope -> DIV_EQ empty .)
    ID              reduce using rule 80 (ope -> DIV_EQ empty .)


state 183

    (48) void -> ID DOT ID L_PAR . param R_PAR SEMICOLON empty
    (53) param -> . exp paramF
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    param                          shift and go to state 229
    exp                            shift and go to state 143
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 184

    (58) var -> ID DOT VAR varF .

    EQUAL           reduce using rule 58 (var -> ID DOT VAR varF .)
    PLUS_EQ         reduce using rule 58 (var -> ID DOT VAR varF .)
    MIN_EQ          reduce using rule 58 (var -> ID DOT VAR varF .)
    MULT_EQ         reduce using rule 58 (var -> ID DOT VAR varF .)
    DIV_EQ          reduce using rule 58 (var -> ID DOT VAR varF .)
    MULT            reduce using rule 58 (var -> ID DOT VAR varF .)
    DIV             reduce using rule 58 (var -> ID DOT VAR varF .)
    PLUS            reduce using rule 58 (var -> ID DOT VAR varF .)
    MINUS           reduce using rule 58 (var -> ID DOT VAR varF .)
    LESS            reduce using rule 58 (var -> ID DOT VAR varF .)
    GREATER         reduce using rule 58 (var -> ID DOT VAR varF .)
    LESS_TH         reduce using rule 58 (var -> ID DOT VAR varF .)
    GREAT_TH        reduce using rule 58 (var -> ID DOT VAR varF .)
    SAME            reduce using rule 58 (var -> ID DOT VAR varF .)
    DIF             reduce using rule 58 (var -> ID DOT VAR varF .)
    OR              reduce using rule 58 (var -> ID DOT VAR varF .)
    AND             reduce using rule 58 (var -> ID DOT VAR varF .)
    COMMA           reduce using rule 58 (var -> ID DOT VAR varF .)
    R_PAR           reduce using rule 58 (var -> ID DOT VAR varF .)
    R_BREAK         reduce using rule 58 (var -> ID DOT VAR varF .)
    TO              reduce using rule 58 (var -> ID DOT VAR varF .)
    ID              reduce using rule 58 (var -> ID DOT VAR varF .)
    RETURN          reduce using rule 58 (var -> ID DOT VAR varF .)
    READ            reduce using rule 58 (var -> ID DOT VAR varF .)
    WRITE           reduce using rule 58 (var -> ID DOT VAR varF .)
    IF              reduce using rule 58 (var -> ID DOT VAR varF .)
    VAR             reduce using rule 58 (var -> ID DOT VAR varF .)
    WHILE           reduce using rule 58 (var -> ID DOT VAR varF .)
    FROM            reduce using rule 58 (var -> ID DOT VAR varF .)
    R_CURPAR        reduce using rule 58 (var -> ID DOT VAR varF .)
    SEMICOLON       reduce using rule 58 (var -> ID DOT VAR varF .)
    DO              reduce using rule 58 (var -> ID DOT VAR varF .)


state 185

    (58) var -> ID DOT . VAR varF

    VAR             shift and go to state 138


state 186

    (106) factor -> L_PAR np_addPar . exp R_PAR np_popPar empty
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    exp                            shift and go to state 230
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 187

    (49) void -> ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 231


state 188

    (50) void -> ID L_PAR R_PAR SEMICOLON . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 232

state 189

    (53) param -> exp paramF .

    R_PAR           reduce using rule 53 (param -> exp paramF .)


state 190

    (54) paramF -> COMMA . param
    (53) param -> . exp paramF
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    param                          shift and go to state 233
    exp                            shift and go to state 143
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 191

    (55) paramF -> empty .

    R_PAR           reduce using rule 55 (paramF -> empty .)


state 192

    (97) exp -> bool empty .

    COMMA           reduce using rule 97 (exp -> bool empty .)
    R_PAR           reduce using rule 97 (exp -> bool empty .)
    R_BREAK         reduce using rule 97 (exp -> bool empty .)
    TO              reduce using rule 97 (exp -> bool empty .)
    ID              reduce using rule 97 (exp -> bool empty .)
    RETURN          reduce using rule 97 (exp -> bool empty .)
    READ            reduce using rule 97 (exp -> bool empty .)
    WRITE           reduce using rule 97 (exp -> bool empty .)
    IF              reduce using rule 97 (exp -> bool empty .)
    VAR             reduce using rule 97 (exp -> bool empty .)
    WHILE           reduce using rule 97 (exp -> bool empty .)
    FROM            reduce using rule 97 (exp -> bool empty .)
    R_CURPAR        reduce using rule 97 (exp -> bool empty .)
    SEMICOLON       reduce using rule 97 (exp -> bool empty .)
    DO              reduce using rule 97 (exp -> bool empty .)


state 193

    (85) bool -> logical np_addBool . boolF
    (86) boolF -> . OR np_addOp bool
    (87) boolF -> . AND np_addOp bool
    (88) boolF -> . empty
    (116) empty -> .

    OR              shift and go to state 235
    AND             shift and go to state 236
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    boolF                          shift and go to state 234
    empty                          shift and go to state 237

state 194

    (89) logical -> ex np_addLogical . logicalF
    (90) logicalF -> . LESS np_addOp logical
    (91) logicalF -> . GREATER np_addOp logical
    (92) logicalF -> . LESS_TH np_addOp logical
    (93) logicalF -> . GREAT_TH np_addOp logical
    (94) logicalF -> . SAME np_addOp logical
    (95) logicalF -> . DIF np_addOp logical
    (96) logicalF -> . empty
    (116) empty -> .

    LESS            shift and go to state 239
    GREATER         shift and go to state 240
    LESS_TH         shift and go to state 241
    GREAT_TH        shift and go to state 242
    SAME            shift and go to state 243
    DIF             shift and go to state 244
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    logicalF                       shift and go to state 238
    empty                          shift and go to state 245

state 195

    (98) ex -> term np_addEx . exF
    (99) exF -> . PLUS np_addOp ex
    (100) exF -> . MINUS np_addOp ex
    (101) exF -> . empty
    (116) empty -> .

    PLUS            shift and go to state 247
    MINUS           shift and go to state 248
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    exF                            shift and go to state 246
    empty                          shift and go to state 249

state 196

    (102) term -> factor np_addTerm . termF
    (103) termF -> . MULT np_addOp term
    (104) termF -> . DIV np_addOp term
    (105) termF -> . empty
    (116) empty -> .

    MULT            shift and go to state 251
    DIV             shift and go to state 252
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    termF                          shift and go to state 250
    empty                          shift and go to state 253

state 197

    (108) factorT -> PLUS factorF .

    MULT            reduce using rule 108 (factorT -> PLUS factorF .)
    DIV             reduce using rule 108 (factorT -> PLUS factorF .)
    PLUS            reduce using rule 108 (factorT -> PLUS factorF .)
    MINUS           reduce using rule 108 (factorT -> PLUS factorF .)
    LESS            reduce using rule 108 (factorT -> PLUS factorF .)
    GREATER         reduce using rule 108 (factorT -> PLUS factorF .)
    LESS_TH         reduce using rule 108 (factorT -> PLUS factorF .)
    GREAT_TH        reduce using rule 108 (factorT -> PLUS factorF .)
    SAME            reduce using rule 108 (factorT -> PLUS factorF .)
    DIF             reduce using rule 108 (factorT -> PLUS factorF .)
    OR              reduce using rule 108 (factorT -> PLUS factorF .)
    AND             reduce using rule 108 (factorT -> PLUS factorF .)
    COMMA           reduce using rule 108 (factorT -> PLUS factorF .)
    R_PAR           reduce using rule 108 (factorT -> PLUS factorF .)
    R_BREAK         reduce using rule 108 (factorT -> PLUS factorF .)
    TO              reduce using rule 108 (factorT -> PLUS factorF .)
    ID              reduce using rule 108 (factorT -> PLUS factorF .)
    RETURN          reduce using rule 108 (factorT -> PLUS factorF .)
    READ            reduce using rule 108 (factorT -> PLUS factorF .)
    WRITE           reduce using rule 108 (factorT -> PLUS factorF .)
    IF              reduce using rule 108 (factorT -> PLUS factorF .)
    VAR             reduce using rule 108 (factorT -> PLUS factorF .)
    WHILE           reduce using rule 108 (factorT -> PLUS factorF .)
    FROM            reduce using rule 108 (factorT -> PLUS factorF .)
    R_CURPAR        reduce using rule 108 (factorT -> PLUS factorF .)
    SEMICOLON       reduce using rule 108 (factorT -> PLUS factorF .)
    DO              reduce using rule 108 (factorT -> PLUS factorF .)


state 198

    (109) factorT -> MINUS factorF .

    MULT            reduce using rule 109 (factorT -> MINUS factorF .)
    DIV             reduce using rule 109 (factorT -> MINUS factorF .)
    PLUS            reduce using rule 109 (factorT -> MINUS factorF .)
    MINUS           reduce using rule 109 (factorT -> MINUS factorF .)
    LESS            reduce using rule 109 (factorT -> MINUS factorF .)
    GREATER         reduce using rule 109 (factorT -> MINUS factorF .)
    LESS_TH         reduce using rule 109 (factorT -> MINUS factorF .)
    GREAT_TH        reduce using rule 109 (factorT -> MINUS factorF .)
    SAME            reduce using rule 109 (factorT -> MINUS factorF .)
    DIF             reduce using rule 109 (factorT -> MINUS factorF .)
    OR              reduce using rule 109 (factorT -> MINUS factorF .)
    AND             reduce using rule 109 (factorT -> MINUS factorF .)
    COMMA           reduce using rule 109 (factorT -> MINUS factorF .)
    R_PAR           reduce using rule 109 (factorT -> MINUS factorF .)
    R_BREAK         reduce using rule 109 (factorT -> MINUS factorF .)
    TO              reduce using rule 109 (factorT -> MINUS factorF .)
    ID              reduce using rule 109 (factorT -> MINUS factorF .)
    RETURN          reduce using rule 109 (factorT -> MINUS factorF .)
    READ            reduce using rule 109 (factorT -> MINUS factorF .)
    WRITE           reduce using rule 109 (factorT -> MINUS factorF .)
    IF              reduce using rule 109 (factorT -> MINUS factorF .)
    VAR             reduce using rule 109 (factorT -> MINUS factorF .)
    WHILE           reduce using rule 109 (factorT -> MINUS factorF .)
    FROM            reduce using rule 109 (factorT -> MINUS factorF .)
    R_CURPAR        reduce using rule 109 (factorT -> MINUS factorF .)
    SEMICOLON       reduce using rule 109 (factorT -> MINUS factorF .)
    DO              reduce using rule 109 (factorT -> MINUS factorF .)


state 199

    (111) factorF -> varcte empty .

    MULT            reduce using rule 111 (factorF -> varcte empty .)
    DIV             reduce using rule 111 (factorF -> varcte empty .)
    PLUS            reduce using rule 111 (factorF -> varcte empty .)
    MINUS           reduce using rule 111 (factorF -> varcte empty .)
    LESS            reduce using rule 111 (factorF -> varcte empty .)
    GREATER         reduce using rule 111 (factorF -> varcte empty .)
    LESS_TH         reduce using rule 111 (factorF -> varcte empty .)
    GREAT_TH        reduce using rule 111 (factorF -> varcte empty .)
    SAME            reduce using rule 111 (factorF -> varcte empty .)
    DIF             reduce using rule 111 (factorF -> varcte empty .)
    OR              reduce using rule 111 (factorF -> varcte empty .)
    AND             reduce using rule 111 (factorF -> varcte empty .)
    COMMA           reduce using rule 111 (factorF -> varcte empty .)
    R_PAR           reduce using rule 111 (factorF -> varcte empty .)
    R_BREAK         reduce using rule 111 (factorF -> varcte empty .)
    TO              reduce using rule 111 (factorF -> varcte empty .)
    ID              reduce using rule 111 (factorF -> varcte empty .)
    RETURN          reduce using rule 111 (factorF -> varcte empty .)
    READ            reduce using rule 111 (factorF -> varcte empty .)
    WRITE           reduce using rule 111 (factorF -> varcte empty .)
    IF              reduce using rule 111 (factorF -> varcte empty .)
    VAR             reduce using rule 111 (factorF -> varcte empty .)
    WHILE           reduce using rule 111 (factorF -> varcte empty .)
    FROM            reduce using rule 111 (factorF -> varcte empty .)
    R_CURPAR        reduce using rule 111 (factorF -> varcte empty .)
    SEMICOLON       reduce using rule 111 (factorF -> varcte empty .)
    DO              reduce using rule 111 (factorF -> varcte empty .)


state 200

    (112) varcte -> var np_addId . empty
    (116) empty -> .

    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 254

state 201

    (113) varcte -> CTE_INT empty .

    MULT            reduce using rule 113 (varcte -> CTE_INT empty .)
    DIV             reduce using rule 113 (varcte -> CTE_INT empty .)
    PLUS            reduce using rule 113 (varcte -> CTE_INT empty .)
    MINUS           reduce using rule 113 (varcte -> CTE_INT empty .)
    LESS            reduce using rule 113 (varcte -> CTE_INT empty .)
    GREATER         reduce using rule 113 (varcte -> CTE_INT empty .)
    LESS_TH         reduce using rule 113 (varcte -> CTE_INT empty .)
    GREAT_TH        reduce using rule 113 (varcte -> CTE_INT empty .)
    SAME            reduce using rule 113 (varcte -> CTE_INT empty .)
    DIF             reduce using rule 113 (varcte -> CTE_INT empty .)
    OR              reduce using rule 113 (varcte -> CTE_INT empty .)
    AND             reduce using rule 113 (varcte -> CTE_INT empty .)
    COMMA           reduce using rule 113 (varcte -> CTE_INT empty .)
    R_PAR           reduce using rule 113 (varcte -> CTE_INT empty .)
    R_BREAK         reduce using rule 113 (varcte -> CTE_INT empty .)
    TO              reduce using rule 113 (varcte -> CTE_INT empty .)
    ID              reduce using rule 113 (varcte -> CTE_INT empty .)
    RETURN          reduce using rule 113 (varcte -> CTE_INT empty .)
    READ            reduce using rule 113 (varcte -> CTE_INT empty .)
    WRITE           reduce using rule 113 (varcte -> CTE_INT empty .)
    IF              reduce using rule 113 (varcte -> CTE_INT empty .)
    VAR             reduce using rule 113 (varcte -> CTE_INT empty .)
    WHILE           reduce using rule 113 (varcte -> CTE_INT empty .)
    FROM            reduce using rule 113 (varcte -> CTE_INT empty .)
    R_CURPAR        reduce using rule 113 (varcte -> CTE_INT empty .)
    SEMICOLON       reduce using rule 113 (varcte -> CTE_INT empty .)
    DO              reduce using rule 113 (varcte -> CTE_INT empty .)


state 202

    (114) varcte -> CTE_FLOAT empty .

    MULT            reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    DIV             reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    PLUS            reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    MINUS           reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    LESS            reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    GREATER         reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    LESS_TH         reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    GREAT_TH        reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    SAME            reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    DIF             reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    OR              reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    AND             reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    COMMA           reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    R_PAR           reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    R_BREAK         reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    TO              reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    ID              reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    RETURN          reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    READ            reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    WRITE           reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    IF              reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    VAR             reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    WHILE           reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    FROM            reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    R_CURPAR        reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    SEMICOLON       reduce using rule 114 (varcte -> CTE_FLOAT empty .)
    DO              reduce using rule 114 (varcte -> CTE_FLOAT empty .)


state 203

    (115) varcte -> CTE_CHAR empty .

    MULT            reduce using rule 115 (varcte -> CTE_CHAR empty .)
    DIV             reduce using rule 115 (varcte -> CTE_CHAR empty .)
    PLUS            reduce using rule 115 (varcte -> CTE_CHAR empty .)
    MINUS           reduce using rule 115 (varcte -> CTE_CHAR empty .)
    LESS            reduce using rule 115 (varcte -> CTE_CHAR empty .)
    GREATER         reduce using rule 115 (varcte -> CTE_CHAR empty .)
    LESS_TH         reduce using rule 115 (varcte -> CTE_CHAR empty .)
    GREAT_TH        reduce using rule 115 (varcte -> CTE_CHAR empty .)
    SAME            reduce using rule 115 (varcte -> CTE_CHAR empty .)
    DIF             reduce using rule 115 (varcte -> CTE_CHAR empty .)
    OR              reduce using rule 115 (varcte -> CTE_CHAR empty .)
    AND             reduce using rule 115 (varcte -> CTE_CHAR empty .)
    COMMA           reduce using rule 115 (varcte -> CTE_CHAR empty .)
    R_PAR           reduce using rule 115 (varcte -> CTE_CHAR empty .)
    R_BREAK         reduce using rule 115 (varcte -> CTE_CHAR empty .)
    TO              reduce using rule 115 (varcte -> CTE_CHAR empty .)
    ID              reduce using rule 115 (varcte -> CTE_CHAR empty .)
    RETURN          reduce using rule 115 (varcte -> CTE_CHAR empty .)
    READ            reduce using rule 115 (varcte -> CTE_CHAR empty .)
    WRITE           reduce using rule 115 (varcte -> CTE_CHAR empty .)
    IF              reduce using rule 115 (varcte -> CTE_CHAR empty .)
    VAR             reduce using rule 115 (varcte -> CTE_CHAR empty .)
    WHILE           reduce using rule 115 (varcte -> CTE_CHAR empty .)
    FROM            reduce using rule 115 (varcte -> CTE_CHAR empty .)
    R_CURPAR        reduce using rule 115 (varcte -> CTE_CHAR empty .)
    SEMICOLON       reduce using rule 115 (varcte -> CTE_CHAR empty .)
    DO              reduce using rule 115 (varcte -> CTE_CHAR empty .)


state 204

    (56) return -> RETURN L_PAR exp R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 255


state 205

    (62) readF -> var COMMA . readF
    (62) readF -> . var COMMA readF
    (63) readF -> . var R_PAR SEMICOLON empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    VAR             shift and go to state 83
    ID              shift and go to state 139

    var                            shift and go to state 160
    readF                          shift and go to state 256

state 206

    (63) readF -> var R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 257


state 207

    (65) writeT -> CTE_CHAR writeF .

    ID              reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    RETURN          reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    READ            reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    WRITE           reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    IF              reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    VAR             reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    WHILE           reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    FROM            reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    R_CURPAR        reduce using rule 65 (writeT -> CTE_CHAR writeF .)
    SEMICOLON       reduce using rule 65 (writeT -> CTE_CHAR writeF .)


state 208

    (67) writeF -> COMMA . writeT
    (65) writeT -> . CTE_CHAR writeF
    (66) writeT -> . exp writeF
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    CTE_CHAR        shift and go to state 162
    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    VAR             shift and go to state 83
    ID              shift and go to state 139

    writeT                         shift and go to state 258
    exp                            shift and go to state 163
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 209

    (68) writeF -> R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 259


state 210

    (66) writeT -> exp writeF .

    ID              reduce using rule 66 (writeT -> exp writeF .)
    RETURN          reduce using rule 66 (writeT -> exp writeF .)
    READ            reduce using rule 66 (writeT -> exp writeF .)
    WRITE           reduce using rule 66 (writeT -> exp writeF .)
    IF              reduce using rule 66 (writeT -> exp writeF .)
    VAR             reduce using rule 66 (writeT -> exp writeF .)
    WHILE           reduce using rule 66 (writeT -> exp writeF .)
    FROM            reduce using rule 66 (writeT -> exp writeF .)
    R_CURPAR        reduce using rule 66 (writeT -> exp writeF .)
    SEMICOLON       reduce using rule 66 (writeT -> exp writeF .)


state 211

    (71) if -> IF L_PAR exp R_PAR . THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    THEN            shift and go to state 260


state 212

    (51) arrfunc -> L_BREAK exp COMMA . exp R_BREAK empty
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    exp                            shift and go to state 261
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 213

    (52) arrfunc -> L_BREAK exp R_BREAK . empty
    (116) empty -> .

    EQUAL           reduce using rule 116 (empty -> .)
    PLUS_EQ         reduce using rule 116 (empty -> .)
    MIN_EQ          reduce using rule 116 (empty -> .)
    MULT_EQ         reduce using rule 116 (empty -> .)
    DIV_EQ          reduce using rule 116 (empty -> .)
    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)
    L_PAR           reduce using rule 116 (empty -> .)
    CTE_INT         reduce using rule 116 (empty -> .)
    CTE_FLOAT       reduce using rule 116 (empty -> .)
    CTE_CHAR        reduce using rule 116 (empty -> .)

    empty                          shift and go to state 262

state 214

    (81) conditional -> WHILE L_PAR exp R_PAR . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 263


state 215

    (82) nonconditional -> FROM VAR arrfunc nonconditionalF .

    ID              reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    RETURN          reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    READ            reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WRITE           reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    IF              reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    VAR             reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WHILE           reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    FROM            reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    R_CURPAR        reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    SEMICOLON       reduce using rule 82 (nonconditional -> FROM VAR arrfunc nonconditionalF .)


state 216

    (84) nonconditionalF -> exp TO . exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (97) exp -> . bool empty
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    exp                            shift and go to state 264
    bool                           shift and go to state 144
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 217

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR . SEMICOLON empty

    SEMICOLON       shift and go to state 265


state 218

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec dec .

    MAIN            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    INT             reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    FLOAT           reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    CHAR            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    ID              reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    VOID            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    METHODS         reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    L_CURPAR        reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)


state 219

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic . empty
    (116) empty -> .

    MAIN            reduce using rule 116 (empty -> .)
    INT             reduce using rule 116 (empty -> .)
    FLOAT           reduce using rule 116 (empty -> .)
    CHAR            reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    VOID            reduce using rule 116 (empty -> .)
    METHODS         reduce using rule 116 (empty -> .)
    L_CURPAR        reduce using rule 116 (empty -> .)

    empty                          shift and go to state 266

state 220

    (24) funcF -> parameter R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 26

    dec                            shift and go to state 267

state 221

    (25) funcF -> R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 268


state 222

    (31) parameter -> VAR COLON typepar . SEMICOLON parameterF

    SEMICOLON       shift and go to state 269


state 223

    (34) typepar -> INT . empty
    (116) empty -> .

    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 270

state 224

    (35) typepar -> FLOAT . empty
    (116) empty -> .

    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 271

state 225

    (36) typepar -> CHAR . empty
    (116) empty -> .

    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 272

state 226

    (37) typepar -> ID . empty
    (116) empty -> .

    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 273

state 227

    (75) assigmentF -> EQUAL np_addOp exp . np_doAssign empty
    (131) np_doAssign -> .

    ID              reduce using rule 131 (np_doAssign -> .)
    RETURN          reduce using rule 131 (np_doAssign -> .)
    READ            reduce using rule 131 (np_doAssign -> .)
    WRITE           reduce using rule 131 (np_doAssign -> .)
    IF              reduce using rule 131 (np_doAssign -> .)
    VAR             reduce using rule 131 (np_doAssign -> .)
    WHILE           reduce using rule 131 (np_doAssign -> .)
    FROM            reduce using rule 131 (np_doAssign -> .)
    R_CURPAR        reduce using rule 131 (np_doAssign -> .)
    SEMICOLON       reduce using rule 131 (np_doAssign -> .)

    np_doAssign                    shift and go to state 274

state 228

    (76) assigmentF -> ope np_addOp exp . np_doAssign empty
    (131) np_doAssign -> .

    ID              reduce using rule 131 (np_doAssign -> .)
    RETURN          reduce using rule 131 (np_doAssign -> .)
    READ            reduce using rule 131 (np_doAssign -> .)
    WRITE           reduce using rule 131 (np_doAssign -> .)
    IF              reduce using rule 131 (np_doAssign -> .)
    VAR             reduce using rule 131 (np_doAssign -> .)
    WHILE           reduce using rule 131 (np_doAssign -> .)
    FROM            reduce using rule 131 (np_doAssign -> .)
    R_CURPAR        reduce using rule 131 (np_doAssign -> .)
    SEMICOLON       reduce using rule 131 (np_doAssign -> .)

    np_doAssign                    shift and go to state 275

state 229

    (48) void -> ID DOT ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 276


state 230

    (106) factor -> L_PAR np_addPar exp . R_PAR np_popPar empty

    R_PAR           shift and go to state 277


state 231

    (49) void -> ID L_PAR param R_PAR SEMICOLON . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 278

state 232

    (50) void -> ID L_PAR R_PAR SEMICOLON empty .

    ID              reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    READ            reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    IF              reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    VAR             reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    FROM            reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 50 (void -> ID L_PAR R_PAR SEMICOLON empty .)


state 233

    (54) paramF -> COMMA param .

    R_PAR           reduce using rule 54 (paramF -> COMMA param .)


state 234

    (85) bool -> logical np_addBool boolF .

    COMMA           reduce using rule 85 (bool -> logical np_addBool boolF .)
    R_PAR           reduce using rule 85 (bool -> logical np_addBool boolF .)
    R_BREAK         reduce using rule 85 (bool -> logical np_addBool boolF .)
    TO              reduce using rule 85 (bool -> logical np_addBool boolF .)
    ID              reduce using rule 85 (bool -> logical np_addBool boolF .)
    RETURN          reduce using rule 85 (bool -> logical np_addBool boolF .)
    READ            reduce using rule 85 (bool -> logical np_addBool boolF .)
    WRITE           reduce using rule 85 (bool -> logical np_addBool boolF .)
    IF              reduce using rule 85 (bool -> logical np_addBool boolF .)
    VAR             reduce using rule 85 (bool -> logical np_addBool boolF .)
    WHILE           reduce using rule 85 (bool -> logical np_addBool boolF .)
    FROM            reduce using rule 85 (bool -> logical np_addBool boolF .)
    R_CURPAR        reduce using rule 85 (bool -> logical np_addBool boolF .)
    SEMICOLON       reduce using rule 85 (bool -> logical np_addBool boolF .)
    DO              reduce using rule 85 (bool -> logical np_addBool boolF .)


state 235

    (86) boolF -> OR . np_addOp bool
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 279

state 236

    (87) boolF -> AND . np_addOp bool
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 280

state 237

    (88) boolF -> empty .

    COMMA           reduce using rule 88 (boolF -> empty .)
    R_PAR           reduce using rule 88 (boolF -> empty .)
    R_BREAK         reduce using rule 88 (boolF -> empty .)
    TO              reduce using rule 88 (boolF -> empty .)
    ID              reduce using rule 88 (boolF -> empty .)
    RETURN          reduce using rule 88 (boolF -> empty .)
    READ            reduce using rule 88 (boolF -> empty .)
    WRITE           reduce using rule 88 (boolF -> empty .)
    IF              reduce using rule 88 (boolF -> empty .)
    VAR             reduce using rule 88 (boolF -> empty .)
    WHILE           reduce using rule 88 (boolF -> empty .)
    FROM            reduce using rule 88 (boolF -> empty .)
    R_CURPAR        reduce using rule 88 (boolF -> empty .)
    SEMICOLON       reduce using rule 88 (boolF -> empty .)
    DO              reduce using rule 88 (boolF -> empty .)


state 238

    (89) logical -> ex np_addLogical logicalF .

    OR              reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    AND             reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    COMMA           reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    R_PAR           reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    R_BREAK         reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    TO              reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    ID              reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    RETURN          reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    READ            reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    WRITE           reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    IF              reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    VAR             reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    WHILE           reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    FROM            reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    R_CURPAR        reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    SEMICOLON       reduce using rule 89 (logical -> ex np_addLogical logicalF .)
    DO              reduce using rule 89 (logical -> ex np_addLogical logicalF .)


state 239

    (90) logicalF -> LESS . np_addOp logical
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 281

state 240

    (91) logicalF -> GREATER . np_addOp logical
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 282

state 241

    (92) logicalF -> LESS_TH . np_addOp logical
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 283

state 242

    (93) logicalF -> GREAT_TH . np_addOp logical
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 284

state 243

    (94) logicalF -> SAME . np_addOp logical
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 285

state 244

    (95) logicalF -> DIF . np_addOp logical
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 286

state 245

    (96) logicalF -> empty .

    OR              reduce using rule 96 (logicalF -> empty .)
    AND             reduce using rule 96 (logicalF -> empty .)
    COMMA           reduce using rule 96 (logicalF -> empty .)
    R_PAR           reduce using rule 96 (logicalF -> empty .)
    R_BREAK         reduce using rule 96 (logicalF -> empty .)
    TO              reduce using rule 96 (logicalF -> empty .)
    ID              reduce using rule 96 (logicalF -> empty .)
    RETURN          reduce using rule 96 (logicalF -> empty .)
    READ            reduce using rule 96 (logicalF -> empty .)
    WRITE           reduce using rule 96 (logicalF -> empty .)
    IF              reduce using rule 96 (logicalF -> empty .)
    VAR             reduce using rule 96 (logicalF -> empty .)
    WHILE           reduce using rule 96 (logicalF -> empty .)
    FROM            reduce using rule 96 (logicalF -> empty .)
    R_CURPAR        reduce using rule 96 (logicalF -> empty .)
    SEMICOLON       reduce using rule 96 (logicalF -> empty .)
    DO              reduce using rule 96 (logicalF -> empty .)


state 246

    (98) ex -> term np_addEx exF .

    LESS            reduce using rule 98 (ex -> term np_addEx exF .)
    GREATER         reduce using rule 98 (ex -> term np_addEx exF .)
    LESS_TH         reduce using rule 98 (ex -> term np_addEx exF .)
    GREAT_TH        reduce using rule 98 (ex -> term np_addEx exF .)
    SAME            reduce using rule 98 (ex -> term np_addEx exF .)
    DIF             reduce using rule 98 (ex -> term np_addEx exF .)
    OR              reduce using rule 98 (ex -> term np_addEx exF .)
    AND             reduce using rule 98 (ex -> term np_addEx exF .)
    COMMA           reduce using rule 98 (ex -> term np_addEx exF .)
    R_PAR           reduce using rule 98 (ex -> term np_addEx exF .)
    R_BREAK         reduce using rule 98 (ex -> term np_addEx exF .)
    TO              reduce using rule 98 (ex -> term np_addEx exF .)
    ID              reduce using rule 98 (ex -> term np_addEx exF .)
    RETURN          reduce using rule 98 (ex -> term np_addEx exF .)
    READ            reduce using rule 98 (ex -> term np_addEx exF .)
    WRITE           reduce using rule 98 (ex -> term np_addEx exF .)
    IF              reduce using rule 98 (ex -> term np_addEx exF .)
    VAR             reduce using rule 98 (ex -> term np_addEx exF .)
    WHILE           reduce using rule 98 (ex -> term np_addEx exF .)
    FROM            reduce using rule 98 (ex -> term np_addEx exF .)
    R_CURPAR        reduce using rule 98 (ex -> term np_addEx exF .)
    SEMICOLON       reduce using rule 98 (ex -> term np_addEx exF .)
    DO              reduce using rule 98 (ex -> term np_addEx exF .)


state 247

    (99) exF -> PLUS . np_addOp ex
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 287

state 248

    (100) exF -> MINUS . np_addOp ex
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 288

state 249

    (101) exF -> empty .

    LESS            reduce using rule 101 (exF -> empty .)
    GREATER         reduce using rule 101 (exF -> empty .)
    LESS_TH         reduce using rule 101 (exF -> empty .)
    GREAT_TH        reduce using rule 101 (exF -> empty .)
    SAME            reduce using rule 101 (exF -> empty .)
    DIF             reduce using rule 101 (exF -> empty .)
    OR              reduce using rule 101 (exF -> empty .)
    AND             reduce using rule 101 (exF -> empty .)
    COMMA           reduce using rule 101 (exF -> empty .)
    R_PAR           reduce using rule 101 (exF -> empty .)
    R_BREAK         reduce using rule 101 (exF -> empty .)
    TO              reduce using rule 101 (exF -> empty .)
    ID              reduce using rule 101 (exF -> empty .)
    RETURN          reduce using rule 101 (exF -> empty .)
    READ            reduce using rule 101 (exF -> empty .)
    WRITE           reduce using rule 101 (exF -> empty .)
    IF              reduce using rule 101 (exF -> empty .)
    VAR             reduce using rule 101 (exF -> empty .)
    WHILE           reduce using rule 101 (exF -> empty .)
    FROM            reduce using rule 101 (exF -> empty .)
    R_CURPAR        reduce using rule 101 (exF -> empty .)
    SEMICOLON       reduce using rule 101 (exF -> empty .)
    DO              reduce using rule 101 (exF -> empty .)


state 250

    (102) term -> factor np_addTerm termF .

    PLUS            reduce using rule 102 (term -> factor np_addTerm termF .)
    MINUS           reduce using rule 102 (term -> factor np_addTerm termF .)
    LESS            reduce using rule 102 (term -> factor np_addTerm termF .)
    GREATER         reduce using rule 102 (term -> factor np_addTerm termF .)
    LESS_TH         reduce using rule 102 (term -> factor np_addTerm termF .)
    GREAT_TH        reduce using rule 102 (term -> factor np_addTerm termF .)
    SAME            reduce using rule 102 (term -> factor np_addTerm termF .)
    DIF             reduce using rule 102 (term -> factor np_addTerm termF .)
    OR              reduce using rule 102 (term -> factor np_addTerm termF .)
    AND             reduce using rule 102 (term -> factor np_addTerm termF .)
    COMMA           reduce using rule 102 (term -> factor np_addTerm termF .)
    R_PAR           reduce using rule 102 (term -> factor np_addTerm termF .)
    R_BREAK         reduce using rule 102 (term -> factor np_addTerm termF .)
    TO              reduce using rule 102 (term -> factor np_addTerm termF .)
    ID              reduce using rule 102 (term -> factor np_addTerm termF .)
    RETURN          reduce using rule 102 (term -> factor np_addTerm termF .)
    READ            reduce using rule 102 (term -> factor np_addTerm termF .)
    WRITE           reduce using rule 102 (term -> factor np_addTerm termF .)
    IF              reduce using rule 102 (term -> factor np_addTerm termF .)
    VAR             reduce using rule 102 (term -> factor np_addTerm termF .)
    WHILE           reduce using rule 102 (term -> factor np_addTerm termF .)
    FROM            reduce using rule 102 (term -> factor np_addTerm termF .)
    R_CURPAR        reduce using rule 102 (term -> factor np_addTerm termF .)
    SEMICOLON       reduce using rule 102 (term -> factor np_addTerm termF .)
    DO              reduce using rule 102 (term -> factor np_addTerm termF .)


state 251

    (103) termF -> MULT . np_addOp term
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 289

state 252

    (104) termF -> DIV . np_addOp term
    (124) np_addOp -> .

    L_PAR           reduce using rule 124 (np_addOp -> .)
    PLUS            reduce using rule 124 (np_addOp -> .)
    MINUS           reduce using rule 124 (np_addOp -> .)
    CTE_INT         reduce using rule 124 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 124 (np_addOp -> .)
    CTE_CHAR        reduce using rule 124 (np_addOp -> .)
    VAR             reduce using rule 124 (np_addOp -> .)
    ID              reduce using rule 124 (np_addOp -> .)

    np_addOp                       shift and go to state 290

state 253

    (105) termF -> empty .

    PLUS            reduce using rule 105 (termF -> empty .)
    MINUS           reduce using rule 105 (termF -> empty .)
    LESS            reduce using rule 105 (termF -> empty .)
    GREATER         reduce using rule 105 (termF -> empty .)
    LESS_TH         reduce using rule 105 (termF -> empty .)
    GREAT_TH        reduce using rule 105 (termF -> empty .)
    SAME            reduce using rule 105 (termF -> empty .)
    DIF             reduce using rule 105 (termF -> empty .)
    OR              reduce using rule 105 (termF -> empty .)
    AND             reduce using rule 105 (termF -> empty .)
    COMMA           reduce using rule 105 (termF -> empty .)
    R_PAR           reduce using rule 105 (termF -> empty .)
    R_BREAK         reduce using rule 105 (termF -> empty .)
    TO              reduce using rule 105 (termF -> empty .)
    ID              reduce using rule 105 (termF -> empty .)
    RETURN          reduce using rule 105 (termF -> empty .)
    READ            reduce using rule 105 (termF -> empty .)
    WRITE           reduce using rule 105 (termF -> empty .)
    IF              reduce using rule 105 (termF -> empty .)
    VAR             reduce using rule 105 (termF -> empty .)
    WHILE           reduce using rule 105 (termF -> empty .)
    FROM            reduce using rule 105 (termF -> empty .)
    R_CURPAR        reduce using rule 105 (termF -> empty .)
    SEMICOLON       reduce using rule 105 (termF -> empty .)
    DO              reduce using rule 105 (termF -> empty .)


state 254

    (112) varcte -> var np_addId empty .

    MULT            reduce using rule 112 (varcte -> var np_addId empty .)
    DIV             reduce using rule 112 (varcte -> var np_addId empty .)
    PLUS            reduce using rule 112 (varcte -> var np_addId empty .)
    MINUS           reduce using rule 112 (varcte -> var np_addId empty .)
    LESS            reduce using rule 112 (varcte -> var np_addId empty .)
    GREATER         reduce using rule 112 (varcte -> var np_addId empty .)
    LESS_TH         reduce using rule 112 (varcte -> var np_addId empty .)
    GREAT_TH        reduce using rule 112 (varcte -> var np_addId empty .)
    SAME            reduce using rule 112 (varcte -> var np_addId empty .)
    DIF             reduce using rule 112 (varcte -> var np_addId empty .)
    OR              reduce using rule 112 (varcte -> var np_addId empty .)
    AND             reduce using rule 112 (varcte -> var np_addId empty .)
    COMMA           reduce using rule 112 (varcte -> var np_addId empty .)
    R_PAR           reduce using rule 112 (varcte -> var np_addId empty .)
    R_BREAK         reduce using rule 112 (varcte -> var np_addId empty .)
    TO              reduce using rule 112 (varcte -> var np_addId empty .)
    ID              reduce using rule 112 (varcte -> var np_addId empty .)
    RETURN          reduce using rule 112 (varcte -> var np_addId empty .)
    READ            reduce using rule 112 (varcte -> var np_addId empty .)
    WRITE           reduce using rule 112 (varcte -> var np_addId empty .)
    IF              reduce using rule 112 (varcte -> var np_addId empty .)
    VAR             reduce using rule 112 (varcte -> var np_addId empty .)
    WHILE           reduce using rule 112 (varcte -> var np_addId empty .)
    FROM            reduce using rule 112 (varcte -> var np_addId empty .)
    R_CURPAR        reduce using rule 112 (varcte -> var np_addId empty .)
    SEMICOLON       reduce using rule 112 (varcte -> var np_addId empty .)
    DO              reduce using rule 112 (varcte -> var np_addId empty .)


state 255

    (56) return -> RETURN L_PAR exp R_PAR SEMICOLON . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 291

state 256

    (62) readF -> var COMMA readF .

    ID              reduce using rule 62 (readF -> var COMMA readF .)
    RETURN          reduce using rule 62 (readF -> var COMMA readF .)
    READ            reduce using rule 62 (readF -> var COMMA readF .)
    WRITE           reduce using rule 62 (readF -> var COMMA readF .)
    IF              reduce using rule 62 (readF -> var COMMA readF .)
    VAR             reduce using rule 62 (readF -> var COMMA readF .)
    WHILE           reduce using rule 62 (readF -> var COMMA readF .)
    FROM            reduce using rule 62 (readF -> var COMMA readF .)
    R_CURPAR        reduce using rule 62 (readF -> var COMMA readF .)
    SEMICOLON       reduce using rule 62 (readF -> var COMMA readF .)


state 257

    (63) readF -> var R_PAR SEMICOLON . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 292

state 258

    (67) writeF -> COMMA writeT .

    ID              reduce using rule 67 (writeF -> COMMA writeT .)
    RETURN          reduce using rule 67 (writeF -> COMMA writeT .)
    READ            reduce using rule 67 (writeF -> COMMA writeT .)
    WRITE           reduce using rule 67 (writeF -> COMMA writeT .)
    IF              reduce using rule 67 (writeF -> COMMA writeT .)
    VAR             reduce using rule 67 (writeF -> COMMA writeT .)
    WHILE           reduce using rule 67 (writeF -> COMMA writeT .)
    FROM            reduce using rule 67 (writeF -> COMMA writeT .)
    R_CURPAR        reduce using rule 67 (writeF -> COMMA writeT .)
    SEMICOLON       reduce using rule 67 (writeF -> COMMA writeT .)


state 259

    (68) writeF -> R_PAR SEMICOLON . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 293

state 260

    (71) if -> IF L_PAR exp R_PAR THEN . L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_CURPAR        shift and go to state 294


state 261

    (51) arrfunc -> L_BREAK exp COMMA exp . R_BREAK empty

    R_BREAK         shift and go to state 295


state 262

    (52) arrfunc -> L_BREAK exp R_BREAK empty .

    EQUAL           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MIN_EQ          reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT_EQ         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV_EQ          reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV             reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MINUS           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREATER         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS_TH         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREAT_TH        reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SAME            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIF             reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    OR              reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    AND             reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    COMMA           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_PAR           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_BREAK         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    TO              reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    ID              reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    RETURN          reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    READ            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WRITE           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    IF              reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    VAR             reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WHILE           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    FROM            reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_CURPAR        reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SEMICOLON       reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DO              reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    L_PAR           reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_INT         reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 52 (arrfunc -> L_BREAK exp R_BREAK empty .)


state 263

    (81) conditional -> WHILE L_PAR exp R_PAR DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 296


state 264

    (84) nonconditionalF -> exp TO exp . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 297


state 265

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON . empty
    (116) empty -> .

    CLASS           reduce using rule 116 (empty -> .)
    VARS            reduce using rule 116 (empty -> .)
    MAIN            reduce using rule 116 (empty -> .)
    INT             reduce using rule 116 (empty -> .)
    FLOAT           reduce using rule 116 (empty -> .)
    CHAR            reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    VOID            reduce using rule 116 (empty -> .)

    empty                          shift and go to state 298

state 266

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .

    MAIN            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    INT             reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    FLOAT           reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    CHAR            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    ID              reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    VOID            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    METHODS         reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    L_CURPAR        reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)


state 267

    (24) funcF -> parameter R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 299


state 268

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 300
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 269

    (31) parameter -> VAR COLON typepar SEMICOLON . parameterF
    (32) parameterF -> . parameter
    (33) parameterF -> . empty
    (31) parameter -> . VAR COLON typepar SEMICOLON parameterF
    (116) empty -> .

    VAR             shift and go to state 128
    R_PAR           reduce using rule 116 (empty -> .)

    parameterF                     shift and go to state 301
    parameter                      shift and go to state 302
    empty                          shift and go to state 303

state 270

    (34) typepar -> INT empty .

    SEMICOLON       reduce using rule 34 (typepar -> INT empty .)


state 271

    (35) typepar -> FLOAT empty .

    SEMICOLON       reduce using rule 35 (typepar -> FLOAT empty .)


state 272

    (36) typepar -> CHAR empty .

    SEMICOLON       reduce using rule 36 (typepar -> CHAR empty .)


state 273

    (37) typepar -> ID empty .

    SEMICOLON       reduce using rule 37 (typepar -> ID empty .)


state 274

    (75) assigmentF -> EQUAL np_addOp exp np_doAssign . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 304

state 275

    (76) assigmentF -> ope np_addOp exp np_doAssign . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 305

state 276

    (48) void -> ID DOT ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 306


state 277

    (106) factor -> L_PAR np_addPar exp R_PAR . np_popPar empty
    (126) np_popPar -> .

    MULT            reduce using rule 126 (np_popPar -> .)
    DIV             reduce using rule 126 (np_popPar -> .)
    PLUS            reduce using rule 126 (np_popPar -> .)
    MINUS           reduce using rule 126 (np_popPar -> .)
    LESS            reduce using rule 126 (np_popPar -> .)
    GREATER         reduce using rule 126 (np_popPar -> .)
    LESS_TH         reduce using rule 126 (np_popPar -> .)
    GREAT_TH        reduce using rule 126 (np_popPar -> .)
    SAME            reduce using rule 126 (np_popPar -> .)
    DIF             reduce using rule 126 (np_popPar -> .)
    OR              reduce using rule 126 (np_popPar -> .)
    AND             reduce using rule 126 (np_popPar -> .)
    COMMA           reduce using rule 126 (np_popPar -> .)
    R_PAR           reduce using rule 126 (np_popPar -> .)
    R_BREAK         reduce using rule 126 (np_popPar -> .)
    TO              reduce using rule 126 (np_popPar -> .)
    ID              reduce using rule 126 (np_popPar -> .)
    RETURN          reduce using rule 126 (np_popPar -> .)
    READ            reduce using rule 126 (np_popPar -> .)
    WRITE           reduce using rule 126 (np_popPar -> .)
    IF              reduce using rule 126 (np_popPar -> .)
    VAR             reduce using rule 126 (np_popPar -> .)
    WHILE           reduce using rule 126 (np_popPar -> .)
    FROM            reduce using rule 126 (np_popPar -> .)
    R_CURPAR        reduce using rule 126 (np_popPar -> .)
    SEMICOLON       reduce using rule 126 (np_popPar -> .)
    DO              reduce using rule 126 (np_popPar -> .)

    np_popPar                      shift and go to state 307

state 278

    (49) void -> ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 49 (void -> ID L_PAR param R_PAR SEMICOLON empty .)


state 279

    (86) boolF -> OR np_addOp . bool
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    bool                           shift and go to state 308
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 280

    (87) boolF -> AND np_addOp . bool
    (85) bool -> . logical np_addBool boolF
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    bool                           shift and go to state 309
    logical                        shift and go to state 145
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 281

    (90) logicalF -> LESS np_addOp . logical
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    logical                        shift and go to state 310
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 282

    (91) logicalF -> GREATER np_addOp . logical
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    logical                        shift and go to state 311
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 283

    (92) logicalF -> LESS_TH np_addOp . logical
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    logical                        shift and go to state 312
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 284

    (93) logicalF -> GREAT_TH np_addOp . logical
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    logical                        shift and go to state 313
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 285

    (94) logicalF -> SAME np_addOp . logical
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    logical                        shift and go to state 314
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 286

    (95) logicalF -> DIF np_addOp . logical
    (89) logical -> . ex np_addLogical logicalF
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    logical                        shift and go to state 315
    ex                             shift and go to state 146
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 287

    (99) exF -> PLUS np_addOp . ex
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    ex                             shift and go to state 316
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 288

    (100) exF -> MINUS np_addOp . ex
    (98) ex -> . term np_addEx exF
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    ex                             shift and go to state 317
    term                           shift and go to state 147
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 289

    (103) termF -> MULT np_addOp . term
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    term                           shift and go to state 318
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 290

    (104) termF -> DIV np_addOp . term
    (102) term -> . factor np_addTerm termF
    (106) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (107) factor -> . factorT
    (108) factorT -> . PLUS factorF
    (109) factorT -> . MINUS factorF
    (110) factorT -> . factorF
    (111) factorF -> . varcte empty
    (112) varcte -> . var np_addId empty
    (113) varcte -> . CTE_INT empty
    (114) varcte -> . CTE_FLOAT empty
    (115) varcte -> . CTE_CHAR empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 140
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    CTE_INT         shift and go to state 155
    CTE_FLOAT       shift and go to state 156
    CTE_CHAR        shift and go to state 157
    VAR             shift and go to state 83
    ID              shift and go to state 139

    term                           shift and go to state 319
    factor                         shift and go to state 148
    factorT                        shift and go to state 149
    factorF                        shift and go to state 151
    varcte                         shift and go to state 153
    var                            shift and go to state 154

state 291

    (56) return -> RETURN L_PAR exp R_PAR SEMICOLON empty .

    ID              reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    READ            reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    IF              reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    VAR             reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    FROM            reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 56 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)


state 292

    (63) readF -> var R_PAR SEMICOLON empty .

    ID              reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    READ            reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    IF              reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    VAR             reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    FROM            reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 63 (readF -> var R_PAR SEMICOLON empty .)


state 293

    (68) writeF -> R_PAR SEMICOLON empty .

    ID              reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    READ            reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    IF              reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    VAR             reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    FROM            reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 68 (writeF -> R_PAR SEMICOLON empty .)


state 294

    (71) if -> IF L_PAR exp R_PAR THEN L_CURPAR . statement SEMICOLON R_CURPAR ifF
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 320
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 295

    (51) arrfunc -> L_BREAK exp COMMA exp R_BREAK . empty
    (116) empty -> .

    EQUAL           reduce using rule 116 (empty -> .)
    PLUS_EQ         reduce using rule 116 (empty -> .)
    MIN_EQ          reduce using rule 116 (empty -> .)
    MULT_EQ         reduce using rule 116 (empty -> .)
    DIV_EQ          reduce using rule 116 (empty -> .)
    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)
    L_PAR           reduce using rule 116 (empty -> .)
    CTE_INT         reduce using rule 116 (empty -> .)
    CTE_FLOAT       reduce using rule 116 (empty -> .)
    CTE_CHAR        reduce using rule 116 (empty -> .)

    empty                          shift and go to state 321

state 296

    (81) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 322
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 297

    (84) nonconditionalF -> exp TO exp DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 323


state 298

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .

    CLASS           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VARS            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    MAIN            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    INT             reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    FLOAT           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    CHAR            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    ID              reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VOID            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)


state 299

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 324
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 300

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 325


state 301

    (31) parameter -> VAR COLON typepar SEMICOLON parameterF .

    R_PAR           reduce using rule 31 (parameter -> VAR COLON typepar SEMICOLON parameterF .)


state 302

    (32) parameterF -> parameter .

    R_PAR           reduce using rule 32 (parameterF -> parameter .)


state 303

    (33) parameterF -> empty .

    R_PAR           reduce using rule 33 (parameterF -> empty .)


state 304

    (75) assigmentF -> EQUAL np_addOp exp np_doAssign empty .

    ID              reduce using rule 75 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    RETURN          reduce using rule 75 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    READ            reduce using rule 75 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    WRITE           reduce using rule 75 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    IF              reduce using rule 75 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    VAR             reduce using rule 75 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    WHILE           reduce using rule 75 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    FROM            reduce using rule 75 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    R_CURPAR        reduce using rule 75 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    SEMICOLON       reduce using rule 75 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)


state 305

    (76) assigmentF -> ope np_addOp exp np_doAssign empty .

    ID              reduce using rule 76 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    RETURN          reduce using rule 76 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    READ            reduce using rule 76 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    WRITE           reduce using rule 76 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    IF              reduce using rule 76 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    VAR             reduce using rule 76 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    WHILE           reduce using rule 76 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    FROM            reduce using rule 76 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    R_CURPAR        reduce using rule 76 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    SEMICOLON       reduce using rule 76 (assigmentF -> ope np_addOp exp np_doAssign empty .)


state 306

    (48) void -> ID DOT ID L_PAR param R_PAR SEMICOLON . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 326

state 307

    (106) factor -> L_PAR np_addPar exp R_PAR np_popPar . empty
    (116) empty -> .

    MULT            reduce using rule 116 (empty -> .)
    DIV             reduce using rule 116 (empty -> .)
    PLUS            reduce using rule 116 (empty -> .)
    MINUS           reduce using rule 116 (empty -> .)
    LESS            reduce using rule 116 (empty -> .)
    GREATER         reduce using rule 116 (empty -> .)
    LESS_TH         reduce using rule 116 (empty -> .)
    GREAT_TH        reduce using rule 116 (empty -> .)
    SAME            reduce using rule 116 (empty -> .)
    DIF             reduce using rule 116 (empty -> .)
    OR              reduce using rule 116 (empty -> .)
    AND             reduce using rule 116 (empty -> .)
    COMMA           reduce using rule 116 (empty -> .)
    R_PAR           reduce using rule 116 (empty -> .)
    R_BREAK         reduce using rule 116 (empty -> .)
    TO              reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)
    DO              reduce using rule 116 (empty -> .)

    empty                          shift and go to state 327

state 308

    (86) boolF -> OR np_addOp bool .

    COMMA           reduce using rule 86 (boolF -> OR np_addOp bool .)
    R_PAR           reduce using rule 86 (boolF -> OR np_addOp bool .)
    R_BREAK         reduce using rule 86 (boolF -> OR np_addOp bool .)
    TO              reduce using rule 86 (boolF -> OR np_addOp bool .)
    ID              reduce using rule 86 (boolF -> OR np_addOp bool .)
    RETURN          reduce using rule 86 (boolF -> OR np_addOp bool .)
    READ            reduce using rule 86 (boolF -> OR np_addOp bool .)
    WRITE           reduce using rule 86 (boolF -> OR np_addOp bool .)
    IF              reduce using rule 86 (boolF -> OR np_addOp bool .)
    VAR             reduce using rule 86 (boolF -> OR np_addOp bool .)
    WHILE           reduce using rule 86 (boolF -> OR np_addOp bool .)
    FROM            reduce using rule 86 (boolF -> OR np_addOp bool .)
    R_CURPAR        reduce using rule 86 (boolF -> OR np_addOp bool .)
    SEMICOLON       reduce using rule 86 (boolF -> OR np_addOp bool .)
    DO              reduce using rule 86 (boolF -> OR np_addOp bool .)


state 309

    (87) boolF -> AND np_addOp bool .

    COMMA           reduce using rule 87 (boolF -> AND np_addOp bool .)
    R_PAR           reduce using rule 87 (boolF -> AND np_addOp bool .)
    R_BREAK         reduce using rule 87 (boolF -> AND np_addOp bool .)
    TO              reduce using rule 87 (boolF -> AND np_addOp bool .)
    ID              reduce using rule 87 (boolF -> AND np_addOp bool .)
    RETURN          reduce using rule 87 (boolF -> AND np_addOp bool .)
    READ            reduce using rule 87 (boolF -> AND np_addOp bool .)
    WRITE           reduce using rule 87 (boolF -> AND np_addOp bool .)
    IF              reduce using rule 87 (boolF -> AND np_addOp bool .)
    VAR             reduce using rule 87 (boolF -> AND np_addOp bool .)
    WHILE           reduce using rule 87 (boolF -> AND np_addOp bool .)
    FROM            reduce using rule 87 (boolF -> AND np_addOp bool .)
    R_CURPAR        reduce using rule 87 (boolF -> AND np_addOp bool .)
    SEMICOLON       reduce using rule 87 (boolF -> AND np_addOp bool .)
    DO              reduce using rule 87 (boolF -> AND np_addOp bool .)


state 310

    (90) logicalF -> LESS np_addOp logical .

    OR              reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    AND             reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    COMMA           reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    R_PAR           reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    R_BREAK         reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    TO              reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    ID              reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    RETURN          reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    READ            reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    WRITE           reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    IF              reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    VAR             reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    WHILE           reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    FROM            reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    R_CURPAR        reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    SEMICOLON       reduce using rule 90 (logicalF -> LESS np_addOp logical .)
    DO              reduce using rule 90 (logicalF -> LESS np_addOp logical .)


state 311

    (91) logicalF -> GREATER np_addOp logical .

    OR              reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    AND             reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    COMMA           reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    R_PAR           reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    R_BREAK         reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    TO              reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    ID              reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    RETURN          reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    READ            reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    WRITE           reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    IF              reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    VAR             reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    WHILE           reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    FROM            reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    R_CURPAR        reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    SEMICOLON       reduce using rule 91 (logicalF -> GREATER np_addOp logical .)
    DO              reduce using rule 91 (logicalF -> GREATER np_addOp logical .)


state 312

    (92) logicalF -> LESS_TH np_addOp logical .

    OR              reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    AND             reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    COMMA           reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    R_PAR           reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    R_BREAK         reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    TO              reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    ID              reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    RETURN          reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    READ            reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    WRITE           reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    IF              reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    VAR             reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    WHILE           reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    FROM            reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    R_CURPAR        reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    SEMICOLON       reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)
    DO              reduce using rule 92 (logicalF -> LESS_TH np_addOp logical .)


state 313

    (93) logicalF -> GREAT_TH np_addOp logical .

    OR              reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    AND             reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    COMMA           reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    R_PAR           reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    R_BREAK         reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    TO              reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    ID              reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    RETURN          reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    READ            reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    WRITE           reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    IF              reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    VAR             reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    WHILE           reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    FROM            reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    R_CURPAR        reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    SEMICOLON       reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)
    DO              reduce using rule 93 (logicalF -> GREAT_TH np_addOp logical .)


state 314

    (94) logicalF -> SAME np_addOp logical .

    OR              reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    AND             reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    COMMA           reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    R_PAR           reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    R_BREAK         reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    TO              reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    ID              reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    RETURN          reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    READ            reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    WRITE           reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    IF              reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    VAR             reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    WHILE           reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    FROM            reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    R_CURPAR        reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    SEMICOLON       reduce using rule 94 (logicalF -> SAME np_addOp logical .)
    DO              reduce using rule 94 (logicalF -> SAME np_addOp logical .)


state 315

    (95) logicalF -> DIF np_addOp logical .

    OR              reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    AND             reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    COMMA           reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    R_PAR           reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    R_BREAK         reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    TO              reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    ID              reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    RETURN          reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    READ            reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    WRITE           reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    IF              reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    VAR             reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    WHILE           reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    FROM            reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    R_CURPAR        reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    SEMICOLON       reduce using rule 95 (logicalF -> DIF np_addOp logical .)
    DO              reduce using rule 95 (logicalF -> DIF np_addOp logical .)


state 316

    (99) exF -> PLUS np_addOp ex .

    LESS            reduce using rule 99 (exF -> PLUS np_addOp ex .)
    GREATER         reduce using rule 99 (exF -> PLUS np_addOp ex .)
    LESS_TH         reduce using rule 99 (exF -> PLUS np_addOp ex .)
    GREAT_TH        reduce using rule 99 (exF -> PLUS np_addOp ex .)
    SAME            reduce using rule 99 (exF -> PLUS np_addOp ex .)
    DIF             reduce using rule 99 (exF -> PLUS np_addOp ex .)
    OR              reduce using rule 99 (exF -> PLUS np_addOp ex .)
    AND             reduce using rule 99 (exF -> PLUS np_addOp ex .)
    COMMA           reduce using rule 99 (exF -> PLUS np_addOp ex .)
    R_PAR           reduce using rule 99 (exF -> PLUS np_addOp ex .)
    R_BREAK         reduce using rule 99 (exF -> PLUS np_addOp ex .)
    TO              reduce using rule 99 (exF -> PLUS np_addOp ex .)
    ID              reduce using rule 99 (exF -> PLUS np_addOp ex .)
    RETURN          reduce using rule 99 (exF -> PLUS np_addOp ex .)
    READ            reduce using rule 99 (exF -> PLUS np_addOp ex .)
    WRITE           reduce using rule 99 (exF -> PLUS np_addOp ex .)
    IF              reduce using rule 99 (exF -> PLUS np_addOp ex .)
    VAR             reduce using rule 99 (exF -> PLUS np_addOp ex .)
    WHILE           reduce using rule 99 (exF -> PLUS np_addOp ex .)
    FROM            reduce using rule 99 (exF -> PLUS np_addOp ex .)
    R_CURPAR        reduce using rule 99 (exF -> PLUS np_addOp ex .)
    SEMICOLON       reduce using rule 99 (exF -> PLUS np_addOp ex .)
    DO              reduce using rule 99 (exF -> PLUS np_addOp ex .)


state 317

    (100) exF -> MINUS np_addOp ex .

    LESS            reduce using rule 100 (exF -> MINUS np_addOp ex .)
    GREATER         reduce using rule 100 (exF -> MINUS np_addOp ex .)
    LESS_TH         reduce using rule 100 (exF -> MINUS np_addOp ex .)
    GREAT_TH        reduce using rule 100 (exF -> MINUS np_addOp ex .)
    SAME            reduce using rule 100 (exF -> MINUS np_addOp ex .)
    DIF             reduce using rule 100 (exF -> MINUS np_addOp ex .)
    OR              reduce using rule 100 (exF -> MINUS np_addOp ex .)
    AND             reduce using rule 100 (exF -> MINUS np_addOp ex .)
    COMMA           reduce using rule 100 (exF -> MINUS np_addOp ex .)
    R_PAR           reduce using rule 100 (exF -> MINUS np_addOp ex .)
    R_BREAK         reduce using rule 100 (exF -> MINUS np_addOp ex .)
    TO              reduce using rule 100 (exF -> MINUS np_addOp ex .)
    ID              reduce using rule 100 (exF -> MINUS np_addOp ex .)
    RETURN          reduce using rule 100 (exF -> MINUS np_addOp ex .)
    READ            reduce using rule 100 (exF -> MINUS np_addOp ex .)
    WRITE           reduce using rule 100 (exF -> MINUS np_addOp ex .)
    IF              reduce using rule 100 (exF -> MINUS np_addOp ex .)
    VAR             reduce using rule 100 (exF -> MINUS np_addOp ex .)
    WHILE           reduce using rule 100 (exF -> MINUS np_addOp ex .)
    FROM            reduce using rule 100 (exF -> MINUS np_addOp ex .)
    R_CURPAR        reduce using rule 100 (exF -> MINUS np_addOp ex .)
    SEMICOLON       reduce using rule 100 (exF -> MINUS np_addOp ex .)
    DO              reduce using rule 100 (exF -> MINUS np_addOp ex .)


state 318

    (103) termF -> MULT np_addOp term .

    PLUS            reduce using rule 103 (termF -> MULT np_addOp term .)
    MINUS           reduce using rule 103 (termF -> MULT np_addOp term .)
    LESS            reduce using rule 103 (termF -> MULT np_addOp term .)
    GREATER         reduce using rule 103 (termF -> MULT np_addOp term .)
    LESS_TH         reduce using rule 103 (termF -> MULT np_addOp term .)
    GREAT_TH        reduce using rule 103 (termF -> MULT np_addOp term .)
    SAME            reduce using rule 103 (termF -> MULT np_addOp term .)
    DIF             reduce using rule 103 (termF -> MULT np_addOp term .)
    OR              reduce using rule 103 (termF -> MULT np_addOp term .)
    AND             reduce using rule 103 (termF -> MULT np_addOp term .)
    COMMA           reduce using rule 103 (termF -> MULT np_addOp term .)
    R_PAR           reduce using rule 103 (termF -> MULT np_addOp term .)
    R_BREAK         reduce using rule 103 (termF -> MULT np_addOp term .)
    TO              reduce using rule 103 (termF -> MULT np_addOp term .)
    ID              reduce using rule 103 (termF -> MULT np_addOp term .)
    RETURN          reduce using rule 103 (termF -> MULT np_addOp term .)
    READ            reduce using rule 103 (termF -> MULT np_addOp term .)
    WRITE           reduce using rule 103 (termF -> MULT np_addOp term .)
    IF              reduce using rule 103 (termF -> MULT np_addOp term .)
    VAR             reduce using rule 103 (termF -> MULT np_addOp term .)
    WHILE           reduce using rule 103 (termF -> MULT np_addOp term .)
    FROM            reduce using rule 103 (termF -> MULT np_addOp term .)
    R_CURPAR        reduce using rule 103 (termF -> MULT np_addOp term .)
    SEMICOLON       reduce using rule 103 (termF -> MULT np_addOp term .)
    DO              reduce using rule 103 (termF -> MULT np_addOp term .)


state 319

    (104) termF -> DIV np_addOp term .

    PLUS            reduce using rule 104 (termF -> DIV np_addOp term .)
    MINUS           reduce using rule 104 (termF -> DIV np_addOp term .)
    LESS            reduce using rule 104 (termF -> DIV np_addOp term .)
    GREATER         reduce using rule 104 (termF -> DIV np_addOp term .)
    LESS_TH         reduce using rule 104 (termF -> DIV np_addOp term .)
    GREAT_TH        reduce using rule 104 (termF -> DIV np_addOp term .)
    SAME            reduce using rule 104 (termF -> DIV np_addOp term .)
    DIF             reduce using rule 104 (termF -> DIV np_addOp term .)
    OR              reduce using rule 104 (termF -> DIV np_addOp term .)
    AND             reduce using rule 104 (termF -> DIV np_addOp term .)
    COMMA           reduce using rule 104 (termF -> DIV np_addOp term .)
    R_PAR           reduce using rule 104 (termF -> DIV np_addOp term .)
    R_BREAK         reduce using rule 104 (termF -> DIV np_addOp term .)
    TO              reduce using rule 104 (termF -> DIV np_addOp term .)
    ID              reduce using rule 104 (termF -> DIV np_addOp term .)
    RETURN          reduce using rule 104 (termF -> DIV np_addOp term .)
    READ            reduce using rule 104 (termF -> DIV np_addOp term .)
    WRITE           reduce using rule 104 (termF -> DIV np_addOp term .)
    IF              reduce using rule 104 (termF -> DIV np_addOp term .)
    VAR             reduce using rule 104 (termF -> DIV np_addOp term .)
    WHILE           reduce using rule 104 (termF -> DIV np_addOp term .)
    FROM            reduce using rule 104 (termF -> DIV np_addOp term .)
    R_CURPAR        reduce using rule 104 (termF -> DIV np_addOp term .)
    SEMICOLON       reduce using rule 104 (termF -> DIV np_addOp term .)
    DO              reduce using rule 104 (termF -> DIV np_addOp term .)


state 320

    (71) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement . SEMICOLON R_CURPAR ifF

    SEMICOLON       shift and go to state 328


state 321

    (51) arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .

    EQUAL           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MIN_EQ          reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT_EQ         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV_EQ          reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV             reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MINUS           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREATER         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS_TH         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREAT_TH        reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SAME            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIF             reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    OR              reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    AND             reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    COMMA           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_PAR           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_BREAK         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    TO              reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    ID              reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    RETURN          reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    READ            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WRITE           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    IF              reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    VAR             reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WHILE           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    FROM            reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_CURPAR        reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SEMICOLON       reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DO              reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    L_PAR           reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_INT         reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 51 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)


state 322

    (81) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 329


state 323

    (84) nonconditionalF -> exp TO exp DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 330
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 324

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 331


state 325

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (116) empty -> .

    MAIN            reduce using rule 116 (empty -> .)
    INT             reduce using rule 116 (empty -> .)
    FLOAT           reduce using rule 116 (empty -> .)
    CHAR            reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    VOID            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)

    empty                          shift and go to state 332

state 326

    (48) void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 48 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)


state 327

    (106) factor -> L_PAR np_addPar exp R_PAR np_popPar empty .

    MULT            reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIV             reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    PLUS            reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    MINUS           reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS            reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREATER         reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS_TH         reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREAT_TH        reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SAME            reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIF             reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    OR              reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    AND             reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    COMMA           reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_PAR           reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_BREAK         reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    TO              reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    ID              reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    RETURN          reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    READ            reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    WRITE           reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    IF              reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    VAR             reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    WHILE           reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    FROM            reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_CURPAR        reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SEMICOLON       reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DO              reduce using rule 106 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)


state 328

    (71) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON . R_CURPAR ifF

    R_CURPAR        shift and go to state 333


state 329

    (81) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 334


state 330

    (84) nonconditionalF -> exp TO exp DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 335


state 331

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (116) empty -> .

    MAIN            reduce using rule 116 (empty -> .)
    INT             reduce using rule 116 (empty -> .)
    FLOAT           reduce using rule 116 (empty -> .)
    CHAR            reduce using rule 116 (empty -> .)
    ID              reduce using rule 116 (empty -> .)
    VOID            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)

    empty                          shift and go to state 336

state 332

    (25) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 25 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 333

    (71) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR . ifF
    (72) ifF -> . ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
    (73) ifF -> . empty
    (116) empty -> .

    ELSE            shift and go to state 338
    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    ifF                            shift and go to state 337
    empty                          shift and go to state 339

state 334

    (81) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 340

state 335

    (84) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 341


state 336

    (24) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 24 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 337

    (71) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .

    ID              reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    RETURN          reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    READ            reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WRITE           reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    IF              reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    VAR             reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WHILE           reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    FROM            reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    R_CURPAR        reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    SEMICOLON       reduce using rule 71 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)


state 338

    (72) ifF -> ELSE . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 342


state 339

    (73) ifF -> empty .

    ID              reduce using rule 73 (ifF -> empty .)
    RETURN          reduce using rule 73 (ifF -> empty .)
    READ            reduce using rule 73 (ifF -> empty .)
    WRITE           reduce using rule 73 (ifF -> empty .)
    IF              reduce using rule 73 (ifF -> empty .)
    VAR             reduce using rule 73 (ifF -> empty .)
    WHILE           reduce using rule 73 (ifF -> empty .)
    FROM            reduce using rule 73 (ifF -> empty .)
    R_CURPAR        reduce using rule 73 (ifF -> empty .)
    SEMICOLON       reduce using rule 73 (ifF -> empty .)


state 340

    (81) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 81 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 341

    (84) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 343

state 342

    (72) ifF -> ELSE L_CURPAR . statement SEMICOLON R_CURPAR empty
    (39) statement -> . assigment statementF
    (40) statement -> . void statementF
    (41) statement -> . return statementF
    (42) statement -> . read statementF
    (43) statement -> . write statementF
    (44) statement -> . if statementF
    (45) statement -> . repeat statementF
    (74) assigment -> . var np_addId assigmentF
    (48) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (49) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (50) void -> . ID L_PAR R_PAR SEMICOLON empty
    (56) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (61) read -> . READ L_PAR readF
    (64) write -> . WRITE L_PAR writeT
    (71) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (69) repeat -> . conditional empty
    (70) repeat -> . nonconditional empty
    (57) var -> . VAR varF
    (58) var -> . ID DOT VAR varF
    (81) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (82) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (83) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 76
    RETURN          shift and go to state 77
    READ            shift and go to state 78
    WRITE           shift and go to state 79
    IF              shift and go to state 80
    VAR             shift and go to state 83
    WHILE           shift and go to state 84
    FROM            shift and go to state 85

    statement                      shift and go to state 344
    assigment                      shift and go to state 68
    void                           shift and go to state 69
    return                         shift and go to state 70
    read                           shift and go to state 71
    write                          shift and go to state 72
    if                             shift and go to state 73
    repeat                         shift and go to state 74
    var                            shift and go to state 75
    conditional                    shift and go to state 81
    nonconditional                 shift and go to state 82

state 343

    (84) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 84 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 344

    (72) ifF -> ELSE L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 345


state 345

    (72) ifF -> ELSE L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 346


state 346

    (72) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR . empty
    (116) empty -> .

    ID              reduce using rule 116 (empty -> .)
    RETURN          reduce using rule 116 (empty -> .)
    READ            reduce using rule 116 (empty -> .)
    WRITE           reduce using rule 116 (empty -> .)
    IF              reduce using rule 116 (empty -> .)
    VAR             reduce using rule 116 (empty -> .)
    WHILE           reduce using rule 116 (empty -> .)
    FROM            reduce using rule 116 (empty -> .)
    R_CURPAR        reduce using rule 116 (empty -> .)
    SEMICOLON       reduce using rule 116 (empty -> .)

    empty                          shift and go to state 347

state 347

    (72) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 72 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 162 resolved as shift
WARNING: shift/reduce conflict for R_PAR in state 162 resolved as shift
