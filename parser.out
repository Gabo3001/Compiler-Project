Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID np_getcurrFunc SEMICOLON programT
Rule 2     programT -> class programT
Rule 3     programT -> vars programF
Rule 4     programT -> programF
Rule 5     programF -> func programF
Rule 6     programF -> main empty
Rule 7     class -> CLASS ID classT
Rule 8     classT -> LESS INHERIT ID GREATER classF
Rule 9     classT -> classF
Rule 10    classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty
Rule 11    vars -> VARS dec np_AddFunc empty
Rule 12    dec -> VAR arr np_getDecArr decF
Rule 13    dec -> VAR np_getDec decF
Rule 14    decF -> COMMA dec
Rule 15    decF -> COLON type np_getVarType SEMICOLON np_getDec dec
Rule 16    decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty
Rule 17    type -> INT empty
Rule 18    type -> FLOAT empty
Rule 19    type -> CHAR empty
Rule 20    type -> BOOL empty
Rule 21    type -> ID empty
Rule 22    arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
Rule 23    arr -> L_BREAK CTE_INT R_BREAK empty
Rule 24    func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
Rule 25    funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 26    funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
Rule 27    typeFunc -> INT empty
Rule 28    typeFunc -> FLOAT empty
Rule 29    typeFunc -> CHAR empty
Rule 30    typeFunc -> BOOL empty
Rule 31    typeFunc -> ID empty
Rule 32    typeFunc -> VOID empty
Rule 33    parameter -> VAR COLON typepar SEMICOLON parameterF
Rule 34    parameterF -> parameter
Rule 35    parameterF -> empty
Rule 36    typepar -> INT empty
Rule 37    typepar -> FLOAT empty
Rule 38    typepar -> CHAR empty
Rule 39    typepar -> BOOL empty
Rule 40    typepar -> ID empty
Rule 41    main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
Rule 42    statement -> assigment statementF
Rule 43    statement -> void statementF
Rule 44    statement -> return statementF
Rule 45    statement -> read statementF
Rule 46    statement -> write statementF
Rule 47    statement -> if statementF
Rule 48    statement -> repeat statementF
Rule 49    statementF -> statement
Rule 50    statementF -> empty
Rule 51    void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty
Rule 52    void -> ID L_PAR param R_PAR SEMICOLON empty
Rule 53    void -> ID L_PAR R_PAR SEMICOLON empty
Rule 54    arrfunc -> L_BREAK exp COMMA exp R_BREAK empty
Rule 55    arrfunc -> L_BREAK exp R_BREAK empty
Rule 56    param -> exp paramF
Rule 57    paramF -> COMMA param
Rule 58    paramF -> empty
Rule 59    return -> RETURN L_PAR exp R_PAR SEMICOLON empty
Rule 60    var -> VAR varF
Rule 61    var -> ID DOT VAR varF
Rule 62    varF -> arrfunc empty
Rule 63    varF -> empty
Rule 64    read -> READ L_PAR readF
Rule 65    readF -> var np_addRead COMMA readF
Rule 66    readF -> var np_addRead R_PAR SEMICOLON empty
Rule 67    write -> WRITE L_PAR writeT
Rule 68    writeT -> CTE_STRING writeF
Rule 69    writeT -> exp writeF
Rule 70    writeF -> COMMA writeT
Rule 71    writeF -> R_PAR SEMICOLON empty
Rule 72    repeat -> conditional empty
Rule 73    repeat -> nonconditional empty
Rule 74    if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
Rule 75    ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 76    ifF -> empty
Rule 77    assigment -> var np_addId assigmentF
Rule 78    assigmentF -> EQUAL np_addOp exp np_doAssign empty
Rule 79    assigmentF -> ope np_addOp exp np_doAssign empty
Rule 80    ope -> PLUS_EQ empty
Rule 81    ope -> MIN_EQ empty
Rule 82    ope -> MULT_EQ empty
Rule 83    ope -> DIV_EQ empty
Rule 84    conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 85    nonconditional -> FROM VAR arrfunc nonconditionalF
Rule 86    nonconditional -> FROM VAR nonconditionalF
Rule 87    nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
Rule 88    bool -> logical np_addBool boolF
Rule 89    boolF -> OR np_addOp bool
Rule 90    boolF -> AND np_addOp bool
Rule 91    boolF -> empty
Rule 92    logical -> ex np_addLogical logicalF
Rule 93    logicalF -> LESS np_addOp logical
Rule 94    logicalF -> GREATER np_addOp logical
Rule 95    logicalF -> LESS_TH np_addOp logical
Rule 96    logicalF -> GREAT_TH np_addOp logical
Rule 97    logicalF -> SAME np_addOp logical
Rule 98    logicalF -> DIF np_addOp logical
Rule 99    logicalF -> empty
Rule 100   exp -> bool empty
Rule 101   ex -> term np_addEx exF
Rule 102   exF -> PLUS np_addOp ex
Rule 103   exF -> MINUS np_addOp ex
Rule 104   exF -> empty
Rule 105   term -> factor np_addTerm termF
Rule 106   termF -> MULT np_addOp term
Rule 107   termF -> DIV np_addOp term
Rule 108   termF -> empty
Rule 109   factor -> L_PAR np_addPar exp R_PAR np_popPar empty
Rule 110   factor -> factorT
Rule 111   factorT -> PLUS factorF
Rule 112   factorT -> MINUS factorF
Rule 113   factorT -> factorF
Rule 114   factorF -> varcte empty
Rule 115   varcte -> var np_addId empty
Rule 116   varcte -> CTE_INT empty
Rule 117   varcte -> CTE_FLOAT empty
Rule 118   varcte -> CTE_CHAR empty
Rule 119   varcte -> CTE_BOOL empty
Rule 120   empty -> <empty>
Rule 121   np_getcurrFunc -> <empty>
Rule 122   np_getDec -> <empty>
Rule 123   np_getDecArr -> <empty>
Rule 124   np_getVarType -> <empty>
Rule 125   np_AddFunc -> <empty>
Rule 126   np_addToDic -> <empty>
Rule 127   np_addId -> <empty>
Rule 128   np_addOp -> <empty>
Rule 129   np_addPar -> <empty>
Rule 130   np_popPar -> <empty>
Rule 131   np_addTerm -> <empty>
Rule 132   np_addEx -> <empty>
Rule 133   np_addLogical -> <empty>
Rule 134   np_addBool -> <empty>
Rule 135   np_doAssign -> <empty>
Rule 136   np_addRead -> <empty>

Terminals, with rules where they appear

AND                  : 90
ATTRIBUTES           : 10
BOOL                 : 20 30 39
CHAR                 : 19 29 38
CLASS                : 7
COLON                : 15 16 33
COMMA                : 14 22 54 57 65 70
CTE_BOOL             : 119
CTE_CHAR             : 118
CTE_FLOAT            : 117
CTE_INT              : 22 22 23 116
CTE_STRING           : 68
DIF                  : 98
DIV                  : 107
DIV_EQ               : 83
DO                   : 84 87
DOT                  : 51 61
ELSE                 : 75
EQUAL                : 78
FLOAT                : 18 28 37
FROM                 : 85 86
FUNCTION             : 24
GREATER              : 8 94
GREAT_TH             : 96
ID                   : 1 7 8 21 24 31 40 51 51 52 53 61
IF                   : 74
INHERIT              : 8
INT                  : 17 27 36
LESS                 : 8 93
LESS_TH              : 95
L_BREAK              : 22 23 54 55
L_CURPAR             : 10 25 26 41 74 75 84 87
L_PAR                : 24 41 51 52 53 59 64 67 74 84 109
MAIN                 : 41
METHODS              : 10
MINUS                : 103 112
MIN_EQ               : 81
MULT                 : 106
MULT_EQ              : 82
OR                   : 89
PLUS                 : 102 111
PLUS_EQ              : 80
PROGRAM              : 1
READ                 : 64
RETURN               : 59
R_BREAK              : 22 23 54 55
R_CURPAR             : 10 25 26 41 74 75 84 87
R_PAR                : 25 26 41 51 52 53 59 66 71 74 84 109
SAME                 : 97
SEMICOLON            : 1 10 10 15 16 25 26 33 51 52 53 59 66 71 74 75 84 87
THEN                 : 74
TO                   : 87
VAR                  : 12 13 33 60 61 85 86
VARS                 : 11
VOID                 : 32
WHILE                : 84
WRITE                : 67
error                : 

Nonterminals, with rules where they appear

arr                  : 12
arrfunc              : 62 85
assigment            : 42
assigmentF           : 77
bool                 : 89 90 100
boolF                : 88
class                : 2
classF               : 8 9
classT               : 7
conditional          : 72
dec                  : 10 11 14 15 25 26
decF                 : 12 13
empty                : 6 10 11 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 35 36 37 38 39 40 41 50 51 52 53 54 55 58 59 62 63 66 71 72 73 75 76 78 79 80 81 82 83 84 87 91 99 100 104 108 109 114 115 116 117 118 119
ex                   : 92 102 103
exF                  : 101
exp                  : 54 54 55 56 59 69 74 78 79 84 87 87 109
factor               : 105
factorF              : 111 112 113
factorT              : 110
func                 : 5 10
funcF                : 24
if                   : 47
ifF                  : 74
logical              : 88 93 94 95 96 97 98
logicalF             : 92
main                 : 6
nonconditional       : 73
nonconditionalF      : 85 86
np_AddFunc           : 11 24
np_addBool           : 88
np_addEx             : 101
np_addId             : 77 115
np_addLogical        : 92
np_addOp             : 78 79 89 90 93 94 95 96 97 98 102 103 106 107
np_addPar            : 109
np_addRead           : 65 66
np_addTerm           : 105
np_addToDic          : 16
np_doAssign          : 78 79
np_getDec            : 13 15 16
np_getDecArr         : 12
np_getVarType        : 15 16
np_getcurrFunc       : 1 24
np_popPar            : 109
ope                  : 79
param                : 51 52 57
paramF               : 56
parameter            : 25 34
parameterF           : 33
program              : 0
programF             : 3 4 5
programT             : 1 2
read                 : 45
readF                : 64 65
repeat               : 48
return               : 44
statement            : 25 26 41 49 74 75 84 87
statementF           : 42 43 44 45 46 47 48
term                 : 101 106 107
termF                : 105
type                 : 15 16
typeFunc             : 24
typepar              : 33
var                  : 65 66 77 115
varF                 : 60 61
varcte               : 114
vars                 : 3
void                 : 43
write                : 46
writeF               : 68 69
writeT               : 67 70

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID np_getcurrFunc SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID np_getcurrFunc SEMICOLON programT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . np_getcurrFunc SEMICOLON programT
    (121) np_getcurrFunc -> .

    SEMICOLON       reduce using rule 121 (np_getcurrFunc -> .)

    np_getcurrFunc                 shift and go to state 4

state 4

    (1) program -> PROGRAM ID np_getcurrFunc . SEMICOLON programT

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID np_getcurrFunc SEMICOLON . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec np_AddFunc empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (41) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 11
    VARS            shift and go to state 12
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    programT                       shift and go to state 7
    class                          shift and go to state 8
    vars                           shift and go to state 9
    programF                       shift and go to state 10
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 6

    (31) typeFunc -> ID . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 22

state 7

    (1) program -> PROGRAM ID np_getcurrFunc SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM ID np_getcurrFunc SEMICOLON programT .)


state 8

    (2) programT -> class . programT
    (2) programT -> . class programT
    (3) programT -> . vars programF
    (4) programT -> . programF
    (7) class -> . CLASS ID classT
    (11) vars -> . VARS dec np_AddFunc empty
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (41) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    CLASS           shift and go to state 11
    VARS            shift and go to state 12
    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    class                          shift and go to state 8
    programT                       shift and go to state 23
    vars                           shift and go to state 9
    programF                       shift and go to state 10
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 9

    (3) programT -> vars . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (41) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    programF                       shift and go to state 24
    func                           shift and go to state 13
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 10

    (4) programT -> programF .

    $end            reduce using rule 4 (programT -> programF .)


state 11

    (7) class -> CLASS . ID classT

    ID              shift and go to state 25


state 12

    (11) vars -> VARS . dec np_AddFunc empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 26

state 13

    (5) programF -> func . programF
    (5) programF -> . func programF
    (6) programF -> . main empty
    (24) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (41) main -> . MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    MAIN            shift and go to state 16
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    func                           shift and go to state 13
    programF                       shift and go to state 28
    main                           shift and go to state 14
    typeFunc                       shift and go to state 15

state 14

    (6) programF -> main . empty
    (120) empty -> .

    $end            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 29

state 15

    (24) func -> typeFunc . FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF

    FUNCTION        shift and go to state 30


state 16

    (41) main -> MAIN . L_PAR R_PAR L_CURPAR statement R_CURPAR empty

    L_PAR           shift and go to state 31


state 17

    (27) typeFunc -> INT . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 32

state 18

    (28) typeFunc -> FLOAT . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 33

state 19

    (29) typeFunc -> CHAR . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 34

state 20

    (30) typeFunc -> BOOL . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 35

state 21

    (32) typeFunc -> VOID . empty
    (120) empty -> .

    FUNCTION        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 36

state 22

    (31) typeFunc -> ID empty .

    FUNCTION        reduce using rule 31 (typeFunc -> ID empty .)


state 23

    (2) programT -> class programT .

    $end            reduce using rule 2 (programT -> class programT .)


state 24

    (3) programT -> vars programF .

    $end            reduce using rule 3 (programT -> vars programF .)


state 25

    (7) class -> CLASS ID . classT
    (8) classT -> . LESS INHERIT ID GREATER classF
    (9) classT -> . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    LESS            shift and go to state 38
    SEMICOLON       shift and go to state 40

    classT                         shift and go to state 37
    classF                         shift and go to state 39

state 26

    (11) vars -> VARS dec . np_AddFunc empty
    (125) np_AddFunc -> .

    MAIN            reduce using rule 125 (np_AddFunc -> .)
    INT             reduce using rule 125 (np_AddFunc -> .)
    FLOAT           reduce using rule 125 (np_AddFunc -> .)
    CHAR            reduce using rule 125 (np_AddFunc -> .)
    BOOL            reduce using rule 125 (np_AddFunc -> .)
    ID              reduce using rule 125 (np_AddFunc -> .)
    VOID            reduce using rule 125 (np_AddFunc -> .)

    np_AddFunc                     shift and go to state 41

state 27

    (12) dec -> VAR . arr np_getDecArr decF
    (13) dec -> VAR . np_getDec decF
    (22) arr -> . L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> . L_BREAK CTE_INT R_BREAK empty
    (122) np_getDec -> .

    L_BREAK         shift and go to state 44
    COMMA           reduce using rule 122 (np_getDec -> .)
    COLON           reduce using rule 122 (np_getDec -> .)

    arr                            shift and go to state 42
    np_getDec                      shift and go to state 43

state 28

    (5) programF -> func programF .

    $end            reduce using rule 5 (programF -> func programF .)


state 29

    (6) programF -> main empty .

    $end            reduce using rule 6 (programF -> main empty .)


state 30

    (24) func -> typeFunc FUNCTION . ID np_getcurrFunc np_AddFunc L_PAR funcF

    ID              shift and go to state 45


state 31

    (41) main -> MAIN L_PAR . R_PAR L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 46


state 32

    (27) typeFunc -> INT empty .

    FUNCTION        reduce using rule 27 (typeFunc -> INT empty .)


state 33

    (28) typeFunc -> FLOAT empty .

    FUNCTION        reduce using rule 28 (typeFunc -> FLOAT empty .)


state 34

    (29) typeFunc -> CHAR empty .

    FUNCTION        reduce using rule 29 (typeFunc -> CHAR empty .)


state 35

    (30) typeFunc -> BOOL empty .

    FUNCTION        reduce using rule 30 (typeFunc -> BOOL empty .)


state 36

    (32) typeFunc -> VOID empty .

    FUNCTION        reduce using rule 32 (typeFunc -> VOID empty .)


state 37

    (7) class -> CLASS ID classT .

    CLASS           reduce using rule 7 (class -> CLASS ID classT .)
    VARS            reduce using rule 7 (class -> CLASS ID classT .)
    MAIN            reduce using rule 7 (class -> CLASS ID classT .)
    INT             reduce using rule 7 (class -> CLASS ID classT .)
    FLOAT           reduce using rule 7 (class -> CLASS ID classT .)
    CHAR            reduce using rule 7 (class -> CLASS ID classT .)
    BOOL            reduce using rule 7 (class -> CLASS ID classT .)
    ID              reduce using rule 7 (class -> CLASS ID classT .)
    VOID            reduce using rule 7 (class -> CLASS ID classT .)


state 38

    (8) classT -> LESS . INHERIT ID GREATER classF

    INHERIT         shift and go to state 47


state 39

    (9) classT -> classF .

    CLASS           reduce using rule 9 (classT -> classF .)
    VARS            reduce using rule 9 (classT -> classF .)
    MAIN            reduce using rule 9 (classT -> classF .)
    INT             reduce using rule 9 (classT -> classF .)
    FLOAT           reduce using rule 9 (classT -> classF .)
    CHAR            reduce using rule 9 (classT -> classF .)
    BOOL            reduce using rule 9 (classT -> classF .)
    ID              reduce using rule 9 (classT -> classF .)
    VOID            reduce using rule 9 (classT -> classF .)


state 40

    (10) classF -> SEMICOLON . L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    L_CURPAR        shift and go to state 48


state 41

    (11) vars -> VARS dec np_AddFunc . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 49

state 42

    (12) dec -> VAR arr . np_getDecArr decF
    (123) np_getDecArr -> .

    COMMA           reduce using rule 123 (np_getDecArr -> .)
    COLON           reduce using rule 123 (np_getDecArr -> .)

    np_getDecArr                   shift and go to state 50

state 43

    (13) dec -> VAR np_getDec . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 52
    COLON           shift and go to state 53

    decF                           shift and go to state 51

state 44

    (22) arr -> L_BREAK . CTE_INT COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 54


state 45

    (24) func -> typeFunc FUNCTION ID . np_getcurrFunc np_AddFunc L_PAR funcF
    (121) np_getcurrFunc -> .

    L_PAR           reduce using rule 121 (np_getcurrFunc -> .)

    np_getcurrFunc                 shift and go to state 55

state 46

    (41) main -> MAIN L_PAR R_PAR . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 56


state 47

    (8) classT -> LESS INHERIT . ID GREATER classF

    ID              shift and go to state 57


state 48

    (10) classF -> SEMICOLON L_CURPAR . ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    ATTRIBUTES      shift and go to state 58


state 49

    (11) vars -> VARS dec np_AddFunc empty .

    MAIN            reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    INT             reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    FLOAT           reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    CHAR            reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    BOOL            reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    ID              reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)
    VOID            reduce using rule 11 (vars -> VARS dec np_AddFunc empty .)


state 50

    (12) dec -> VAR arr np_getDecArr . decF
    (14) decF -> . COMMA dec
    (15) decF -> . COLON type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> . COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty

    COMMA           shift and go to state 52
    COLON           shift and go to state 53

    decF                           shift and go to state 59

state 51

    (13) dec -> VAR np_getDec decF .

    MAIN            reduce using rule 13 (dec -> VAR np_getDec decF .)
    INT             reduce using rule 13 (dec -> VAR np_getDec decF .)
    FLOAT           reduce using rule 13 (dec -> VAR np_getDec decF .)
    CHAR            reduce using rule 13 (dec -> VAR np_getDec decF .)
    BOOL            reduce using rule 13 (dec -> VAR np_getDec decF .)
    ID              reduce using rule 13 (dec -> VAR np_getDec decF .)
    VOID            reduce using rule 13 (dec -> VAR np_getDec decF .)
    METHODS         reduce using rule 13 (dec -> VAR np_getDec decF .)
    L_CURPAR        reduce using rule 13 (dec -> VAR np_getDec decF .)


state 52

    (14) decF -> COMMA . dec
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 60

state 53

    (15) decF -> COLON . type np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON . type np_getVarType SEMICOLON np_getDec np_addToDic empty
    (17) type -> . INT empty
    (18) type -> . FLOAT empty
    (19) type -> . CHAR empty
    (20) type -> . BOOL empty
    (21) type -> . ID empty

    INT             shift and go to state 62
    FLOAT           shift and go to state 63
    CHAR            shift and go to state 64
    BOOL            shift and go to state 65
    ID              shift and go to state 66

    type                           shift and go to state 61

state 54

    (22) arr -> L_BREAK CTE_INT . COMMA CTE_INT R_BREAK empty
    (23) arr -> L_BREAK CTE_INT . R_BREAK empty

    COMMA           shift and go to state 67
    R_BREAK         shift and go to state 68


state 55

    (24) func -> typeFunc FUNCTION ID np_getcurrFunc . np_AddFunc L_PAR funcF
    (125) np_AddFunc -> .

    L_PAR           reduce using rule 125 (np_AddFunc -> .)

    np_AddFunc                     shift and go to state 69

state 56

    (41) main -> MAIN L_PAR R_PAR L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    statement                      shift and go to state 70
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 57

    (8) classT -> LESS INHERIT ID . GREATER classF

    GREATER         shift and go to state 89


state 58

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES . dec METHODS func R_CURPAR SEMICOLON empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 90

state 59

    (12) dec -> VAR arr np_getDecArr decF .

    MAIN            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    INT             reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    FLOAT           reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    CHAR            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    BOOL            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    ID              reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    VOID            reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    METHODS         reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)
    L_CURPAR        reduce using rule 12 (dec -> VAR arr np_getDecArr decF .)


state 60

    (14) decF -> COMMA dec .

    MAIN            reduce using rule 14 (decF -> COMMA dec .)
    INT             reduce using rule 14 (decF -> COMMA dec .)
    FLOAT           reduce using rule 14 (decF -> COMMA dec .)
    CHAR            reduce using rule 14 (decF -> COMMA dec .)
    BOOL            reduce using rule 14 (decF -> COMMA dec .)
    ID              reduce using rule 14 (decF -> COMMA dec .)
    VOID            reduce using rule 14 (decF -> COMMA dec .)
    METHODS         reduce using rule 14 (decF -> COMMA dec .)
    L_CURPAR        reduce using rule 14 (decF -> COMMA dec .)


state 61

    (15) decF -> COLON type . np_getVarType SEMICOLON np_getDec dec
    (16) decF -> COLON type . np_getVarType SEMICOLON np_getDec np_addToDic empty
    (124) np_getVarType -> .

    SEMICOLON       reduce using rule 124 (np_getVarType -> .)

    np_getVarType                  shift and go to state 91

state 62

    (17) type -> INT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 92

state 63

    (18) type -> FLOAT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 93

state 64

    (19) type -> CHAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 94

state 65

    (20) type -> BOOL . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 95

state 66

    (21) type -> ID . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 96

state 67

    (22) arr -> L_BREAK CTE_INT COMMA . CTE_INT R_BREAK empty

    CTE_INT         shift and go to state 97


state 68

    (23) arr -> L_BREAK CTE_INT R_BREAK . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    COLON           reduce using rule 120 (empty -> .)

    empty                          shift and go to state 98

state 69

    (24) func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc . L_PAR funcF

    L_PAR           shift and go to state 99


state 70

    (41) main -> MAIN L_PAR R_PAR L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 100


state 71

    (42) statement -> assigment . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    assigment                      shift and go to state 71
    statementF                     shift and go to state 101
    statement                      shift and go to state 102
    empty                          shift and go to state 103
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 72

    (43) statement -> void . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    void                           shift and go to state 72
    statementF                     shift and go to state 104
    statement                      shift and go to state 102
    empty                          shift and go to state 103
    assigment                      shift and go to state 71
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 73

    (44) statement -> return . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    return                         shift and go to state 73
    statementF                     shift and go to state 105
    statement                      shift and go to state 102
    empty                          shift and go to state 103
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 74

    (45) statement -> read . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    read                           shift and go to state 74
    statementF                     shift and go to state 106
    statement                      shift and go to state 102
    empty                          shift and go to state 103
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 75

    (46) statement -> write . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    write                          shift and go to state 75
    statementF                     shift and go to state 107
    statement                      shift and go to state 102
    empty                          shift and go to state 103
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 76

    (47) statement -> if . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    if                             shift and go to state 76
    statementF                     shift and go to state 108
    statement                      shift and go to state 102
    empty                          shift and go to state 103
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 77

    (48) statement -> repeat . statementF
    (49) statementF -> . statement
    (50) statementF -> . empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (120) empty -> .
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    repeat                         shift and go to state 77
    statementF                     shift and go to state 109
    statement                      shift and go to state 102
    empty                          shift and go to state 103
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 78

    (77) assigment -> var . np_addId assigmentF
    (127) np_addId -> .

    EQUAL           reduce using rule 127 (np_addId -> .)
    PLUS_EQ         reduce using rule 127 (np_addId -> .)
    MIN_EQ          reduce using rule 127 (np_addId -> .)
    MULT_EQ         reduce using rule 127 (np_addId -> .)
    DIV_EQ          reduce using rule 127 (np_addId -> .)

    np_addId                       shift and go to state 110

state 79

    (51) void -> ID . DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> ID . L_PAR param R_PAR SEMICOLON empty
    (53) void -> ID . L_PAR R_PAR SEMICOLON empty
    (61) var -> ID . DOT VAR varF

    DOT             shift and go to state 111
    L_PAR           shift and go to state 112


state 80

    (59) return -> RETURN . L_PAR exp R_PAR SEMICOLON empty

    L_PAR           shift and go to state 113


state 81

    (64) read -> READ . L_PAR readF

    L_PAR           shift and go to state 114


state 82

    (67) write -> WRITE . L_PAR writeT

    L_PAR           shift and go to state 115


state 83

    (74) if -> IF . L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_PAR           shift and go to state 116


state 84

    (72) repeat -> conditional . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 117

state 85

    (73) repeat -> nonconditional . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 118

state 86

    (60) var -> VAR . varF
    (62) varF -> . arrfunc empty
    (63) varF -> . empty
    (54) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (55) arrfunc -> . L_BREAK exp R_BREAK empty
    (120) empty -> .

    L_BREAK         shift and go to state 122
    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    varF                           shift and go to state 119
    arrfunc                        shift and go to state 120
    empty                          shift and go to state 121

state 87

    (84) conditional -> WHILE . L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    L_PAR           shift and go to state 123


state 88

    (85) nonconditional -> FROM . VAR arrfunc nonconditionalF
    (86) nonconditional -> FROM . VAR nonconditionalF

    VAR             shift and go to state 124


state 89

    (8) classT -> LESS INHERIT ID GREATER . classF
    (10) classF -> . SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty

    SEMICOLON       shift and go to state 40

    classF                         shift and go to state 125

state 90

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec . METHODS func R_CURPAR SEMICOLON empty

    METHODS         shift and go to state 126


state 91

    (15) decF -> COLON type np_getVarType . SEMICOLON np_getDec dec
    (16) decF -> COLON type np_getVarType . SEMICOLON np_getDec np_addToDic empty

    SEMICOLON       shift and go to state 127


state 92

    (17) type -> INT empty .

    SEMICOLON       reduce using rule 17 (type -> INT empty .)


state 93

    (18) type -> FLOAT empty .

    SEMICOLON       reduce using rule 18 (type -> FLOAT empty .)


state 94

    (19) type -> CHAR empty .

    SEMICOLON       reduce using rule 19 (type -> CHAR empty .)


state 95

    (20) type -> BOOL empty .

    SEMICOLON       reduce using rule 20 (type -> BOOL empty .)


state 96

    (21) type -> ID empty .

    SEMICOLON       reduce using rule 21 (type -> ID empty .)


state 97

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT . R_BREAK empty

    R_BREAK         shift and go to state 128


state 98

    (23) arr -> L_BREAK CTE_INT R_BREAK empty .

    COMMA           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)
    COLON           reduce using rule 23 (arr -> L_BREAK CTE_INT R_BREAK empty .)


state 99

    (24) func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR . funcF
    (25) funcF -> . parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (26) funcF -> . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty
    (33) parameter -> . VAR COLON typepar SEMICOLON parameterF

    R_PAR           shift and go to state 131
    VAR             shift and go to state 132

    funcF                          shift and go to state 129
    parameter                      shift and go to state 130

state 100

    (41) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    $end            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 133

state 101

    (42) statement -> assigment statementF .

    R_CURPAR        reduce using rule 42 (statement -> assigment statementF .)
    SEMICOLON       reduce using rule 42 (statement -> assigment statementF .)


state 102

    (49) statementF -> statement .

    R_CURPAR        reduce using rule 49 (statementF -> statement .)
    SEMICOLON       reduce using rule 49 (statementF -> statement .)


state 103

    (50) statementF -> empty .

    R_CURPAR        reduce using rule 50 (statementF -> empty .)
    SEMICOLON       reduce using rule 50 (statementF -> empty .)


state 104

    (43) statement -> void statementF .

    R_CURPAR        reduce using rule 43 (statement -> void statementF .)
    SEMICOLON       reduce using rule 43 (statement -> void statementF .)


state 105

    (44) statement -> return statementF .

    R_CURPAR        reduce using rule 44 (statement -> return statementF .)
    SEMICOLON       reduce using rule 44 (statement -> return statementF .)


state 106

    (45) statement -> read statementF .

    R_CURPAR        reduce using rule 45 (statement -> read statementF .)
    SEMICOLON       reduce using rule 45 (statement -> read statementF .)


state 107

    (46) statement -> write statementF .

    R_CURPAR        reduce using rule 46 (statement -> write statementF .)
    SEMICOLON       reduce using rule 46 (statement -> write statementF .)


state 108

    (47) statement -> if statementF .

    R_CURPAR        reduce using rule 47 (statement -> if statementF .)
    SEMICOLON       reduce using rule 47 (statement -> if statementF .)


state 109

    (48) statement -> repeat statementF .

    R_CURPAR        reduce using rule 48 (statement -> repeat statementF .)
    SEMICOLON       reduce using rule 48 (statement -> repeat statementF .)


state 110

    (77) assigment -> var np_addId . assigmentF
    (78) assigmentF -> . EQUAL np_addOp exp np_doAssign empty
    (79) assigmentF -> . ope np_addOp exp np_doAssign empty
    (80) ope -> . PLUS_EQ empty
    (81) ope -> . MIN_EQ empty
    (82) ope -> . MULT_EQ empty
    (83) ope -> . DIV_EQ empty

    EQUAL           shift and go to state 135
    PLUS_EQ         shift and go to state 137
    MIN_EQ          shift and go to state 138
    MULT_EQ         shift and go to state 139
    DIV_EQ          shift and go to state 140

    assigmentF                     shift and go to state 134
    ope                            shift and go to state 136

state 111

    (51) void -> ID DOT . ID L_PAR param R_PAR SEMICOLON empty
    (61) var -> ID DOT . VAR varF

    ID              shift and go to state 141
    VAR             shift and go to state 142


state 112

    (52) void -> ID L_PAR . param R_PAR SEMICOLON empty
    (53) void -> ID L_PAR . R_PAR SEMICOLON empty
    (56) param -> . exp paramF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    R_PAR           shift and go to state 146
    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    param                          shift and go to state 145
    exp                            shift and go to state 147
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 113

    (59) return -> RETURN L_PAR . exp R_PAR SEMICOLON empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    exp                            shift and go to state 163
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 114

    (64) read -> READ L_PAR . readF
    (65) readF -> . var np_addRead COMMA readF
    (66) readF -> . var np_addRead R_PAR SEMICOLON empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 86
    ID              shift and go to state 143

    readF                          shift and go to state 164
    var                            shift and go to state 165

state 115

    (67) write -> WRITE L_PAR . writeT
    (68) writeT -> . CTE_STRING writeF
    (69) writeT -> . exp writeF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 167
    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    writeT                         shift and go to state 166
    exp                            shift and go to state 168
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 116

    (74) if -> IF L_PAR . exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    exp                            shift and go to state 169
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 117

    (72) repeat -> conditional empty .

    ID              reduce using rule 72 (repeat -> conditional empty .)
    RETURN          reduce using rule 72 (repeat -> conditional empty .)
    READ            reduce using rule 72 (repeat -> conditional empty .)
    WRITE           reduce using rule 72 (repeat -> conditional empty .)
    IF              reduce using rule 72 (repeat -> conditional empty .)
    VAR             reduce using rule 72 (repeat -> conditional empty .)
    WHILE           reduce using rule 72 (repeat -> conditional empty .)
    FROM            reduce using rule 72 (repeat -> conditional empty .)
    R_CURPAR        reduce using rule 72 (repeat -> conditional empty .)
    SEMICOLON       reduce using rule 72 (repeat -> conditional empty .)


state 118

    (73) repeat -> nonconditional empty .

    ID              reduce using rule 73 (repeat -> nonconditional empty .)
    RETURN          reduce using rule 73 (repeat -> nonconditional empty .)
    READ            reduce using rule 73 (repeat -> nonconditional empty .)
    WRITE           reduce using rule 73 (repeat -> nonconditional empty .)
    IF              reduce using rule 73 (repeat -> nonconditional empty .)
    VAR             reduce using rule 73 (repeat -> nonconditional empty .)
    WHILE           reduce using rule 73 (repeat -> nonconditional empty .)
    FROM            reduce using rule 73 (repeat -> nonconditional empty .)
    R_CURPAR        reduce using rule 73 (repeat -> nonconditional empty .)
    SEMICOLON       reduce using rule 73 (repeat -> nonconditional empty .)


state 119

    (60) var -> VAR varF .

    EQUAL           reduce using rule 60 (var -> VAR varF .)
    PLUS_EQ         reduce using rule 60 (var -> VAR varF .)
    MIN_EQ          reduce using rule 60 (var -> VAR varF .)
    MULT_EQ         reduce using rule 60 (var -> VAR varF .)
    DIV_EQ          reduce using rule 60 (var -> VAR varF .)
    MULT            reduce using rule 60 (var -> VAR varF .)
    DIV             reduce using rule 60 (var -> VAR varF .)
    PLUS            reduce using rule 60 (var -> VAR varF .)
    MINUS           reduce using rule 60 (var -> VAR varF .)
    LESS            reduce using rule 60 (var -> VAR varF .)
    GREATER         reduce using rule 60 (var -> VAR varF .)
    LESS_TH         reduce using rule 60 (var -> VAR varF .)
    GREAT_TH        reduce using rule 60 (var -> VAR varF .)
    SAME            reduce using rule 60 (var -> VAR varF .)
    DIF             reduce using rule 60 (var -> VAR varF .)
    OR              reduce using rule 60 (var -> VAR varF .)
    AND             reduce using rule 60 (var -> VAR varF .)
    COMMA           reduce using rule 60 (var -> VAR varF .)
    R_PAR           reduce using rule 60 (var -> VAR varF .)
    R_BREAK         reduce using rule 60 (var -> VAR varF .)
    TO              reduce using rule 60 (var -> VAR varF .)
    ID              reduce using rule 60 (var -> VAR varF .)
    RETURN          reduce using rule 60 (var -> VAR varF .)
    READ            reduce using rule 60 (var -> VAR varF .)
    WRITE           reduce using rule 60 (var -> VAR varF .)
    IF              reduce using rule 60 (var -> VAR varF .)
    VAR             reduce using rule 60 (var -> VAR varF .)
    WHILE           reduce using rule 60 (var -> VAR varF .)
    FROM            reduce using rule 60 (var -> VAR varF .)
    R_CURPAR        reduce using rule 60 (var -> VAR varF .)
    SEMICOLON       reduce using rule 60 (var -> VAR varF .)
    DO              reduce using rule 60 (var -> VAR varF .)


state 120

    (62) varF -> arrfunc . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 170

state 121

    (63) varF -> empty .

    EQUAL           reduce using rule 63 (varF -> empty .)
    PLUS_EQ         reduce using rule 63 (varF -> empty .)
    MIN_EQ          reduce using rule 63 (varF -> empty .)
    MULT_EQ         reduce using rule 63 (varF -> empty .)
    DIV_EQ          reduce using rule 63 (varF -> empty .)
    MULT            reduce using rule 63 (varF -> empty .)
    DIV             reduce using rule 63 (varF -> empty .)
    PLUS            reduce using rule 63 (varF -> empty .)
    MINUS           reduce using rule 63 (varF -> empty .)
    LESS            reduce using rule 63 (varF -> empty .)
    GREATER         reduce using rule 63 (varF -> empty .)
    LESS_TH         reduce using rule 63 (varF -> empty .)
    GREAT_TH        reduce using rule 63 (varF -> empty .)
    SAME            reduce using rule 63 (varF -> empty .)
    DIF             reduce using rule 63 (varF -> empty .)
    OR              reduce using rule 63 (varF -> empty .)
    AND             reduce using rule 63 (varF -> empty .)
    COMMA           reduce using rule 63 (varF -> empty .)
    R_PAR           reduce using rule 63 (varF -> empty .)
    R_BREAK         reduce using rule 63 (varF -> empty .)
    TO              reduce using rule 63 (varF -> empty .)
    ID              reduce using rule 63 (varF -> empty .)
    RETURN          reduce using rule 63 (varF -> empty .)
    READ            reduce using rule 63 (varF -> empty .)
    WRITE           reduce using rule 63 (varF -> empty .)
    IF              reduce using rule 63 (varF -> empty .)
    VAR             reduce using rule 63 (varF -> empty .)
    WHILE           reduce using rule 63 (varF -> empty .)
    FROM            reduce using rule 63 (varF -> empty .)
    R_CURPAR        reduce using rule 63 (varF -> empty .)
    SEMICOLON       reduce using rule 63 (varF -> empty .)
    DO              reduce using rule 63 (varF -> empty .)


state 122

    (54) arrfunc -> L_BREAK . exp COMMA exp R_BREAK empty
    (55) arrfunc -> L_BREAK . exp R_BREAK empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    exp                            shift and go to state 171
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 123

    (84) conditional -> WHILE L_PAR . exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    exp                            shift and go to state 172
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 124

    (85) nonconditional -> FROM VAR . arrfunc nonconditionalF
    (86) nonconditional -> FROM VAR . nonconditionalF
    (54) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (55) arrfunc -> . L_BREAK exp R_BREAK empty
    (87) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_BREAK         shift and go to state 122
    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    arrfunc                        shift and go to state 173
    nonconditionalF                shift and go to state 174
    exp                            shift and go to state 175
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 125

    (8) classT -> LESS INHERIT ID GREATER classF .

    CLASS           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VARS            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    MAIN            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    INT             reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    FLOAT           reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    CHAR            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    BOOL            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    ID              reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)
    VOID            reduce using rule 8 (classT -> LESS INHERIT ID GREATER classF .)


state 126

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS . func R_CURPAR SEMICOLON empty
    (24) func -> . typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF
    (27) typeFunc -> . INT empty
    (28) typeFunc -> . FLOAT empty
    (29) typeFunc -> . CHAR empty
    (30) typeFunc -> . BOOL empty
    (31) typeFunc -> . ID empty
    (32) typeFunc -> . VOID empty

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    ID              shift and go to state 6
    VOID            shift and go to state 21

    func                           shift and go to state 176
    typeFunc                       shift and go to state 15

state 127

    (15) decF -> COLON type np_getVarType SEMICOLON . np_getDec dec
    (16) decF -> COLON type np_getVarType SEMICOLON . np_getDec np_addToDic empty
    (122) np_getDec -> .

    VAR             reduce using rule 122 (np_getDec -> .)
    MAIN            reduce using rule 122 (np_getDec -> .)
    INT             reduce using rule 122 (np_getDec -> .)
    FLOAT           reduce using rule 122 (np_getDec -> .)
    CHAR            reduce using rule 122 (np_getDec -> .)
    BOOL            reduce using rule 122 (np_getDec -> .)
    ID              reduce using rule 122 (np_getDec -> .)
    VOID            reduce using rule 122 (np_getDec -> .)
    METHODS         reduce using rule 122 (np_getDec -> .)
    L_CURPAR        reduce using rule 122 (np_getDec -> .)

    np_getDec                      shift and go to state 177

state 128

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    COLON           reduce using rule 120 (empty -> .)

    empty                          shift and go to state 178

state 129

    (24) func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .

    MAIN            reduce using rule 24 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    INT             reduce using rule 24 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    FLOAT           reduce using rule 24 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    CHAR            reduce using rule 24 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    BOOL            reduce using rule 24 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    ID              reduce using rule 24 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    VOID            reduce using rule 24 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)
    R_CURPAR        reduce using rule 24 (func -> typeFunc FUNCTION ID np_getcurrFunc np_AddFunc L_PAR funcF .)


state 130

    (25) funcF -> parameter . R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty

    R_PAR           shift and go to state 179


state 131

    (26) funcF -> R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 180


state 132

    (33) parameter -> VAR . COLON typepar SEMICOLON parameterF

    COLON           shift and go to state 181


state 133

    (41) main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .

    $end            reduce using rule 41 (main -> MAIN L_PAR R_PAR L_CURPAR statement R_CURPAR empty .)


state 134

    (77) assigment -> var np_addId assigmentF .

    ID              reduce using rule 77 (assigment -> var np_addId assigmentF .)
    RETURN          reduce using rule 77 (assigment -> var np_addId assigmentF .)
    READ            reduce using rule 77 (assigment -> var np_addId assigmentF .)
    WRITE           reduce using rule 77 (assigment -> var np_addId assigmentF .)
    IF              reduce using rule 77 (assigment -> var np_addId assigmentF .)
    VAR             reduce using rule 77 (assigment -> var np_addId assigmentF .)
    WHILE           reduce using rule 77 (assigment -> var np_addId assigmentF .)
    FROM            reduce using rule 77 (assigment -> var np_addId assigmentF .)
    R_CURPAR        reduce using rule 77 (assigment -> var np_addId assigmentF .)
    SEMICOLON       reduce using rule 77 (assigment -> var np_addId assigmentF .)


state 135

    (78) assigmentF -> EQUAL . np_addOp exp np_doAssign empty
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 182

state 136

    (79) assigmentF -> ope . np_addOp exp np_doAssign empty
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 183

state 137

    (80) ope -> PLUS_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 184

state 138

    (81) ope -> MIN_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 185

state 139

    (82) ope -> MULT_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 186

state 140

    (83) ope -> DIV_EQ . empty
    (120) empty -> .

    L_PAR           reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 187

state 141

    (51) void -> ID DOT ID . L_PAR param R_PAR SEMICOLON empty

    L_PAR           shift and go to state 188


state 142

    (61) var -> ID DOT VAR . varF
    (62) varF -> . arrfunc empty
    (63) varF -> . empty
    (54) arrfunc -> . L_BREAK exp COMMA exp R_BREAK empty
    (55) arrfunc -> . L_BREAK exp R_BREAK empty
    (120) empty -> .

    L_BREAK         shift and go to state 122
    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    varF                           shift and go to state 189
    arrfunc                        shift and go to state 120
    empty                          shift and go to state 121

state 143

    (61) var -> ID . DOT VAR varF

    DOT             shift and go to state 190


state 144

    (109) factor -> L_PAR . np_addPar exp R_PAR np_popPar empty
    (129) np_addPar -> .

    L_PAR           reduce using rule 129 (np_addPar -> .)
    PLUS            reduce using rule 129 (np_addPar -> .)
    MINUS           reduce using rule 129 (np_addPar -> .)
    CTE_INT         reduce using rule 129 (np_addPar -> .)
    CTE_FLOAT       reduce using rule 129 (np_addPar -> .)
    CTE_CHAR        reduce using rule 129 (np_addPar -> .)
    CTE_BOOL        reduce using rule 129 (np_addPar -> .)
    VAR             reduce using rule 129 (np_addPar -> .)
    ID              reduce using rule 129 (np_addPar -> .)

    np_addPar                      shift and go to state 191

state 145

    (52) void -> ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 192


state 146

    (53) void -> ID L_PAR R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 193


state 147

    (56) param -> exp . paramF
    (57) paramF -> . COMMA param
    (58) paramF -> . empty
    (120) empty -> .

    COMMA           shift and go to state 195
    R_PAR           reduce using rule 120 (empty -> .)

    paramF                         shift and go to state 194
    empty                          shift and go to state 196

state 148

    (100) exp -> bool . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 197

state 149

    (88) bool -> logical . np_addBool boolF
    (134) np_addBool -> .

    OR              reduce using rule 134 (np_addBool -> .)
    AND             reduce using rule 134 (np_addBool -> .)
    COMMA           reduce using rule 134 (np_addBool -> .)
    R_PAR           reduce using rule 134 (np_addBool -> .)
    R_BREAK         reduce using rule 134 (np_addBool -> .)
    TO              reduce using rule 134 (np_addBool -> .)
    ID              reduce using rule 134 (np_addBool -> .)
    RETURN          reduce using rule 134 (np_addBool -> .)
    READ            reduce using rule 134 (np_addBool -> .)
    WRITE           reduce using rule 134 (np_addBool -> .)
    IF              reduce using rule 134 (np_addBool -> .)
    VAR             reduce using rule 134 (np_addBool -> .)
    WHILE           reduce using rule 134 (np_addBool -> .)
    FROM            reduce using rule 134 (np_addBool -> .)
    R_CURPAR        reduce using rule 134 (np_addBool -> .)
    SEMICOLON       reduce using rule 134 (np_addBool -> .)
    DO              reduce using rule 134 (np_addBool -> .)

    np_addBool                     shift and go to state 198

state 150

    (92) logical -> ex . np_addLogical logicalF
    (133) np_addLogical -> .

    LESS            reduce using rule 133 (np_addLogical -> .)
    GREATER         reduce using rule 133 (np_addLogical -> .)
    LESS_TH         reduce using rule 133 (np_addLogical -> .)
    GREAT_TH        reduce using rule 133 (np_addLogical -> .)
    SAME            reduce using rule 133 (np_addLogical -> .)
    DIF             reduce using rule 133 (np_addLogical -> .)
    OR              reduce using rule 133 (np_addLogical -> .)
    AND             reduce using rule 133 (np_addLogical -> .)
    COMMA           reduce using rule 133 (np_addLogical -> .)
    R_PAR           reduce using rule 133 (np_addLogical -> .)
    R_BREAK         reduce using rule 133 (np_addLogical -> .)
    TO              reduce using rule 133 (np_addLogical -> .)
    ID              reduce using rule 133 (np_addLogical -> .)
    RETURN          reduce using rule 133 (np_addLogical -> .)
    READ            reduce using rule 133 (np_addLogical -> .)
    WRITE           reduce using rule 133 (np_addLogical -> .)
    IF              reduce using rule 133 (np_addLogical -> .)
    VAR             reduce using rule 133 (np_addLogical -> .)
    WHILE           reduce using rule 133 (np_addLogical -> .)
    FROM            reduce using rule 133 (np_addLogical -> .)
    R_CURPAR        reduce using rule 133 (np_addLogical -> .)
    SEMICOLON       reduce using rule 133 (np_addLogical -> .)
    DO              reduce using rule 133 (np_addLogical -> .)

    np_addLogical                  shift and go to state 199

state 151

    (101) ex -> term . np_addEx exF
    (132) np_addEx -> .

    PLUS            reduce using rule 132 (np_addEx -> .)
    MINUS           reduce using rule 132 (np_addEx -> .)
    LESS            reduce using rule 132 (np_addEx -> .)
    GREATER         reduce using rule 132 (np_addEx -> .)
    LESS_TH         reduce using rule 132 (np_addEx -> .)
    GREAT_TH        reduce using rule 132 (np_addEx -> .)
    SAME            reduce using rule 132 (np_addEx -> .)
    DIF             reduce using rule 132 (np_addEx -> .)
    OR              reduce using rule 132 (np_addEx -> .)
    AND             reduce using rule 132 (np_addEx -> .)
    COMMA           reduce using rule 132 (np_addEx -> .)
    R_PAR           reduce using rule 132 (np_addEx -> .)
    R_BREAK         reduce using rule 132 (np_addEx -> .)
    TO              reduce using rule 132 (np_addEx -> .)
    ID              reduce using rule 132 (np_addEx -> .)
    RETURN          reduce using rule 132 (np_addEx -> .)
    READ            reduce using rule 132 (np_addEx -> .)
    WRITE           reduce using rule 132 (np_addEx -> .)
    IF              reduce using rule 132 (np_addEx -> .)
    VAR             reduce using rule 132 (np_addEx -> .)
    WHILE           reduce using rule 132 (np_addEx -> .)
    FROM            reduce using rule 132 (np_addEx -> .)
    R_CURPAR        reduce using rule 132 (np_addEx -> .)
    SEMICOLON       reduce using rule 132 (np_addEx -> .)
    DO              reduce using rule 132 (np_addEx -> .)

    np_addEx                       shift and go to state 200

state 152

    (105) term -> factor . np_addTerm termF
    (131) np_addTerm -> .

    MULT            reduce using rule 131 (np_addTerm -> .)
    DIV             reduce using rule 131 (np_addTerm -> .)
    PLUS            reduce using rule 131 (np_addTerm -> .)
    MINUS           reduce using rule 131 (np_addTerm -> .)
    LESS            reduce using rule 131 (np_addTerm -> .)
    GREATER         reduce using rule 131 (np_addTerm -> .)
    LESS_TH         reduce using rule 131 (np_addTerm -> .)
    GREAT_TH        reduce using rule 131 (np_addTerm -> .)
    SAME            reduce using rule 131 (np_addTerm -> .)
    DIF             reduce using rule 131 (np_addTerm -> .)
    OR              reduce using rule 131 (np_addTerm -> .)
    AND             reduce using rule 131 (np_addTerm -> .)
    COMMA           reduce using rule 131 (np_addTerm -> .)
    R_PAR           reduce using rule 131 (np_addTerm -> .)
    R_BREAK         reduce using rule 131 (np_addTerm -> .)
    TO              reduce using rule 131 (np_addTerm -> .)
    ID              reduce using rule 131 (np_addTerm -> .)
    RETURN          reduce using rule 131 (np_addTerm -> .)
    READ            reduce using rule 131 (np_addTerm -> .)
    WRITE           reduce using rule 131 (np_addTerm -> .)
    IF              reduce using rule 131 (np_addTerm -> .)
    VAR             reduce using rule 131 (np_addTerm -> .)
    WHILE           reduce using rule 131 (np_addTerm -> .)
    FROM            reduce using rule 131 (np_addTerm -> .)
    R_CURPAR        reduce using rule 131 (np_addTerm -> .)
    SEMICOLON       reduce using rule 131 (np_addTerm -> .)
    DO              reduce using rule 131 (np_addTerm -> .)

    np_addTerm                     shift and go to state 201

state 153

    (110) factor -> factorT .

    MULT            reduce using rule 110 (factor -> factorT .)
    DIV             reduce using rule 110 (factor -> factorT .)
    PLUS            reduce using rule 110 (factor -> factorT .)
    MINUS           reduce using rule 110 (factor -> factorT .)
    LESS            reduce using rule 110 (factor -> factorT .)
    GREATER         reduce using rule 110 (factor -> factorT .)
    LESS_TH         reduce using rule 110 (factor -> factorT .)
    GREAT_TH        reduce using rule 110 (factor -> factorT .)
    SAME            reduce using rule 110 (factor -> factorT .)
    DIF             reduce using rule 110 (factor -> factorT .)
    OR              reduce using rule 110 (factor -> factorT .)
    AND             reduce using rule 110 (factor -> factorT .)
    COMMA           reduce using rule 110 (factor -> factorT .)
    R_PAR           reduce using rule 110 (factor -> factorT .)
    R_BREAK         reduce using rule 110 (factor -> factorT .)
    TO              reduce using rule 110 (factor -> factorT .)
    ID              reduce using rule 110 (factor -> factorT .)
    RETURN          reduce using rule 110 (factor -> factorT .)
    READ            reduce using rule 110 (factor -> factorT .)
    WRITE           reduce using rule 110 (factor -> factorT .)
    IF              reduce using rule 110 (factor -> factorT .)
    VAR             reduce using rule 110 (factor -> factorT .)
    WHILE           reduce using rule 110 (factor -> factorT .)
    FROM            reduce using rule 110 (factor -> factorT .)
    R_CURPAR        reduce using rule 110 (factor -> factorT .)
    SEMICOLON       reduce using rule 110 (factor -> factorT .)
    DO              reduce using rule 110 (factor -> factorT .)


state 154

    (111) factorT -> PLUS . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    factorF                        shift and go to state 202
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 155

    (113) factorT -> factorF .

    MULT            reduce using rule 113 (factorT -> factorF .)
    DIV             reduce using rule 113 (factorT -> factorF .)
    PLUS            reduce using rule 113 (factorT -> factorF .)
    MINUS           reduce using rule 113 (factorT -> factorF .)
    LESS            reduce using rule 113 (factorT -> factorF .)
    GREATER         reduce using rule 113 (factorT -> factorF .)
    LESS_TH         reduce using rule 113 (factorT -> factorF .)
    GREAT_TH        reduce using rule 113 (factorT -> factorF .)
    SAME            reduce using rule 113 (factorT -> factorF .)
    DIF             reduce using rule 113 (factorT -> factorF .)
    OR              reduce using rule 113 (factorT -> factorF .)
    AND             reduce using rule 113 (factorT -> factorF .)
    COMMA           reduce using rule 113 (factorT -> factorF .)
    R_PAR           reduce using rule 113 (factorT -> factorF .)
    R_BREAK         reduce using rule 113 (factorT -> factorF .)
    TO              reduce using rule 113 (factorT -> factorF .)
    ID              reduce using rule 113 (factorT -> factorF .)
    RETURN          reduce using rule 113 (factorT -> factorF .)
    READ            reduce using rule 113 (factorT -> factorF .)
    WRITE           reduce using rule 113 (factorT -> factorF .)
    IF              reduce using rule 113 (factorT -> factorF .)
    VAR             reduce using rule 113 (factorT -> factorF .)
    WHILE           reduce using rule 113 (factorT -> factorF .)
    FROM            reduce using rule 113 (factorT -> factorF .)
    R_CURPAR        reduce using rule 113 (factorT -> factorF .)
    SEMICOLON       reduce using rule 113 (factorT -> factorF .)
    DO              reduce using rule 113 (factorT -> factorF .)


state 156

    (112) factorT -> MINUS . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    factorF                        shift and go to state 203
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 157

    (114) factorF -> varcte . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 204

state 158

    (115) varcte -> var . np_addId empty
    (127) np_addId -> .

    MULT            reduce using rule 127 (np_addId -> .)
    DIV             reduce using rule 127 (np_addId -> .)
    PLUS            reduce using rule 127 (np_addId -> .)
    MINUS           reduce using rule 127 (np_addId -> .)
    LESS            reduce using rule 127 (np_addId -> .)
    GREATER         reduce using rule 127 (np_addId -> .)
    LESS_TH         reduce using rule 127 (np_addId -> .)
    GREAT_TH        reduce using rule 127 (np_addId -> .)
    SAME            reduce using rule 127 (np_addId -> .)
    DIF             reduce using rule 127 (np_addId -> .)
    OR              reduce using rule 127 (np_addId -> .)
    AND             reduce using rule 127 (np_addId -> .)
    COMMA           reduce using rule 127 (np_addId -> .)
    R_PAR           reduce using rule 127 (np_addId -> .)
    R_BREAK         reduce using rule 127 (np_addId -> .)
    TO              reduce using rule 127 (np_addId -> .)
    ID              reduce using rule 127 (np_addId -> .)
    RETURN          reduce using rule 127 (np_addId -> .)
    READ            reduce using rule 127 (np_addId -> .)
    WRITE           reduce using rule 127 (np_addId -> .)
    IF              reduce using rule 127 (np_addId -> .)
    VAR             reduce using rule 127 (np_addId -> .)
    WHILE           reduce using rule 127 (np_addId -> .)
    FROM            reduce using rule 127 (np_addId -> .)
    R_CURPAR        reduce using rule 127 (np_addId -> .)
    SEMICOLON       reduce using rule 127 (np_addId -> .)
    DO              reduce using rule 127 (np_addId -> .)

    np_addId                       shift and go to state 205

state 159

    (116) varcte -> CTE_INT . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 206

state 160

    (117) varcte -> CTE_FLOAT . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 207

state 161

    (118) varcte -> CTE_CHAR . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 208

state 162

    (119) varcte -> CTE_BOOL . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 209

state 163

    (59) return -> RETURN L_PAR exp . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 210


state 164

    (64) read -> READ L_PAR readF .

    ID              reduce using rule 64 (read -> READ L_PAR readF .)
    RETURN          reduce using rule 64 (read -> READ L_PAR readF .)
    READ            reduce using rule 64 (read -> READ L_PAR readF .)
    WRITE           reduce using rule 64 (read -> READ L_PAR readF .)
    IF              reduce using rule 64 (read -> READ L_PAR readF .)
    VAR             reduce using rule 64 (read -> READ L_PAR readF .)
    WHILE           reduce using rule 64 (read -> READ L_PAR readF .)
    FROM            reduce using rule 64 (read -> READ L_PAR readF .)
    R_CURPAR        reduce using rule 64 (read -> READ L_PAR readF .)
    SEMICOLON       reduce using rule 64 (read -> READ L_PAR readF .)


state 165

    (65) readF -> var . np_addRead COMMA readF
    (66) readF -> var . np_addRead R_PAR SEMICOLON empty
    (136) np_addRead -> .

    COMMA           reduce using rule 136 (np_addRead -> .)
    R_PAR           reduce using rule 136 (np_addRead -> .)

    np_addRead                     shift and go to state 211

state 166

    (67) write -> WRITE L_PAR writeT .

    ID              reduce using rule 67 (write -> WRITE L_PAR writeT .)
    RETURN          reduce using rule 67 (write -> WRITE L_PAR writeT .)
    READ            reduce using rule 67 (write -> WRITE L_PAR writeT .)
    WRITE           reduce using rule 67 (write -> WRITE L_PAR writeT .)
    IF              reduce using rule 67 (write -> WRITE L_PAR writeT .)
    VAR             reduce using rule 67 (write -> WRITE L_PAR writeT .)
    WHILE           reduce using rule 67 (write -> WRITE L_PAR writeT .)
    FROM            reduce using rule 67 (write -> WRITE L_PAR writeT .)
    R_CURPAR        reduce using rule 67 (write -> WRITE L_PAR writeT .)
    SEMICOLON       reduce using rule 67 (write -> WRITE L_PAR writeT .)


state 167

    (68) writeT -> CTE_STRING . writeF
    (70) writeF -> . COMMA writeT
    (71) writeF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 213
    R_PAR           shift and go to state 214

    writeF                         shift and go to state 212

state 168

    (69) writeT -> exp . writeF
    (70) writeF -> . COMMA writeT
    (71) writeF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 213
    R_PAR           shift and go to state 214

    writeF                         shift and go to state 215

state 169

    (74) if -> IF L_PAR exp . R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    R_PAR           shift and go to state 216


state 170

    (62) varF -> arrfunc empty .

    EQUAL           reduce using rule 62 (varF -> arrfunc empty .)
    PLUS_EQ         reduce using rule 62 (varF -> arrfunc empty .)
    MIN_EQ          reduce using rule 62 (varF -> arrfunc empty .)
    MULT_EQ         reduce using rule 62 (varF -> arrfunc empty .)
    DIV_EQ          reduce using rule 62 (varF -> arrfunc empty .)
    MULT            reduce using rule 62 (varF -> arrfunc empty .)
    DIV             reduce using rule 62 (varF -> arrfunc empty .)
    PLUS            reduce using rule 62 (varF -> arrfunc empty .)
    MINUS           reduce using rule 62 (varF -> arrfunc empty .)
    LESS            reduce using rule 62 (varF -> arrfunc empty .)
    GREATER         reduce using rule 62 (varF -> arrfunc empty .)
    LESS_TH         reduce using rule 62 (varF -> arrfunc empty .)
    GREAT_TH        reduce using rule 62 (varF -> arrfunc empty .)
    SAME            reduce using rule 62 (varF -> arrfunc empty .)
    DIF             reduce using rule 62 (varF -> arrfunc empty .)
    OR              reduce using rule 62 (varF -> arrfunc empty .)
    AND             reduce using rule 62 (varF -> arrfunc empty .)
    COMMA           reduce using rule 62 (varF -> arrfunc empty .)
    R_PAR           reduce using rule 62 (varF -> arrfunc empty .)
    R_BREAK         reduce using rule 62 (varF -> arrfunc empty .)
    TO              reduce using rule 62 (varF -> arrfunc empty .)
    ID              reduce using rule 62 (varF -> arrfunc empty .)
    RETURN          reduce using rule 62 (varF -> arrfunc empty .)
    READ            reduce using rule 62 (varF -> arrfunc empty .)
    WRITE           reduce using rule 62 (varF -> arrfunc empty .)
    IF              reduce using rule 62 (varF -> arrfunc empty .)
    VAR             reduce using rule 62 (varF -> arrfunc empty .)
    WHILE           reduce using rule 62 (varF -> arrfunc empty .)
    FROM            reduce using rule 62 (varF -> arrfunc empty .)
    R_CURPAR        reduce using rule 62 (varF -> arrfunc empty .)
    SEMICOLON       reduce using rule 62 (varF -> arrfunc empty .)
    DO              reduce using rule 62 (varF -> arrfunc empty .)


state 171

    (54) arrfunc -> L_BREAK exp . COMMA exp R_BREAK empty
    (55) arrfunc -> L_BREAK exp . R_BREAK empty

    COMMA           shift and go to state 217
    R_BREAK         shift and go to state 218


state 172

    (84) conditional -> WHILE L_PAR exp . R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty

    R_PAR           shift and go to state 219


state 173

    (85) nonconditional -> FROM VAR arrfunc . nonconditionalF
    (87) nonconditionalF -> . exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    nonconditionalF                shift and go to state 220
    exp                            shift and go to state 175
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 174

    (86) nonconditional -> FROM VAR nonconditionalF .

    ID              reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    RETURN          reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    READ            reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    WRITE           reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    IF              reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    VAR             reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    WHILE           reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    FROM            reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    R_CURPAR        reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)
    SEMICOLON       reduce using rule 86 (nonconditional -> FROM VAR nonconditionalF .)


state 175

    (87) nonconditionalF -> exp . TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty

    TO              shift and go to state 221


state 176

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func . R_CURPAR SEMICOLON empty

    R_CURPAR        shift and go to state 222


state 177

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec . dec
    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec . np_addToDic empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF
    (126) np_addToDic -> .

    VAR             shift and go to state 27
    MAIN            reduce using rule 126 (np_addToDic -> .)
    INT             reduce using rule 126 (np_addToDic -> .)
    FLOAT           reduce using rule 126 (np_addToDic -> .)
    CHAR            reduce using rule 126 (np_addToDic -> .)
    BOOL            reduce using rule 126 (np_addToDic -> .)
    ID              reduce using rule 126 (np_addToDic -> .)
    VOID            reduce using rule 126 (np_addToDic -> .)
    METHODS         reduce using rule 126 (np_addToDic -> .)
    L_CURPAR        reduce using rule 126 (np_addToDic -> .)

    dec                            shift and go to state 223
    np_addToDic                    shift and go to state 224

state 178

    (22) arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .

    COMMA           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)
    COLON           reduce using rule 22 (arr -> L_BREAK CTE_INT COMMA CTE_INT R_BREAK empty .)


state 179

    (25) funcF -> parameter R_PAR . SEMICOLON dec L_CURPAR statement R_CURPAR empty

    SEMICOLON       shift and go to state 225


state 180

    (26) funcF -> R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 226

state 181

    (33) parameter -> VAR COLON . typepar SEMICOLON parameterF
    (36) typepar -> . INT empty
    (37) typepar -> . FLOAT empty
    (38) typepar -> . CHAR empty
    (39) typepar -> . BOOL empty
    (40) typepar -> . ID empty

    INT             shift and go to state 228
    FLOAT           shift and go to state 229
    CHAR            shift and go to state 230
    BOOL            shift and go to state 231
    ID              shift and go to state 232

    typepar                        shift and go to state 227

state 182

    (78) assigmentF -> EQUAL np_addOp . exp np_doAssign empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    exp                            shift and go to state 233
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 183

    (79) assigmentF -> ope np_addOp . exp np_doAssign empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    exp                            shift and go to state 234
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 184

    (80) ope -> PLUS_EQ empty .

    L_PAR           reduce using rule 80 (ope -> PLUS_EQ empty .)
    PLUS            reduce using rule 80 (ope -> PLUS_EQ empty .)
    MINUS           reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_INT         reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_FLOAT       reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_CHAR        reduce using rule 80 (ope -> PLUS_EQ empty .)
    CTE_BOOL        reduce using rule 80 (ope -> PLUS_EQ empty .)
    VAR             reduce using rule 80 (ope -> PLUS_EQ empty .)
    ID              reduce using rule 80 (ope -> PLUS_EQ empty .)


state 185

    (81) ope -> MIN_EQ empty .

    L_PAR           reduce using rule 81 (ope -> MIN_EQ empty .)
    PLUS            reduce using rule 81 (ope -> MIN_EQ empty .)
    MINUS           reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_INT         reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_FLOAT       reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_CHAR        reduce using rule 81 (ope -> MIN_EQ empty .)
    CTE_BOOL        reduce using rule 81 (ope -> MIN_EQ empty .)
    VAR             reduce using rule 81 (ope -> MIN_EQ empty .)
    ID              reduce using rule 81 (ope -> MIN_EQ empty .)


state 186

    (82) ope -> MULT_EQ empty .

    L_PAR           reduce using rule 82 (ope -> MULT_EQ empty .)
    PLUS            reduce using rule 82 (ope -> MULT_EQ empty .)
    MINUS           reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_INT         reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_FLOAT       reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_CHAR        reduce using rule 82 (ope -> MULT_EQ empty .)
    CTE_BOOL        reduce using rule 82 (ope -> MULT_EQ empty .)
    VAR             reduce using rule 82 (ope -> MULT_EQ empty .)
    ID              reduce using rule 82 (ope -> MULT_EQ empty .)


state 187

    (83) ope -> DIV_EQ empty .

    L_PAR           reduce using rule 83 (ope -> DIV_EQ empty .)
    PLUS            reduce using rule 83 (ope -> DIV_EQ empty .)
    MINUS           reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_INT         reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_FLOAT       reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_CHAR        reduce using rule 83 (ope -> DIV_EQ empty .)
    CTE_BOOL        reduce using rule 83 (ope -> DIV_EQ empty .)
    VAR             reduce using rule 83 (ope -> DIV_EQ empty .)
    ID              reduce using rule 83 (ope -> DIV_EQ empty .)


state 188

    (51) void -> ID DOT ID L_PAR . param R_PAR SEMICOLON empty
    (56) param -> . exp paramF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    param                          shift and go to state 235
    exp                            shift and go to state 147
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 189

    (61) var -> ID DOT VAR varF .

    EQUAL           reduce using rule 61 (var -> ID DOT VAR varF .)
    PLUS_EQ         reduce using rule 61 (var -> ID DOT VAR varF .)
    MIN_EQ          reduce using rule 61 (var -> ID DOT VAR varF .)
    MULT_EQ         reduce using rule 61 (var -> ID DOT VAR varF .)
    DIV_EQ          reduce using rule 61 (var -> ID DOT VAR varF .)
    MULT            reduce using rule 61 (var -> ID DOT VAR varF .)
    DIV             reduce using rule 61 (var -> ID DOT VAR varF .)
    PLUS            reduce using rule 61 (var -> ID DOT VAR varF .)
    MINUS           reduce using rule 61 (var -> ID DOT VAR varF .)
    LESS            reduce using rule 61 (var -> ID DOT VAR varF .)
    GREATER         reduce using rule 61 (var -> ID DOT VAR varF .)
    LESS_TH         reduce using rule 61 (var -> ID DOT VAR varF .)
    GREAT_TH        reduce using rule 61 (var -> ID DOT VAR varF .)
    SAME            reduce using rule 61 (var -> ID DOT VAR varF .)
    DIF             reduce using rule 61 (var -> ID DOT VAR varF .)
    OR              reduce using rule 61 (var -> ID DOT VAR varF .)
    AND             reduce using rule 61 (var -> ID DOT VAR varF .)
    COMMA           reduce using rule 61 (var -> ID DOT VAR varF .)
    R_PAR           reduce using rule 61 (var -> ID DOT VAR varF .)
    R_BREAK         reduce using rule 61 (var -> ID DOT VAR varF .)
    TO              reduce using rule 61 (var -> ID DOT VAR varF .)
    ID              reduce using rule 61 (var -> ID DOT VAR varF .)
    RETURN          reduce using rule 61 (var -> ID DOT VAR varF .)
    READ            reduce using rule 61 (var -> ID DOT VAR varF .)
    WRITE           reduce using rule 61 (var -> ID DOT VAR varF .)
    IF              reduce using rule 61 (var -> ID DOT VAR varF .)
    VAR             reduce using rule 61 (var -> ID DOT VAR varF .)
    WHILE           reduce using rule 61 (var -> ID DOT VAR varF .)
    FROM            reduce using rule 61 (var -> ID DOT VAR varF .)
    R_CURPAR        reduce using rule 61 (var -> ID DOT VAR varF .)
    SEMICOLON       reduce using rule 61 (var -> ID DOT VAR varF .)
    DO              reduce using rule 61 (var -> ID DOT VAR varF .)


state 190

    (61) var -> ID DOT . VAR varF

    VAR             shift and go to state 142


state 191

    (109) factor -> L_PAR np_addPar . exp R_PAR np_popPar empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    exp                            shift and go to state 236
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 192

    (52) void -> ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 237


state 193

    (53) void -> ID L_PAR R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 238

state 194

    (56) param -> exp paramF .

    R_PAR           reduce using rule 56 (param -> exp paramF .)


state 195

    (57) paramF -> COMMA . param
    (56) param -> . exp paramF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    param                          shift and go to state 239
    exp                            shift and go to state 147
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 196

    (58) paramF -> empty .

    R_PAR           reduce using rule 58 (paramF -> empty .)


state 197

    (100) exp -> bool empty .

    COMMA           reduce using rule 100 (exp -> bool empty .)
    R_PAR           reduce using rule 100 (exp -> bool empty .)
    R_BREAK         reduce using rule 100 (exp -> bool empty .)
    TO              reduce using rule 100 (exp -> bool empty .)
    ID              reduce using rule 100 (exp -> bool empty .)
    RETURN          reduce using rule 100 (exp -> bool empty .)
    READ            reduce using rule 100 (exp -> bool empty .)
    WRITE           reduce using rule 100 (exp -> bool empty .)
    IF              reduce using rule 100 (exp -> bool empty .)
    VAR             reduce using rule 100 (exp -> bool empty .)
    WHILE           reduce using rule 100 (exp -> bool empty .)
    FROM            reduce using rule 100 (exp -> bool empty .)
    R_CURPAR        reduce using rule 100 (exp -> bool empty .)
    SEMICOLON       reduce using rule 100 (exp -> bool empty .)
    DO              reduce using rule 100 (exp -> bool empty .)


state 198

    (88) bool -> logical np_addBool . boolF
    (89) boolF -> . OR np_addOp bool
    (90) boolF -> . AND np_addOp bool
    (91) boolF -> . empty
    (120) empty -> .

    OR              shift and go to state 241
    AND             shift and go to state 242
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    boolF                          shift and go to state 240
    empty                          shift and go to state 243

state 199

    (92) logical -> ex np_addLogical . logicalF
    (93) logicalF -> . LESS np_addOp logical
    (94) logicalF -> . GREATER np_addOp logical
    (95) logicalF -> . LESS_TH np_addOp logical
    (96) logicalF -> . GREAT_TH np_addOp logical
    (97) logicalF -> . SAME np_addOp logical
    (98) logicalF -> . DIF np_addOp logical
    (99) logicalF -> . empty
    (120) empty -> .

    LESS            shift and go to state 245
    GREATER         shift and go to state 246
    LESS_TH         shift and go to state 247
    GREAT_TH        shift and go to state 248
    SAME            shift and go to state 249
    DIF             shift and go to state 250
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    logicalF                       shift and go to state 244
    empty                          shift and go to state 251

state 200

    (101) ex -> term np_addEx . exF
    (102) exF -> . PLUS np_addOp ex
    (103) exF -> . MINUS np_addOp ex
    (104) exF -> . empty
    (120) empty -> .

    PLUS            shift and go to state 253
    MINUS           shift and go to state 254
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    exF                            shift and go to state 252
    empty                          shift and go to state 255

state 201

    (105) term -> factor np_addTerm . termF
    (106) termF -> . MULT np_addOp term
    (107) termF -> . DIV np_addOp term
    (108) termF -> . empty
    (120) empty -> .

    MULT            shift and go to state 257
    DIV             shift and go to state 258
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    termF                          shift and go to state 256
    empty                          shift and go to state 259

state 202

    (111) factorT -> PLUS factorF .

    MULT            reduce using rule 111 (factorT -> PLUS factorF .)
    DIV             reduce using rule 111 (factorT -> PLUS factorF .)
    PLUS            reduce using rule 111 (factorT -> PLUS factorF .)
    MINUS           reduce using rule 111 (factorT -> PLUS factorF .)
    LESS            reduce using rule 111 (factorT -> PLUS factorF .)
    GREATER         reduce using rule 111 (factorT -> PLUS factorF .)
    LESS_TH         reduce using rule 111 (factorT -> PLUS factorF .)
    GREAT_TH        reduce using rule 111 (factorT -> PLUS factorF .)
    SAME            reduce using rule 111 (factorT -> PLUS factorF .)
    DIF             reduce using rule 111 (factorT -> PLUS factorF .)
    OR              reduce using rule 111 (factorT -> PLUS factorF .)
    AND             reduce using rule 111 (factorT -> PLUS factorF .)
    COMMA           reduce using rule 111 (factorT -> PLUS factorF .)
    R_PAR           reduce using rule 111 (factorT -> PLUS factorF .)
    R_BREAK         reduce using rule 111 (factorT -> PLUS factorF .)
    TO              reduce using rule 111 (factorT -> PLUS factorF .)
    ID              reduce using rule 111 (factorT -> PLUS factorF .)
    RETURN          reduce using rule 111 (factorT -> PLUS factorF .)
    READ            reduce using rule 111 (factorT -> PLUS factorF .)
    WRITE           reduce using rule 111 (factorT -> PLUS factorF .)
    IF              reduce using rule 111 (factorT -> PLUS factorF .)
    VAR             reduce using rule 111 (factorT -> PLUS factorF .)
    WHILE           reduce using rule 111 (factorT -> PLUS factorF .)
    FROM            reduce using rule 111 (factorT -> PLUS factorF .)
    R_CURPAR        reduce using rule 111 (factorT -> PLUS factorF .)
    SEMICOLON       reduce using rule 111 (factorT -> PLUS factorF .)
    DO              reduce using rule 111 (factorT -> PLUS factorF .)


state 203

    (112) factorT -> MINUS factorF .

    MULT            reduce using rule 112 (factorT -> MINUS factorF .)
    DIV             reduce using rule 112 (factorT -> MINUS factorF .)
    PLUS            reduce using rule 112 (factorT -> MINUS factorF .)
    MINUS           reduce using rule 112 (factorT -> MINUS factorF .)
    LESS            reduce using rule 112 (factorT -> MINUS factorF .)
    GREATER         reduce using rule 112 (factorT -> MINUS factorF .)
    LESS_TH         reduce using rule 112 (factorT -> MINUS factorF .)
    GREAT_TH        reduce using rule 112 (factorT -> MINUS factorF .)
    SAME            reduce using rule 112 (factorT -> MINUS factorF .)
    DIF             reduce using rule 112 (factorT -> MINUS factorF .)
    OR              reduce using rule 112 (factorT -> MINUS factorF .)
    AND             reduce using rule 112 (factorT -> MINUS factorF .)
    COMMA           reduce using rule 112 (factorT -> MINUS factorF .)
    R_PAR           reduce using rule 112 (factorT -> MINUS factorF .)
    R_BREAK         reduce using rule 112 (factorT -> MINUS factorF .)
    TO              reduce using rule 112 (factorT -> MINUS factorF .)
    ID              reduce using rule 112 (factorT -> MINUS factorF .)
    RETURN          reduce using rule 112 (factorT -> MINUS factorF .)
    READ            reduce using rule 112 (factorT -> MINUS factorF .)
    WRITE           reduce using rule 112 (factorT -> MINUS factorF .)
    IF              reduce using rule 112 (factorT -> MINUS factorF .)
    VAR             reduce using rule 112 (factorT -> MINUS factorF .)
    WHILE           reduce using rule 112 (factorT -> MINUS factorF .)
    FROM            reduce using rule 112 (factorT -> MINUS factorF .)
    R_CURPAR        reduce using rule 112 (factorT -> MINUS factorF .)
    SEMICOLON       reduce using rule 112 (factorT -> MINUS factorF .)
    DO              reduce using rule 112 (factorT -> MINUS factorF .)


state 204

    (114) factorF -> varcte empty .

    MULT            reduce using rule 114 (factorF -> varcte empty .)
    DIV             reduce using rule 114 (factorF -> varcte empty .)
    PLUS            reduce using rule 114 (factorF -> varcte empty .)
    MINUS           reduce using rule 114 (factorF -> varcte empty .)
    LESS            reduce using rule 114 (factorF -> varcte empty .)
    GREATER         reduce using rule 114 (factorF -> varcte empty .)
    LESS_TH         reduce using rule 114 (factorF -> varcte empty .)
    GREAT_TH        reduce using rule 114 (factorF -> varcte empty .)
    SAME            reduce using rule 114 (factorF -> varcte empty .)
    DIF             reduce using rule 114 (factorF -> varcte empty .)
    OR              reduce using rule 114 (factorF -> varcte empty .)
    AND             reduce using rule 114 (factorF -> varcte empty .)
    COMMA           reduce using rule 114 (factorF -> varcte empty .)
    R_PAR           reduce using rule 114 (factorF -> varcte empty .)
    R_BREAK         reduce using rule 114 (factorF -> varcte empty .)
    TO              reduce using rule 114 (factorF -> varcte empty .)
    ID              reduce using rule 114 (factorF -> varcte empty .)
    RETURN          reduce using rule 114 (factorF -> varcte empty .)
    READ            reduce using rule 114 (factorF -> varcte empty .)
    WRITE           reduce using rule 114 (factorF -> varcte empty .)
    IF              reduce using rule 114 (factorF -> varcte empty .)
    VAR             reduce using rule 114 (factorF -> varcte empty .)
    WHILE           reduce using rule 114 (factorF -> varcte empty .)
    FROM            reduce using rule 114 (factorF -> varcte empty .)
    R_CURPAR        reduce using rule 114 (factorF -> varcte empty .)
    SEMICOLON       reduce using rule 114 (factorF -> varcte empty .)
    DO              reduce using rule 114 (factorF -> varcte empty .)


state 205

    (115) varcte -> var np_addId . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 260

state 206

    (116) varcte -> CTE_INT empty .

    MULT            reduce using rule 116 (varcte -> CTE_INT empty .)
    DIV             reduce using rule 116 (varcte -> CTE_INT empty .)
    PLUS            reduce using rule 116 (varcte -> CTE_INT empty .)
    MINUS           reduce using rule 116 (varcte -> CTE_INT empty .)
    LESS            reduce using rule 116 (varcte -> CTE_INT empty .)
    GREATER         reduce using rule 116 (varcte -> CTE_INT empty .)
    LESS_TH         reduce using rule 116 (varcte -> CTE_INT empty .)
    GREAT_TH        reduce using rule 116 (varcte -> CTE_INT empty .)
    SAME            reduce using rule 116 (varcte -> CTE_INT empty .)
    DIF             reduce using rule 116 (varcte -> CTE_INT empty .)
    OR              reduce using rule 116 (varcte -> CTE_INT empty .)
    AND             reduce using rule 116 (varcte -> CTE_INT empty .)
    COMMA           reduce using rule 116 (varcte -> CTE_INT empty .)
    R_PAR           reduce using rule 116 (varcte -> CTE_INT empty .)
    R_BREAK         reduce using rule 116 (varcte -> CTE_INT empty .)
    TO              reduce using rule 116 (varcte -> CTE_INT empty .)
    ID              reduce using rule 116 (varcte -> CTE_INT empty .)
    RETURN          reduce using rule 116 (varcte -> CTE_INT empty .)
    READ            reduce using rule 116 (varcte -> CTE_INT empty .)
    WRITE           reduce using rule 116 (varcte -> CTE_INT empty .)
    IF              reduce using rule 116 (varcte -> CTE_INT empty .)
    VAR             reduce using rule 116 (varcte -> CTE_INT empty .)
    WHILE           reduce using rule 116 (varcte -> CTE_INT empty .)
    FROM            reduce using rule 116 (varcte -> CTE_INT empty .)
    R_CURPAR        reduce using rule 116 (varcte -> CTE_INT empty .)
    SEMICOLON       reduce using rule 116 (varcte -> CTE_INT empty .)
    DO              reduce using rule 116 (varcte -> CTE_INT empty .)


state 207

    (117) varcte -> CTE_FLOAT empty .

    MULT            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    DIV             reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    PLUS            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    MINUS           reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    LESS            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    GREATER         reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    LESS_TH         reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    GREAT_TH        reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    SAME            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    DIF             reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    OR              reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    AND             reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    COMMA           reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    R_PAR           reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    R_BREAK         reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    TO              reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    ID              reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    RETURN          reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    READ            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    WRITE           reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    IF              reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    VAR             reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    WHILE           reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    FROM            reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    R_CURPAR        reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    SEMICOLON       reduce using rule 117 (varcte -> CTE_FLOAT empty .)
    DO              reduce using rule 117 (varcte -> CTE_FLOAT empty .)


state 208

    (118) varcte -> CTE_CHAR empty .

    MULT            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    DIV             reduce using rule 118 (varcte -> CTE_CHAR empty .)
    PLUS            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    MINUS           reduce using rule 118 (varcte -> CTE_CHAR empty .)
    LESS            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    GREATER         reduce using rule 118 (varcte -> CTE_CHAR empty .)
    LESS_TH         reduce using rule 118 (varcte -> CTE_CHAR empty .)
    GREAT_TH        reduce using rule 118 (varcte -> CTE_CHAR empty .)
    SAME            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    DIF             reduce using rule 118 (varcte -> CTE_CHAR empty .)
    OR              reduce using rule 118 (varcte -> CTE_CHAR empty .)
    AND             reduce using rule 118 (varcte -> CTE_CHAR empty .)
    COMMA           reduce using rule 118 (varcte -> CTE_CHAR empty .)
    R_PAR           reduce using rule 118 (varcte -> CTE_CHAR empty .)
    R_BREAK         reduce using rule 118 (varcte -> CTE_CHAR empty .)
    TO              reduce using rule 118 (varcte -> CTE_CHAR empty .)
    ID              reduce using rule 118 (varcte -> CTE_CHAR empty .)
    RETURN          reduce using rule 118 (varcte -> CTE_CHAR empty .)
    READ            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    WRITE           reduce using rule 118 (varcte -> CTE_CHAR empty .)
    IF              reduce using rule 118 (varcte -> CTE_CHAR empty .)
    VAR             reduce using rule 118 (varcte -> CTE_CHAR empty .)
    WHILE           reduce using rule 118 (varcte -> CTE_CHAR empty .)
    FROM            reduce using rule 118 (varcte -> CTE_CHAR empty .)
    R_CURPAR        reduce using rule 118 (varcte -> CTE_CHAR empty .)
    SEMICOLON       reduce using rule 118 (varcte -> CTE_CHAR empty .)
    DO              reduce using rule 118 (varcte -> CTE_CHAR empty .)


state 209

    (119) varcte -> CTE_BOOL empty .

    MULT            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    DIV             reduce using rule 119 (varcte -> CTE_BOOL empty .)
    PLUS            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    MINUS           reduce using rule 119 (varcte -> CTE_BOOL empty .)
    LESS            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    GREATER         reduce using rule 119 (varcte -> CTE_BOOL empty .)
    LESS_TH         reduce using rule 119 (varcte -> CTE_BOOL empty .)
    GREAT_TH        reduce using rule 119 (varcte -> CTE_BOOL empty .)
    SAME            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    DIF             reduce using rule 119 (varcte -> CTE_BOOL empty .)
    OR              reduce using rule 119 (varcte -> CTE_BOOL empty .)
    AND             reduce using rule 119 (varcte -> CTE_BOOL empty .)
    COMMA           reduce using rule 119 (varcte -> CTE_BOOL empty .)
    R_PAR           reduce using rule 119 (varcte -> CTE_BOOL empty .)
    R_BREAK         reduce using rule 119 (varcte -> CTE_BOOL empty .)
    TO              reduce using rule 119 (varcte -> CTE_BOOL empty .)
    ID              reduce using rule 119 (varcte -> CTE_BOOL empty .)
    RETURN          reduce using rule 119 (varcte -> CTE_BOOL empty .)
    READ            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    WRITE           reduce using rule 119 (varcte -> CTE_BOOL empty .)
    IF              reduce using rule 119 (varcte -> CTE_BOOL empty .)
    VAR             reduce using rule 119 (varcte -> CTE_BOOL empty .)
    WHILE           reduce using rule 119 (varcte -> CTE_BOOL empty .)
    FROM            reduce using rule 119 (varcte -> CTE_BOOL empty .)
    R_CURPAR        reduce using rule 119 (varcte -> CTE_BOOL empty .)
    SEMICOLON       reduce using rule 119 (varcte -> CTE_BOOL empty .)
    DO              reduce using rule 119 (varcte -> CTE_BOOL empty .)


state 210

    (59) return -> RETURN L_PAR exp R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 261


state 211

    (65) readF -> var np_addRead . COMMA readF
    (66) readF -> var np_addRead . R_PAR SEMICOLON empty

    COMMA           shift and go to state 262
    R_PAR           shift and go to state 263


state 212

    (68) writeT -> CTE_STRING writeF .

    ID              reduce using rule 68 (writeT -> CTE_STRING writeF .)
    RETURN          reduce using rule 68 (writeT -> CTE_STRING writeF .)
    READ            reduce using rule 68 (writeT -> CTE_STRING writeF .)
    WRITE           reduce using rule 68 (writeT -> CTE_STRING writeF .)
    IF              reduce using rule 68 (writeT -> CTE_STRING writeF .)
    VAR             reduce using rule 68 (writeT -> CTE_STRING writeF .)
    WHILE           reduce using rule 68 (writeT -> CTE_STRING writeF .)
    FROM            reduce using rule 68 (writeT -> CTE_STRING writeF .)
    R_CURPAR        reduce using rule 68 (writeT -> CTE_STRING writeF .)
    SEMICOLON       reduce using rule 68 (writeT -> CTE_STRING writeF .)


state 213

    (70) writeF -> COMMA . writeT
    (68) writeT -> . CTE_STRING writeF
    (69) writeT -> . exp writeF
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    CTE_STRING      shift and go to state 167
    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    writeT                         shift and go to state 264
    exp                            shift and go to state 168
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 214

    (71) writeF -> R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 265


state 215

    (69) writeT -> exp writeF .

    ID              reduce using rule 69 (writeT -> exp writeF .)
    RETURN          reduce using rule 69 (writeT -> exp writeF .)
    READ            reduce using rule 69 (writeT -> exp writeF .)
    WRITE           reduce using rule 69 (writeT -> exp writeF .)
    IF              reduce using rule 69 (writeT -> exp writeF .)
    VAR             reduce using rule 69 (writeT -> exp writeF .)
    WHILE           reduce using rule 69 (writeT -> exp writeF .)
    FROM            reduce using rule 69 (writeT -> exp writeF .)
    R_CURPAR        reduce using rule 69 (writeT -> exp writeF .)
    SEMICOLON       reduce using rule 69 (writeT -> exp writeF .)


state 216

    (74) if -> IF L_PAR exp R_PAR . THEN L_CURPAR statement SEMICOLON R_CURPAR ifF

    THEN            shift and go to state 266


state 217

    (54) arrfunc -> L_BREAK exp COMMA . exp R_BREAK empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    exp                            shift and go to state 267
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 218

    (55) arrfunc -> L_BREAK exp R_BREAK . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)
    L_PAR           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 268

state 219

    (84) conditional -> WHILE L_PAR exp R_PAR . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 269


state 220

    (85) nonconditional -> FROM VAR arrfunc nonconditionalF .

    ID              reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    RETURN          reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    READ            reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WRITE           reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    IF              reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    VAR             reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    WHILE           reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    FROM            reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    R_CURPAR        reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)
    SEMICOLON       reduce using rule 85 (nonconditional -> FROM VAR arrfunc nonconditionalF .)


state 221

    (87) nonconditionalF -> exp TO . exp DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (100) exp -> . bool empty
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    exp                            shift and go to state 270
    bool                           shift and go to state 148
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 222

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR . SEMICOLON empty

    SEMICOLON       shift and go to state 271


state 223

    (15) decF -> COLON type np_getVarType SEMICOLON np_getDec dec .

    MAIN            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    INT             reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    FLOAT           reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    CHAR            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    BOOL            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    ID              reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    VOID            reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    METHODS         reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)
    L_CURPAR        reduce using rule 15 (decF -> COLON type np_getVarType SEMICOLON np_getDec dec .)


state 224

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    METHODS         reduce using rule 120 (empty -> .)
    L_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 272

state 225

    (25) funcF -> parameter R_PAR SEMICOLON . dec L_CURPAR statement R_CURPAR empty
    (12) dec -> . VAR arr np_getDecArr decF
    (13) dec -> . VAR np_getDec decF

    VAR             shift and go to state 27

    dec                            shift and go to state 273

state 226

    (26) funcF -> R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 274


state 227

    (33) parameter -> VAR COLON typepar . SEMICOLON parameterF

    SEMICOLON       shift and go to state 275


state 228

    (36) typepar -> INT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 276

state 229

    (37) typepar -> FLOAT . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 277

state 230

    (38) typepar -> CHAR . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 278

state 231

    (39) typepar -> BOOL . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 279

state 232

    (40) typepar -> ID . empty
    (120) empty -> .

    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 280

state 233

    (78) assigmentF -> EQUAL np_addOp exp . np_doAssign empty
    (135) np_doAssign -> .

    ID              reduce using rule 135 (np_doAssign -> .)
    RETURN          reduce using rule 135 (np_doAssign -> .)
    READ            reduce using rule 135 (np_doAssign -> .)
    WRITE           reduce using rule 135 (np_doAssign -> .)
    IF              reduce using rule 135 (np_doAssign -> .)
    VAR             reduce using rule 135 (np_doAssign -> .)
    WHILE           reduce using rule 135 (np_doAssign -> .)
    FROM            reduce using rule 135 (np_doAssign -> .)
    R_CURPAR        reduce using rule 135 (np_doAssign -> .)
    SEMICOLON       reduce using rule 135 (np_doAssign -> .)

    np_doAssign                    shift and go to state 281

state 234

    (79) assigmentF -> ope np_addOp exp . np_doAssign empty
    (135) np_doAssign -> .

    ID              reduce using rule 135 (np_doAssign -> .)
    RETURN          reduce using rule 135 (np_doAssign -> .)
    READ            reduce using rule 135 (np_doAssign -> .)
    WRITE           reduce using rule 135 (np_doAssign -> .)
    IF              reduce using rule 135 (np_doAssign -> .)
    VAR             reduce using rule 135 (np_doAssign -> .)
    WHILE           reduce using rule 135 (np_doAssign -> .)
    FROM            reduce using rule 135 (np_doAssign -> .)
    R_CURPAR        reduce using rule 135 (np_doAssign -> .)
    SEMICOLON       reduce using rule 135 (np_doAssign -> .)

    np_doAssign                    shift and go to state 282

state 235

    (51) void -> ID DOT ID L_PAR param . R_PAR SEMICOLON empty

    R_PAR           shift and go to state 283


state 236

    (109) factor -> L_PAR np_addPar exp . R_PAR np_popPar empty

    R_PAR           shift and go to state 284


state 237

    (52) void -> ID L_PAR param R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 285

state 238

    (53) void -> ID L_PAR R_PAR SEMICOLON empty .

    ID              reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    READ            reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    IF              reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    VAR             reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    FROM            reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 53 (void -> ID L_PAR R_PAR SEMICOLON empty .)


state 239

    (57) paramF -> COMMA param .

    R_PAR           reduce using rule 57 (paramF -> COMMA param .)


state 240

    (88) bool -> logical np_addBool boolF .

    COMMA           reduce using rule 88 (bool -> logical np_addBool boolF .)
    R_PAR           reduce using rule 88 (bool -> logical np_addBool boolF .)
    R_BREAK         reduce using rule 88 (bool -> logical np_addBool boolF .)
    TO              reduce using rule 88 (bool -> logical np_addBool boolF .)
    ID              reduce using rule 88 (bool -> logical np_addBool boolF .)
    RETURN          reduce using rule 88 (bool -> logical np_addBool boolF .)
    READ            reduce using rule 88 (bool -> logical np_addBool boolF .)
    WRITE           reduce using rule 88 (bool -> logical np_addBool boolF .)
    IF              reduce using rule 88 (bool -> logical np_addBool boolF .)
    VAR             reduce using rule 88 (bool -> logical np_addBool boolF .)
    WHILE           reduce using rule 88 (bool -> logical np_addBool boolF .)
    FROM            reduce using rule 88 (bool -> logical np_addBool boolF .)
    R_CURPAR        reduce using rule 88 (bool -> logical np_addBool boolF .)
    SEMICOLON       reduce using rule 88 (bool -> logical np_addBool boolF .)
    DO              reduce using rule 88 (bool -> logical np_addBool boolF .)


state 241

    (89) boolF -> OR . np_addOp bool
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 286

state 242

    (90) boolF -> AND . np_addOp bool
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 287

state 243

    (91) boolF -> empty .

    COMMA           reduce using rule 91 (boolF -> empty .)
    R_PAR           reduce using rule 91 (boolF -> empty .)
    R_BREAK         reduce using rule 91 (boolF -> empty .)
    TO              reduce using rule 91 (boolF -> empty .)
    ID              reduce using rule 91 (boolF -> empty .)
    RETURN          reduce using rule 91 (boolF -> empty .)
    READ            reduce using rule 91 (boolF -> empty .)
    WRITE           reduce using rule 91 (boolF -> empty .)
    IF              reduce using rule 91 (boolF -> empty .)
    VAR             reduce using rule 91 (boolF -> empty .)
    WHILE           reduce using rule 91 (boolF -> empty .)
    FROM            reduce using rule 91 (boolF -> empty .)
    R_CURPAR        reduce using rule 91 (boolF -> empty .)
    SEMICOLON       reduce using rule 91 (boolF -> empty .)
    DO              reduce using rule 91 (boolF -> empty .)


state 244

    (92) logical -> ex np_addLogical logicalF .

    OR              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    AND             reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    COMMA           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_PAR           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_BREAK         reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    TO              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    ID              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    RETURN          reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    READ            reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    WRITE           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    IF              reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    VAR             reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    WHILE           reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    FROM            reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    R_CURPAR        reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    SEMICOLON       reduce using rule 92 (logical -> ex np_addLogical logicalF .)
    DO              reduce using rule 92 (logical -> ex np_addLogical logicalF .)


state 245

    (93) logicalF -> LESS . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 288

state 246

    (94) logicalF -> GREATER . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 289

state 247

    (95) logicalF -> LESS_TH . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 290

state 248

    (96) logicalF -> GREAT_TH . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 291

state 249

    (97) logicalF -> SAME . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 292

state 250

    (98) logicalF -> DIF . np_addOp logical
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 293

state 251

    (99) logicalF -> empty .

    OR              reduce using rule 99 (logicalF -> empty .)
    AND             reduce using rule 99 (logicalF -> empty .)
    COMMA           reduce using rule 99 (logicalF -> empty .)
    R_PAR           reduce using rule 99 (logicalF -> empty .)
    R_BREAK         reduce using rule 99 (logicalF -> empty .)
    TO              reduce using rule 99 (logicalF -> empty .)
    ID              reduce using rule 99 (logicalF -> empty .)
    RETURN          reduce using rule 99 (logicalF -> empty .)
    READ            reduce using rule 99 (logicalF -> empty .)
    WRITE           reduce using rule 99 (logicalF -> empty .)
    IF              reduce using rule 99 (logicalF -> empty .)
    VAR             reduce using rule 99 (logicalF -> empty .)
    WHILE           reduce using rule 99 (logicalF -> empty .)
    FROM            reduce using rule 99 (logicalF -> empty .)
    R_CURPAR        reduce using rule 99 (logicalF -> empty .)
    SEMICOLON       reduce using rule 99 (logicalF -> empty .)
    DO              reduce using rule 99 (logicalF -> empty .)


state 252

    (101) ex -> term np_addEx exF .

    LESS            reduce using rule 101 (ex -> term np_addEx exF .)
    GREATER         reduce using rule 101 (ex -> term np_addEx exF .)
    LESS_TH         reduce using rule 101 (ex -> term np_addEx exF .)
    GREAT_TH        reduce using rule 101 (ex -> term np_addEx exF .)
    SAME            reduce using rule 101 (ex -> term np_addEx exF .)
    DIF             reduce using rule 101 (ex -> term np_addEx exF .)
    OR              reduce using rule 101 (ex -> term np_addEx exF .)
    AND             reduce using rule 101 (ex -> term np_addEx exF .)
    COMMA           reduce using rule 101 (ex -> term np_addEx exF .)
    R_PAR           reduce using rule 101 (ex -> term np_addEx exF .)
    R_BREAK         reduce using rule 101 (ex -> term np_addEx exF .)
    TO              reduce using rule 101 (ex -> term np_addEx exF .)
    ID              reduce using rule 101 (ex -> term np_addEx exF .)
    RETURN          reduce using rule 101 (ex -> term np_addEx exF .)
    READ            reduce using rule 101 (ex -> term np_addEx exF .)
    WRITE           reduce using rule 101 (ex -> term np_addEx exF .)
    IF              reduce using rule 101 (ex -> term np_addEx exF .)
    VAR             reduce using rule 101 (ex -> term np_addEx exF .)
    WHILE           reduce using rule 101 (ex -> term np_addEx exF .)
    FROM            reduce using rule 101 (ex -> term np_addEx exF .)
    R_CURPAR        reduce using rule 101 (ex -> term np_addEx exF .)
    SEMICOLON       reduce using rule 101 (ex -> term np_addEx exF .)
    DO              reduce using rule 101 (ex -> term np_addEx exF .)


state 253

    (102) exF -> PLUS . np_addOp ex
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 294

state 254

    (103) exF -> MINUS . np_addOp ex
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 295

state 255

    (104) exF -> empty .

    LESS            reduce using rule 104 (exF -> empty .)
    GREATER         reduce using rule 104 (exF -> empty .)
    LESS_TH         reduce using rule 104 (exF -> empty .)
    GREAT_TH        reduce using rule 104 (exF -> empty .)
    SAME            reduce using rule 104 (exF -> empty .)
    DIF             reduce using rule 104 (exF -> empty .)
    OR              reduce using rule 104 (exF -> empty .)
    AND             reduce using rule 104 (exF -> empty .)
    COMMA           reduce using rule 104 (exF -> empty .)
    R_PAR           reduce using rule 104 (exF -> empty .)
    R_BREAK         reduce using rule 104 (exF -> empty .)
    TO              reduce using rule 104 (exF -> empty .)
    ID              reduce using rule 104 (exF -> empty .)
    RETURN          reduce using rule 104 (exF -> empty .)
    READ            reduce using rule 104 (exF -> empty .)
    WRITE           reduce using rule 104 (exF -> empty .)
    IF              reduce using rule 104 (exF -> empty .)
    VAR             reduce using rule 104 (exF -> empty .)
    WHILE           reduce using rule 104 (exF -> empty .)
    FROM            reduce using rule 104 (exF -> empty .)
    R_CURPAR        reduce using rule 104 (exF -> empty .)
    SEMICOLON       reduce using rule 104 (exF -> empty .)
    DO              reduce using rule 104 (exF -> empty .)


state 256

    (105) term -> factor np_addTerm termF .

    PLUS            reduce using rule 105 (term -> factor np_addTerm termF .)
    MINUS           reduce using rule 105 (term -> factor np_addTerm termF .)
    LESS            reduce using rule 105 (term -> factor np_addTerm termF .)
    GREATER         reduce using rule 105 (term -> factor np_addTerm termF .)
    LESS_TH         reduce using rule 105 (term -> factor np_addTerm termF .)
    GREAT_TH        reduce using rule 105 (term -> factor np_addTerm termF .)
    SAME            reduce using rule 105 (term -> factor np_addTerm termF .)
    DIF             reduce using rule 105 (term -> factor np_addTerm termF .)
    OR              reduce using rule 105 (term -> factor np_addTerm termF .)
    AND             reduce using rule 105 (term -> factor np_addTerm termF .)
    COMMA           reduce using rule 105 (term -> factor np_addTerm termF .)
    R_PAR           reduce using rule 105 (term -> factor np_addTerm termF .)
    R_BREAK         reduce using rule 105 (term -> factor np_addTerm termF .)
    TO              reduce using rule 105 (term -> factor np_addTerm termF .)
    ID              reduce using rule 105 (term -> factor np_addTerm termF .)
    RETURN          reduce using rule 105 (term -> factor np_addTerm termF .)
    READ            reduce using rule 105 (term -> factor np_addTerm termF .)
    WRITE           reduce using rule 105 (term -> factor np_addTerm termF .)
    IF              reduce using rule 105 (term -> factor np_addTerm termF .)
    VAR             reduce using rule 105 (term -> factor np_addTerm termF .)
    WHILE           reduce using rule 105 (term -> factor np_addTerm termF .)
    FROM            reduce using rule 105 (term -> factor np_addTerm termF .)
    R_CURPAR        reduce using rule 105 (term -> factor np_addTerm termF .)
    SEMICOLON       reduce using rule 105 (term -> factor np_addTerm termF .)
    DO              reduce using rule 105 (term -> factor np_addTerm termF .)


state 257

    (106) termF -> MULT . np_addOp term
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 296

state 258

    (107) termF -> DIV . np_addOp term
    (128) np_addOp -> .

    L_PAR           reduce using rule 128 (np_addOp -> .)
    PLUS            reduce using rule 128 (np_addOp -> .)
    MINUS           reduce using rule 128 (np_addOp -> .)
    CTE_INT         reduce using rule 128 (np_addOp -> .)
    CTE_FLOAT       reduce using rule 128 (np_addOp -> .)
    CTE_CHAR        reduce using rule 128 (np_addOp -> .)
    CTE_BOOL        reduce using rule 128 (np_addOp -> .)
    VAR             reduce using rule 128 (np_addOp -> .)
    ID              reduce using rule 128 (np_addOp -> .)

    np_addOp                       shift and go to state 297

state 259

    (108) termF -> empty .

    PLUS            reduce using rule 108 (termF -> empty .)
    MINUS           reduce using rule 108 (termF -> empty .)
    LESS            reduce using rule 108 (termF -> empty .)
    GREATER         reduce using rule 108 (termF -> empty .)
    LESS_TH         reduce using rule 108 (termF -> empty .)
    GREAT_TH        reduce using rule 108 (termF -> empty .)
    SAME            reduce using rule 108 (termF -> empty .)
    DIF             reduce using rule 108 (termF -> empty .)
    OR              reduce using rule 108 (termF -> empty .)
    AND             reduce using rule 108 (termF -> empty .)
    COMMA           reduce using rule 108 (termF -> empty .)
    R_PAR           reduce using rule 108 (termF -> empty .)
    R_BREAK         reduce using rule 108 (termF -> empty .)
    TO              reduce using rule 108 (termF -> empty .)
    ID              reduce using rule 108 (termF -> empty .)
    RETURN          reduce using rule 108 (termF -> empty .)
    READ            reduce using rule 108 (termF -> empty .)
    WRITE           reduce using rule 108 (termF -> empty .)
    IF              reduce using rule 108 (termF -> empty .)
    VAR             reduce using rule 108 (termF -> empty .)
    WHILE           reduce using rule 108 (termF -> empty .)
    FROM            reduce using rule 108 (termF -> empty .)
    R_CURPAR        reduce using rule 108 (termF -> empty .)
    SEMICOLON       reduce using rule 108 (termF -> empty .)
    DO              reduce using rule 108 (termF -> empty .)


state 260

    (115) varcte -> var np_addId empty .

    MULT            reduce using rule 115 (varcte -> var np_addId empty .)
    DIV             reduce using rule 115 (varcte -> var np_addId empty .)
    PLUS            reduce using rule 115 (varcte -> var np_addId empty .)
    MINUS           reduce using rule 115 (varcte -> var np_addId empty .)
    LESS            reduce using rule 115 (varcte -> var np_addId empty .)
    GREATER         reduce using rule 115 (varcte -> var np_addId empty .)
    LESS_TH         reduce using rule 115 (varcte -> var np_addId empty .)
    GREAT_TH        reduce using rule 115 (varcte -> var np_addId empty .)
    SAME            reduce using rule 115 (varcte -> var np_addId empty .)
    DIF             reduce using rule 115 (varcte -> var np_addId empty .)
    OR              reduce using rule 115 (varcte -> var np_addId empty .)
    AND             reduce using rule 115 (varcte -> var np_addId empty .)
    COMMA           reduce using rule 115 (varcte -> var np_addId empty .)
    R_PAR           reduce using rule 115 (varcte -> var np_addId empty .)
    R_BREAK         reduce using rule 115 (varcte -> var np_addId empty .)
    TO              reduce using rule 115 (varcte -> var np_addId empty .)
    ID              reduce using rule 115 (varcte -> var np_addId empty .)
    RETURN          reduce using rule 115 (varcte -> var np_addId empty .)
    READ            reduce using rule 115 (varcte -> var np_addId empty .)
    WRITE           reduce using rule 115 (varcte -> var np_addId empty .)
    IF              reduce using rule 115 (varcte -> var np_addId empty .)
    VAR             reduce using rule 115 (varcte -> var np_addId empty .)
    WHILE           reduce using rule 115 (varcte -> var np_addId empty .)
    FROM            reduce using rule 115 (varcte -> var np_addId empty .)
    R_CURPAR        reduce using rule 115 (varcte -> var np_addId empty .)
    SEMICOLON       reduce using rule 115 (varcte -> var np_addId empty .)
    DO              reduce using rule 115 (varcte -> var np_addId empty .)


state 261

    (59) return -> RETURN L_PAR exp R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 298

state 262

    (65) readF -> var np_addRead COMMA . readF
    (65) readF -> . var np_addRead COMMA readF
    (66) readF -> . var np_addRead R_PAR SEMICOLON empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    VAR             shift and go to state 86
    ID              shift and go to state 143

    var                            shift and go to state 165
    readF                          shift and go to state 299

state 263

    (66) readF -> var np_addRead R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 300


state 264

    (70) writeF -> COMMA writeT .

    ID              reduce using rule 70 (writeF -> COMMA writeT .)
    RETURN          reduce using rule 70 (writeF -> COMMA writeT .)
    READ            reduce using rule 70 (writeF -> COMMA writeT .)
    WRITE           reduce using rule 70 (writeF -> COMMA writeT .)
    IF              reduce using rule 70 (writeF -> COMMA writeT .)
    VAR             reduce using rule 70 (writeF -> COMMA writeT .)
    WHILE           reduce using rule 70 (writeF -> COMMA writeT .)
    FROM            reduce using rule 70 (writeF -> COMMA writeT .)
    R_CURPAR        reduce using rule 70 (writeF -> COMMA writeT .)
    SEMICOLON       reduce using rule 70 (writeF -> COMMA writeT .)


state 265

    (71) writeF -> R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 301

state 266

    (74) if -> IF L_PAR exp R_PAR THEN . L_CURPAR statement SEMICOLON R_CURPAR ifF

    L_CURPAR        shift and go to state 302


state 267

    (54) arrfunc -> L_BREAK exp COMMA exp . R_BREAK empty

    R_BREAK         shift and go to state 303


state 268

    (55) arrfunc -> L_BREAK exp R_BREAK empty .

    EQUAL           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MIN_EQ          reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT_EQ         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV_EQ          reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MULT            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIV             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    PLUS            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    MINUS           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREATER         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    LESS_TH         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    GREAT_TH        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SAME            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DIF             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    OR              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    AND             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    COMMA           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_PAR           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_BREAK         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    TO              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    ID              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    RETURN          reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    READ            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WRITE           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    IF              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    VAR             reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    WHILE           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    FROM            reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    R_CURPAR        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    SEMICOLON       reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    DO              reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    L_PAR           reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_INT         reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)
    CTE_BOOL        reduce using rule 55 (arrfunc -> L_BREAK exp R_BREAK empty .)


state 269

    (84) conditional -> WHILE L_PAR exp R_PAR DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 304


state 270

    (87) nonconditionalF -> exp TO exp . DO L_CURPAR statement SEMICOLON R_CURPAR empty

    DO              shift and go to state 305


state 271

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON . empty
    (120) empty -> .

    CLASS           reduce using rule 120 (empty -> .)
    VARS            reduce using rule 120 (empty -> .)
    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)

    empty                          shift and go to state 306

state 272

    (16) decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .

    MAIN            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    INT             reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    FLOAT           reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    CHAR            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    BOOL            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    ID              reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    VOID            reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    METHODS         reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)
    L_CURPAR        reduce using rule 16 (decF -> COLON type np_getVarType SEMICOLON np_getDec np_addToDic empty .)


state 273

    (25) funcF -> parameter R_PAR SEMICOLON dec . L_CURPAR statement R_CURPAR empty

    L_CURPAR        shift and go to state 307


state 274

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    statement                      shift and go to state 308
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 275

    (33) parameter -> VAR COLON typepar SEMICOLON . parameterF
    (34) parameterF -> . parameter
    (35) parameterF -> . empty
    (33) parameter -> . VAR COLON typepar SEMICOLON parameterF
    (120) empty -> .

    VAR             shift and go to state 132
    R_PAR           reduce using rule 120 (empty -> .)

    parameterF                     shift and go to state 309
    parameter                      shift and go to state 310
    empty                          shift and go to state 311

state 276

    (36) typepar -> INT empty .

    SEMICOLON       reduce using rule 36 (typepar -> INT empty .)


state 277

    (37) typepar -> FLOAT empty .

    SEMICOLON       reduce using rule 37 (typepar -> FLOAT empty .)


state 278

    (38) typepar -> CHAR empty .

    SEMICOLON       reduce using rule 38 (typepar -> CHAR empty .)


state 279

    (39) typepar -> BOOL empty .

    SEMICOLON       reduce using rule 39 (typepar -> BOOL empty .)


state 280

    (40) typepar -> ID empty .

    SEMICOLON       reduce using rule 40 (typepar -> ID empty .)


state 281

    (78) assigmentF -> EQUAL np_addOp exp np_doAssign . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 312

state 282

    (79) assigmentF -> ope np_addOp exp np_doAssign . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 313

state 283

    (51) void -> ID DOT ID L_PAR param R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 314


state 284

    (109) factor -> L_PAR np_addPar exp R_PAR . np_popPar empty
    (130) np_popPar -> .

    MULT            reduce using rule 130 (np_popPar -> .)
    DIV             reduce using rule 130 (np_popPar -> .)
    PLUS            reduce using rule 130 (np_popPar -> .)
    MINUS           reduce using rule 130 (np_popPar -> .)
    LESS            reduce using rule 130 (np_popPar -> .)
    GREATER         reduce using rule 130 (np_popPar -> .)
    LESS_TH         reduce using rule 130 (np_popPar -> .)
    GREAT_TH        reduce using rule 130 (np_popPar -> .)
    SAME            reduce using rule 130 (np_popPar -> .)
    DIF             reduce using rule 130 (np_popPar -> .)
    OR              reduce using rule 130 (np_popPar -> .)
    AND             reduce using rule 130 (np_popPar -> .)
    COMMA           reduce using rule 130 (np_popPar -> .)
    R_PAR           reduce using rule 130 (np_popPar -> .)
    R_BREAK         reduce using rule 130 (np_popPar -> .)
    TO              reduce using rule 130 (np_popPar -> .)
    ID              reduce using rule 130 (np_popPar -> .)
    RETURN          reduce using rule 130 (np_popPar -> .)
    READ            reduce using rule 130 (np_popPar -> .)
    WRITE           reduce using rule 130 (np_popPar -> .)
    IF              reduce using rule 130 (np_popPar -> .)
    VAR             reduce using rule 130 (np_popPar -> .)
    WHILE           reduce using rule 130 (np_popPar -> .)
    FROM            reduce using rule 130 (np_popPar -> .)
    R_CURPAR        reduce using rule 130 (np_popPar -> .)
    SEMICOLON       reduce using rule 130 (np_popPar -> .)
    DO              reduce using rule 130 (np_popPar -> .)

    np_popPar                      shift and go to state 315

state 285

    (52) void -> ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 52 (void -> ID L_PAR param R_PAR SEMICOLON empty .)


state 286

    (89) boolF -> OR np_addOp . bool
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    bool                           shift and go to state 316
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 287

    (90) boolF -> AND np_addOp . bool
    (88) bool -> . logical np_addBool boolF
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    bool                           shift and go to state 317
    logical                        shift and go to state 149
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 288

    (93) logicalF -> LESS np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    logical                        shift and go to state 318
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 289

    (94) logicalF -> GREATER np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    logical                        shift and go to state 319
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 290

    (95) logicalF -> LESS_TH np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    logical                        shift and go to state 320
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 291

    (96) logicalF -> GREAT_TH np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    logical                        shift and go to state 321
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 292

    (97) logicalF -> SAME np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    logical                        shift and go to state 322
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 293

    (98) logicalF -> DIF np_addOp . logical
    (92) logical -> . ex np_addLogical logicalF
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    logical                        shift and go to state 323
    ex                             shift and go to state 150
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 294

    (102) exF -> PLUS np_addOp . ex
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    ex                             shift and go to state 324
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 295

    (103) exF -> MINUS np_addOp . ex
    (101) ex -> . term np_addEx exF
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    ex                             shift and go to state 325
    term                           shift and go to state 151
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 296

    (106) termF -> MULT np_addOp . term
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    term                           shift and go to state 326
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 297

    (107) termF -> DIV np_addOp . term
    (105) term -> . factor np_addTerm termF
    (109) factor -> . L_PAR np_addPar exp R_PAR np_popPar empty
    (110) factor -> . factorT
    (111) factorT -> . PLUS factorF
    (112) factorT -> . MINUS factorF
    (113) factorT -> . factorF
    (114) factorF -> . varcte empty
    (115) varcte -> . var np_addId empty
    (116) varcte -> . CTE_INT empty
    (117) varcte -> . CTE_FLOAT empty
    (118) varcte -> . CTE_CHAR empty
    (119) varcte -> . CTE_BOOL empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF

    L_PAR           shift and go to state 144
    PLUS            shift and go to state 154
    MINUS           shift and go to state 156
    CTE_INT         shift and go to state 159
    CTE_FLOAT       shift and go to state 160
    CTE_CHAR        shift and go to state 161
    CTE_BOOL        shift and go to state 162
    VAR             shift and go to state 86
    ID              shift and go to state 143

    term                           shift and go to state 327
    factor                         shift and go to state 152
    factorT                        shift and go to state 153
    factorF                        shift and go to state 155
    varcte                         shift and go to state 157
    var                            shift and go to state 158

state 298

    (59) return -> RETURN L_PAR exp R_PAR SEMICOLON empty .

    ID              reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    READ            reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    IF              reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    VAR             reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    FROM            reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 59 (return -> RETURN L_PAR exp R_PAR SEMICOLON empty .)


state 299

    (65) readF -> var np_addRead COMMA readF .

    ID              reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    RETURN          reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    READ            reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    WRITE           reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    IF              reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    VAR             reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    WHILE           reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    FROM            reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    R_CURPAR        reduce using rule 65 (readF -> var np_addRead COMMA readF .)
    SEMICOLON       reduce using rule 65 (readF -> var np_addRead COMMA readF .)


state 300

    (66) readF -> var np_addRead R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 328

state 301

    (71) writeF -> R_PAR SEMICOLON empty .

    ID              reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    READ            reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    IF              reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    VAR             reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    FROM            reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 71 (writeF -> R_PAR SEMICOLON empty .)


state 302

    (74) if -> IF L_PAR exp R_PAR THEN L_CURPAR . statement SEMICOLON R_CURPAR ifF
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    statement                      shift and go to state 329
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 303

    (54) arrfunc -> L_BREAK exp COMMA exp R_BREAK . empty
    (120) empty -> .

    EQUAL           reduce using rule 120 (empty -> .)
    PLUS_EQ         reduce using rule 120 (empty -> .)
    MIN_EQ          reduce using rule 120 (empty -> .)
    MULT_EQ         reduce using rule 120 (empty -> .)
    DIV_EQ          reduce using rule 120 (empty -> .)
    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)
    L_PAR           reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 330

state 304

    (84) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    statement                      shift and go to state 331
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 305

    (87) nonconditionalF -> exp TO exp DO . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 332


state 306

    (10) classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .

    CLASS           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VARS            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    MAIN            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    INT             reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    FLOAT           reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    CHAR            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    BOOL            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    ID              reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)
    VOID            reduce using rule 10 (classF -> SEMICOLON L_CURPAR ATTRIBUTES dec METHODS func R_CURPAR SEMICOLON empty .)


state 307

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR . statement R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    statement                      shift and go to state 333
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 308

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 334


state 309

    (33) parameter -> VAR COLON typepar SEMICOLON parameterF .

    R_PAR           reduce using rule 33 (parameter -> VAR COLON typepar SEMICOLON parameterF .)


state 310

    (34) parameterF -> parameter .

    R_PAR           reduce using rule 34 (parameterF -> parameter .)


state 311

    (35) parameterF -> empty .

    R_PAR           reduce using rule 35 (parameterF -> empty .)


state 312

    (78) assigmentF -> EQUAL np_addOp exp np_doAssign empty .

    ID              reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    RETURN          reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    READ            reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    WRITE           reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    IF              reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    VAR             reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    WHILE           reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    FROM            reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    R_CURPAR        reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)
    SEMICOLON       reduce using rule 78 (assigmentF -> EQUAL np_addOp exp np_doAssign empty .)


state 313

    (79) assigmentF -> ope np_addOp exp np_doAssign empty .

    ID              reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    RETURN          reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    READ            reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    WRITE           reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    IF              reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    VAR             reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    WHILE           reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    FROM            reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    R_CURPAR        reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)
    SEMICOLON       reduce using rule 79 (assigmentF -> ope np_addOp exp np_doAssign empty .)


state 314

    (51) void -> ID DOT ID L_PAR param R_PAR SEMICOLON . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 335

state 315

    (109) factor -> L_PAR np_addPar exp R_PAR np_popPar . empty
    (120) empty -> .

    MULT            reduce using rule 120 (empty -> .)
    DIV             reduce using rule 120 (empty -> .)
    PLUS            reduce using rule 120 (empty -> .)
    MINUS           reduce using rule 120 (empty -> .)
    LESS            reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESS_TH         reduce using rule 120 (empty -> .)
    GREAT_TH        reduce using rule 120 (empty -> .)
    SAME            reduce using rule 120 (empty -> .)
    DIF             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    R_PAR           reduce using rule 120 (empty -> .)
    R_BREAK         reduce using rule 120 (empty -> .)
    TO              reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    DO              reduce using rule 120 (empty -> .)

    empty                          shift and go to state 336

state 316

    (89) boolF -> OR np_addOp bool .

    COMMA           reduce using rule 89 (boolF -> OR np_addOp bool .)
    R_PAR           reduce using rule 89 (boolF -> OR np_addOp bool .)
    R_BREAK         reduce using rule 89 (boolF -> OR np_addOp bool .)
    TO              reduce using rule 89 (boolF -> OR np_addOp bool .)
    ID              reduce using rule 89 (boolF -> OR np_addOp bool .)
    RETURN          reduce using rule 89 (boolF -> OR np_addOp bool .)
    READ            reduce using rule 89 (boolF -> OR np_addOp bool .)
    WRITE           reduce using rule 89 (boolF -> OR np_addOp bool .)
    IF              reduce using rule 89 (boolF -> OR np_addOp bool .)
    VAR             reduce using rule 89 (boolF -> OR np_addOp bool .)
    WHILE           reduce using rule 89 (boolF -> OR np_addOp bool .)
    FROM            reduce using rule 89 (boolF -> OR np_addOp bool .)
    R_CURPAR        reduce using rule 89 (boolF -> OR np_addOp bool .)
    SEMICOLON       reduce using rule 89 (boolF -> OR np_addOp bool .)
    DO              reduce using rule 89 (boolF -> OR np_addOp bool .)


state 317

    (90) boolF -> AND np_addOp bool .

    COMMA           reduce using rule 90 (boolF -> AND np_addOp bool .)
    R_PAR           reduce using rule 90 (boolF -> AND np_addOp bool .)
    R_BREAK         reduce using rule 90 (boolF -> AND np_addOp bool .)
    TO              reduce using rule 90 (boolF -> AND np_addOp bool .)
    ID              reduce using rule 90 (boolF -> AND np_addOp bool .)
    RETURN          reduce using rule 90 (boolF -> AND np_addOp bool .)
    READ            reduce using rule 90 (boolF -> AND np_addOp bool .)
    WRITE           reduce using rule 90 (boolF -> AND np_addOp bool .)
    IF              reduce using rule 90 (boolF -> AND np_addOp bool .)
    VAR             reduce using rule 90 (boolF -> AND np_addOp bool .)
    WHILE           reduce using rule 90 (boolF -> AND np_addOp bool .)
    FROM            reduce using rule 90 (boolF -> AND np_addOp bool .)
    R_CURPAR        reduce using rule 90 (boolF -> AND np_addOp bool .)
    SEMICOLON       reduce using rule 90 (boolF -> AND np_addOp bool .)
    DO              reduce using rule 90 (boolF -> AND np_addOp bool .)


state 318

    (93) logicalF -> LESS np_addOp logical .

    OR              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    AND             reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    COMMA           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_PAR           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_BREAK         reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    TO              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    ID              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    RETURN          reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    READ            reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    WRITE           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    IF              reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    VAR             reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    WHILE           reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    FROM            reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    R_CURPAR        reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    SEMICOLON       reduce using rule 93 (logicalF -> LESS np_addOp logical .)
    DO              reduce using rule 93 (logicalF -> LESS np_addOp logical .)


state 319

    (94) logicalF -> GREATER np_addOp logical .

    OR              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    AND             reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    COMMA           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_PAR           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_BREAK         reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    TO              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    ID              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    RETURN          reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    READ            reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    WRITE           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    IF              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    VAR             reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    WHILE           reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    FROM            reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    R_CURPAR        reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    SEMICOLON       reduce using rule 94 (logicalF -> GREATER np_addOp logical .)
    DO              reduce using rule 94 (logicalF -> GREATER np_addOp logical .)


state 320

    (95) logicalF -> LESS_TH np_addOp logical .

    OR              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    AND             reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    COMMA           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_PAR           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_BREAK         reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    TO              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    ID              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    RETURN          reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    READ            reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    WRITE           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    IF              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    VAR             reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    WHILE           reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    FROM            reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    R_CURPAR        reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    SEMICOLON       reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)
    DO              reduce using rule 95 (logicalF -> LESS_TH np_addOp logical .)


state 321

    (96) logicalF -> GREAT_TH np_addOp logical .

    OR              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    AND             reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    COMMA           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_PAR           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_BREAK         reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    TO              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    ID              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    RETURN          reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    READ            reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    WRITE           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    IF              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    VAR             reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    WHILE           reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    FROM            reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    R_CURPAR        reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    SEMICOLON       reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)
    DO              reduce using rule 96 (logicalF -> GREAT_TH np_addOp logical .)


state 322

    (97) logicalF -> SAME np_addOp logical .

    OR              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    AND             reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    COMMA           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_PAR           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_BREAK         reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    TO              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    ID              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    RETURN          reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    READ            reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    WRITE           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    IF              reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    VAR             reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    WHILE           reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    FROM            reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    R_CURPAR        reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    SEMICOLON       reduce using rule 97 (logicalF -> SAME np_addOp logical .)
    DO              reduce using rule 97 (logicalF -> SAME np_addOp logical .)


state 323

    (98) logicalF -> DIF np_addOp logical .

    OR              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    AND             reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    COMMA           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_PAR           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_BREAK         reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    TO              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    ID              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    RETURN          reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    READ            reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    WRITE           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    IF              reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    VAR             reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    WHILE           reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    FROM            reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    R_CURPAR        reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    SEMICOLON       reduce using rule 98 (logicalF -> DIF np_addOp logical .)
    DO              reduce using rule 98 (logicalF -> DIF np_addOp logical .)


state 324

    (102) exF -> PLUS np_addOp ex .

    LESS            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    GREATER         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    LESS_TH         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    GREAT_TH        reduce using rule 102 (exF -> PLUS np_addOp ex .)
    SAME            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    DIF             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    OR              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    AND             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    COMMA           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_PAR           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_BREAK         reduce using rule 102 (exF -> PLUS np_addOp ex .)
    TO              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    ID              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    RETURN          reduce using rule 102 (exF -> PLUS np_addOp ex .)
    READ            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    WRITE           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    IF              reduce using rule 102 (exF -> PLUS np_addOp ex .)
    VAR             reduce using rule 102 (exF -> PLUS np_addOp ex .)
    WHILE           reduce using rule 102 (exF -> PLUS np_addOp ex .)
    FROM            reduce using rule 102 (exF -> PLUS np_addOp ex .)
    R_CURPAR        reduce using rule 102 (exF -> PLUS np_addOp ex .)
    SEMICOLON       reduce using rule 102 (exF -> PLUS np_addOp ex .)
    DO              reduce using rule 102 (exF -> PLUS np_addOp ex .)


state 325

    (103) exF -> MINUS np_addOp ex .

    LESS            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    GREATER         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    LESS_TH         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    GREAT_TH        reduce using rule 103 (exF -> MINUS np_addOp ex .)
    SAME            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    DIF             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    OR              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    AND             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    COMMA           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_PAR           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_BREAK         reduce using rule 103 (exF -> MINUS np_addOp ex .)
    TO              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    ID              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    RETURN          reduce using rule 103 (exF -> MINUS np_addOp ex .)
    READ            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    WRITE           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    IF              reduce using rule 103 (exF -> MINUS np_addOp ex .)
    VAR             reduce using rule 103 (exF -> MINUS np_addOp ex .)
    WHILE           reduce using rule 103 (exF -> MINUS np_addOp ex .)
    FROM            reduce using rule 103 (exF -> MINUS np_addOp ex .)
    R_CURPAR        reduce using rule 103 (exF -> MINUS np_addOp ex .)
    SEMICOLON       reduce using rule 103 (exF -> MINUS np_addOp ex .)
    DO              reduce using rule 103 (exF -> MINUS np_addOp ex .)


state 326

    (106) termF -> MULT np_addOp term .

    PLUS            reduce using rule 106 (termF -> MULT np_addOp term .)
    MINUS           reduce using rule 106 (termF -> MULT np_addOp term .)
    LESS            reduce using rule 106 (termF -> MULT np_addOp term .)
    GREATER         reduce using rule 106 (termF -> MULT np_addOp term .)
    LESS_TH         reduce using rule 106 (termF -> MULT np_addOp term .)
    GREAT_TH        reduce using rule 106 (termF -> MULT np_addOp term .)
    SAME            reduce using rule 106 (termF -> MULT np_addOp term .)
    DIF             reduce using rule 106 (termF -> MULT np_addOp term .)
    OR              reduce using rule 106 (termF -> MULT np_addOp term .)
    AND             reduce using rule 106 (termF -> MULT np_addOp term .)
    COMMA           reduce using rule 106 (termF -> MULT np_addOp term .)
    R_PAR           reduce using rule 106 (termF -> MULT np_addOp term .)
    R_BREAK         reduce using rule 106 (termF -> MULT np_addOp term .)
    TO              reduce using rule 106 (termF -> MULT np_addOp term .)
    ID              reduce using rule 106 (termF -> MULT np_addOp term .)
    RETURN          reduce using rule 106 (termF -> MULT np_addOp term .)
    READ            reduce using rule 106 (termF -> MULT np_addOp term .)
    WRITE           reduce using rule 106 (termF -> MULT np_addOp term .)
    IF              reduce using rule 106 (termF -> MULT np_addOp term .)
    VAR             reduce using rule 106 (termF -> MULT np_addOp term .)
    WHILE           reduce using rule 106 (termF -> MULT np_addOp term .)
    FROM            reduce using rule 106 (termF -> MULT np_addOp term .)
    R_CURPAR        reduce using rule 106 (termF -> MULT np_addOp term .)
    SEMICOLON       reduce using rule 106 (termF -> MULT np_addOp term .)
    DO              reduce using rule 106 (termF -> MULT np_addOp term .)


state 327

    (107) termF -> DIV np_addOp term .

    PLUS            reduce using rule 107 (termF -> DIV np_addOp term .)
    MINUS           reduce using rule 107 (termF -> DIV np_addOp term .)
    LESS            reduce using rule 107 (termF -> DIV np_addOp term .)
    GREATER         reduce using rule 107 (termF -> DIV np_addOp term .)
    LESS_TH         reduce using rule 107 (termF -> DIV np_addOp term .)
    GREAT_TH        reduce using rule 107 (termF -> DIV np_addOp term .)
    SAME            reduce using rule 107 (termF -> DIV np_addOp term .)
    DIF             reduce using rule 107 (termF -> DIV np_addOp term .)
    OR              reduce using rule 107 (termF -> DIV np_addOp term .)
    AND             reduce using rule 107 (termF -> DIV np_addOp term .)
    COMMA           reduce using rule 107 (termF -> DIV np_addOp term .)
    R_PAR           reduce using rule 107 (termF -> DIV np_addOp term .)
    R_BREAK         reduce using rule 107 (termF -> DIV np_addOp term .)
    TO              reduce using rule 107 (termF -> DIV np_addOp term .)
    ID              reduce using rule 107 (termF -> DIV np_addOp term .)
    RETURN          reduce using rule 107 (termF -> DIV np_addOp term .)
    READ            reduce using rule 107 (termF -> DIV np_addOp term .)
    WRITE           reduce using rule 107 (termF -> DIV np_addOp term .)
    IF              reduce using rule 107 (termF -> DIV np_addOp term .)
    VAR             reduce using rule 107 (termF -> DIV np_addOp term .)
    WHILE           reduce using rule 107 (termF -> DIV np_addOp term .)
    FROM            reduce using rule 107 (termF -> DIV np_addOp term .)
    R_CURPAR        reduce using rule 107 (termF -> DIV np_addOp term .)
    SEMICOLON       reduce using rule 107 (termF -> DIV np_addOp term .)
    DO              reduce using rule 107 (termF -> DIV np_addOp term .)


state 328

    (66) readF -> var np_addRead R_PAR SEMICOLON empty .

    ID              reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    READ            reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    IF              reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    VAR             reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    FROM            reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 66 (readF -> var np_addRead R_PAR SEMICOLON empty .)


state 329

    (74) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement . SEMICOLON R_CURPAR ifF

    SEMICOLON       shift and go to state 337


state 330

    (54) arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .

    EQUAL           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS_EQ         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MIN_EQ          reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT_EQ         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV_EQ          reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MULT            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIV             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    PLUS            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    MINUS           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREATER         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    LESS_TH         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    GREAT_TH        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SAME            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DIF             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    OR              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    AND             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    COMMA           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_PAR           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_BREAK         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    TO              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    ID              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    RETURN          reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    READ            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WRITE           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    IF              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    VAR             reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    WHILE           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    FROM            reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    R_CURPAR        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    SEMICOLON       reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    DO              reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    L_PAR           reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_INT         reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_FLOAT       reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_CHAR        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)
    CTE_BOOL        reduce using rule 54 (arrfunc -> L_BREAK exp COMMA exp R_BREAK empty .)


state 331

    (84) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 338


state 332

    (87) nonconditionalF -> exp TO exp DO L_CURPAR . statement SEMICOLON R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    statement                      shift and go to state 339
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 333

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement . R_CURPAR empty

    R_CURPAR        shift and go to state 340


state 334

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 341

state 335

    (51) void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .

    ID              reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    RETURN          reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    READ            reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WRITE           reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    IF              reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    VAR             reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    WHILE           reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    FROM            reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    R_CURPAR        reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)
    SEMICOLON       reduce using rule 51 (void -> ID DOT ID L_PAR param R_PAR SEMICOLON empty .)


state 336

    (109) factor -> L_PAR np_addPar exp R_PAR np_popPar empty .

    MULT            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIV             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    PLUS            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    MINUS           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREATER         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    LESS_TH         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    GREAT_TH        reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SAME            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DIF             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    OR              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    AND             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    COMMA           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_PAR           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_BREAK         reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    TO              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    ID              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    RETURN          reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    READ            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    WRITE           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    IF              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    VAR             reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    WHILE           reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    FROM            reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    R_CURPAR        reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    SEMICOLON       reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)
    DO              reduce using rule 109 (factor -> L_PAR np_addPar exp R_PAR np_popPar empty .)


state 337

    (74) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON . R_CURPAR ifF

    R_CURPAR        shift and go to state 342


state 338

    (84) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 343


state 339

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 344


state 340

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR . empty
    (120) empty -> .

    MAIN            reduce using rule 120 (empty -> .)
    INT             reduce using rule 120 (empty -> .)
    FLOAT           reduce using rule 120 (empty -> .)
    CHAR            reduce using rule 120 (empty -> .)
    BOOL            reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    VOID            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)

    empty                          shift and go to state 345

state 341

    (26) funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    BOOL            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 26 (funcF -> R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 342

    (74) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR . ifF
    (75) ifF -> . ELSE L_CURPAR statement SEMICOLON R_CURPAR empty
    (76) ifF -> . empty
    (120) empty -> .

    ELSE            shift and go to state 347
    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    ifF                            shift and go to state 346
    empty                          shift and go to state 348

state 343

    (84) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 349

state 344

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 350


state 345

    (25) funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .

    MAIN            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    INT             reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    FLOAT           reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    CHAR            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    BOOL            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    ID              reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    VOID            reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)
    R_CURPAR        reduce using rule 25 (funcF -> parameter R_PAR SEMICOLON dec L_CURPAR statement R_CURPAR empty .)


state 346

    (74) if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .

    ID              reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    RETURN          reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    READ            reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WRITE           reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    IF              reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    VAR             reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    WHILE           reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    FROM            reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    R_CURPAR        reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)
    SEMICOLON       reduce using rule 74 (if -> IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF .)


state 347

    (75) ifF -> ELSE . L_CURPAR statement SEMICOLON R_CURPAR empty

    L_CURPAR        shift and go to state 351


state 348

    (76) ifF -> empty .

    ID              reduce using rule 76 (ifF -> empty .)
    RETURN          reduce using rule 76 (ifF -> empty .)
    READ            reduce using rule 76 (ifF -> empty .)
    WRITE           reduce using rule 76 (ifF -> empty .)
    IF              reduce using rule 76 (ifF -> empty .)
    VAR             reduce using rule 76 (ifF -> empty .)
    WHILE           reduce using rule 76 (ifF -> empty .)
    FROM            reduce using rule 76 (ifF -> empty .)
    R_CURPAR        reduce using rule 76 (ifF -> empty .)
    SEMICOLON       reduce using rule 76 (ifF -> empty .)


state 349

    (84) conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 84 (conditional -> WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 350

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 352

state 351

    (75) ifF -> ELSE L_CURPAR . statement SEMICOLON R_CURPAR empty
    (42) statement -> . assigment statementF
    (43) statement -> . void statementF
    (44) statement -> . return statementF
    (45) statement -> . read statementF
    (46) statement -> . write statementF
    (47) statement -> . if statementF
    (48) statement -> . repeat statementF
    (77) assigment -> . var np_addId assigmentF
    (51) void -> . ID DOT ID L_PAR param R_PAR SEMICOLON empty
    (52) void -> . ID L_PAR param R_PAR SEMICOLON empty
    (53) void -> . ID L_PAR R_PAR SEMICOLON empty
    (59) return -> . RETURN L_PAR exp R_PAR SEMICOLON empty
    (64) read -> . READ L_PAR readF
    (67) write -> . WRITE L_PAR writeT
    (74) if -> . IF L_PAR exp R_PAR THEN L_CURPAR statement SEMICOLON R_CURPAR ifF
    (72) repeat -> . conditional empty
    (73) repeat -> . nonconditional empty
    (60) var -> . VAR varF
    (61) var -> . ID DOT VAR varF
    (84) conditional -> . WHILE L_PAR exp R_PAR DO L_CURPAR statement SEMICOLON R_CURPAR empty
    (85) nonconditional -> . FROM VAR arrfunc nonconditionalF
    (86) nonconditional -> . FROM VAR nonconditionalF

    ID              shift and go to state 79
    RETURN          shift and go to state 80
    READ            shift and go to state 81
    WRITE           shift and go to state 82
    IF              shift and go to state 83
    VAR             shift and go to state 86
    WHILE           shift and go to state 87
    FROM            shift and go to state 88

    statement                      shift and go to state 353
    assigment                      shift and go to state 71
    void                           shift and go to state 72
    return                         shift and go to state 73
    read                           shift and go to state 74
    write                          shift and go to state 75
    if                             shift and go to state 76
    repeat                         shift and go to state 77
    var                            shift and go to state 78
    conditional                    shift and go to state 84
    nonconditional                 shift and go to state 85

state 352

    (87) nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 87 (nonconditionalF -> exp TO exp DO L_CURPAR statement SEMICOLON R_CURPAR empty .)


state 353

    (75) ifF -> ELSE L_CURPAR statement . SEMICOLON R_CURPAR empty

    SEMICOLON       shift and go to state 354


state 354

    (75) ifF -> ELSE L_CURPAR statement SEMICOLON . R_CURPAR empty

    R_CURPAR        shift and go to state 355


state 355

    (75) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR . empty
    (120) empty -> .

    ID              reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    WRITE           reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    VAR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    FROM            reduce using rule 120 (empty -> .)
    R_CURPAR        reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)

    empty                          shift and go to state 356

state 356

    (75) ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .

    ID              reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    RETURN          reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    READ            reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WRITE           reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    IF              reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    VAR             reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    WHILE           reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    FROM            reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    R_CURPAR        reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)
    SEMICOLON       reduce using rule 75 (ifF -> ELSE L_CURPAR statement SEMICOLON R_CURPAR empty .)

